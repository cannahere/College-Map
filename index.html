<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="google-site-verification" content="XLI_3QT03lSkcCEmteQWtQeDviYsA07lmIbGu_5GKCc" />
  <meta name="msvalidate.01" content="CA49DC12684491A5E489D6BA5BD08ED5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Branding and Icons -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="manifest" href="site.webmanifest">

  <!-- SEO Meta Tags -->
  <title>U.S. College Map | Explore Colleges by Type, Near You, or Along Your Route</title>
  <link rel="canonical" href="https://uscollegemap.org/">
  <meta name="description" content="U.S. College Map helps students and families explore colleges anywhere in the United States. Search by type, region, state, or name ‚Äî or enter any address or travel route to see nearby schools. A simple tool for early research and campus visit planning.">
  <meta name="keywords" content="college map, university map, US colleges, college finder, college search, college visit planning, college by location, interactive map, higher education USA, find colleges near me, college visit planning, college map, find colleges near me, colleges along a route, college search tool, campus visit planner, college route planner">
  <meta name="author" content="U.S. College Map">

  <!-- Open Graph (Social Media Preview) -->
  <meta property="og:title" content="U.S. College Map | Explore Colleges by Location and Type">
  <meta property="og:description" content="Use the U.S. College Map to explore accredited colleges by state, region, or type ‚Äî a simple way to plan your next campus visit.">
  <meta property="og:image" content="https://uscollegemap.org/us-college-map-logo.png">
<meta property="og:url" content="https://uscollegemap.org/">
<meta property="og:type" content="website">
<meta property="og:site_name" content="U.S. College Map">

  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="U.S. College Map ‚Äî Explore and Plan College Visits">
  <meta name="twitter:description" content="Interactive map of U.S. colleges. Filter by region, state, or school type to find and plan your next college visit.">
  <meta name="twitter:image" content="https://uscollegemap.org/us-college-map-logo.png">

  <!-- Schema Markup (Structured Data) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "U.S. College Map",
    "url": "https://uscollegemap.org/",
    "description": "Interactive map of U.S. colleges and universities by state, region, and school type. Filter and explore campus locations easily.",
    "applicationCategory": "Education",
    "operatingSystem": "All",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "creator": {
      "@type": "Organization",
      "name": "U.S. College Map"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "ratingCount": "150"
    },
    "featureList": [
      "Interactive map of all U.S. colleges",
      "Filter by state, region, or school type",
      "Search by college name",
      "Find colleges near your location",
      "Plan college visits efficiently"
    ]
  }
  </script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "url": "https://uscollegemap.org/",
    "name": "U.S. College Map",
    "alternateName": "US College Map"
  }
  </script>
  
  <!-- BreadcrumbList Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [{
      "@type": "ListItem",
      "position": 1,
      "name": "Home",
      "item": "https://uscollegemap.org/"
    }]
  }
  </script>

  <!-- Resource Hints for Performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://nominatim.openstreetmap.org">

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body {margin:0;font-family:Inter,system-ui,sans-serif;background:#fff;color:#0f172a}
    .main-container {display:flex;flex-direction:column;min-height:100vh}
    .container {max-width:1100px;margin:0 auto;padding:16px}
    header.app-header {position:sticky;top:0;background:#fff;z-index:10;border-bottom:1px solid #e2e8f0;box-shadow:0 10px 25px rgba(15,23,42,.08)}
    .app-header {display:flex;align-items:flex-start;justify-content:flex-start;padding:16px 40px;background:#fff;border-bottom:1px solid #e5e7eb;box-shadow:0 4px 10px rgba(0,0,0,0.05)}
    .header-logo-tagline {display:flex;flex-direction:column;align-items:flex-start;gap:0}
    .site-logo {height:70px;width:auto;object-fit:contain;transition:all 0.3s ease;margin-bottom:0}
    .tagline {font-family:Inter,sans-serif;font-size:14px;color:#6b7280;line-height:1.5;text-align:left;margin:0;margin-top:4px;margin-bottom:3px;margin-left:10px;font-weight:400;max-width:calc(100% - 10px)}
    .sr-only {position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}
    @media (max-width:700px){
      .app-header{flex-direction:row;align-items:flex-start;text-align:left;padding:12px 16px;}
      .header-logo-tagline{align-items:flex-start;text-align:left}
      .tagline{text-align:left;margin-left:0;max-width:100%;font-size:12px;color:#94A3B8;line-height:1.4;margin-top:4px;margin-bottom:6px}
      .site-logo{height:56px;width:auto;object-fit:contain;margin-bottom:0;}
      .container{padding:6px;}
      .controls{padding:8px 8px;gap:2px;}
      .row-filters{flex-direction:row;gap:6px;flex-wrap:nowrap;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);min-width:0;}
      .row-filters .pill label{display:none}
      .row-filters .pill select{width:100%;font-size:12px;padding:6px 8px;}
      .row-filters .pill-search{display:none !important}
      .row-search{display:flex !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .row-nearby .pill.address-autocomplete{flex:1 1 100%;}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:14px;}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:6px 10px;margin-left:4px;}
      .row-nearby .pill:not(.address-autocomplete){flex:1 1 100%;flex-direction:row;align-items:center;flex-wrap:wrap;padding:6px;}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:12px !important;font-weight:600;color:#475569;}
      .row-nearby #radius{width:80px;flex:0 0 auto;max-width:80px;}
      .row-nearby #units{width:60px;flex:0 0 auto;max-width:60px;}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:8px;}
      .pill{flex-direction:row;align-items:center;padding:6px;}
      .pill label{min-width:60px;margin-bottom:0;width:auto;font-size:11px;}
      .pill input,.pill select,.pill button{width:auto;flex:1;}
      .legend{position:relative;bottom:auto;left:auto;margin:6px;width:calc(100% - 12px);text-align:center;}
    }
    .controls {display:flex;flex-direction:column;gap:3px;padding:10px 12px 6px;border-top:1px solid #e5e7eb;background:#fff}
    .row {display:flex;gap:8px;justify-content:space-between}
    .row>.pill {flex:1}
    .row-filters{display:flex;gap:8px;justify-content:space-between}
    .row-filters .pill{flex:1}
    .row-search{display:none}
    .row-filters .pill-search{display:none}
    @media (min-width:1025px) {
      .row-filters .pill-search{display:flex}
      .row-search{display:none}
      .controls{flex-direction:row;flex-wrap:wrap;align-items:flex-start}
      .row-filters{flex:1 1 100%;margin-bottom:3px}
      .row-filters .pill:not(.pill-search){flex:0 1 180px}
      .row-filters .pill-search{flex:1 1 auto;min-width:200px}
      .row-filters .pill-search input{font-size:14px}
      .row-nearby{display:flex;flex-direction:row;gap:8px;flex-wrap:nowrap;margin-bottom:0;align-items:center}
      .row-nearby .pill.address-autocomplete{flex:1 1 auto;min-width:0}
      .row-nearby .pill.address-autocomplete label{min-width:60px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{font-size:14px}
      .row-nearby .pill.address-autocomplete button{font-size:14px}
      .row-nearby .pill:not(.address-autocomplete){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:60px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-nearby #radius{width:70px;flex:0 0 auto;font-size:14px}
      .row-nearby #units{width:55px;flex:0 0 auto;font-size:14px}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
      .row-route{display:flex;flex-direction:row;gap:8px;flex-wrap:nowrap;margin-bottom:0;align-items:center}
      .row-route .pill{flex:1 1 auto;min-width:0}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex:1 1 auto;min-width:0}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:45px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:14px}
      .row-route .pill:has(#routeMaxDistance){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-route .pill:has(#routeMaxDistance) label{min-width:75px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:70px;flex:0 0 auto;font-size:14px}
      .row-route #routeUnits{width:55px;flex:0 0 auto;font-size:14px}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
      .row-route #clearRoute{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
    }
    .pill {display:flex;align-items:center;gap:6px;background:#f1f5f9;border:1px solid #e2e8f0;padding:4px 8px;border-radius:12px;font-size:12px}
    .pill label {color:#475569;font-weight:600;font-size:12px;min-width:60px}
    .pill input,.pill select,.pill button {border:1px solid #e2e8f0;border-radius:10px;padding:6px 8px;background:#fff;color:#0f172a;font-size:14px;flex:1;transition:border-color 0.2s,box-shadow 0.2s}
    .pill input:focus {outline:none;border-color:#4285f4;box-shadow:0 0 0 1px #4285f4}
    .pill button {background:#2563eb;color:#fff;border:none;font-weight:600;cursor:pointer;flex:0}
    #map {height:calc(100vh - 280px);background:#e5e7eb;border-top:1px solid #e2e8f0;position:relative;z-index:1;min-height:500px}
    .legend {position:absolute;bottom:14px;left:14px;background:#fff;padding:8px 10px;border-radius:12px;border:1px solid #e2e8f0;font-size:12px;box-shadow:0 10px 25px rgba(15,23,42,.08);color:#0f172a}
    .map-hint-bubble {position:absolute;top:16px;right:16px;background:rgba(255,255,255,0.98);padding:12px 14px;border-radius:12px;box-shadow:0 8px 20px rgba(15,23,42,0.18);font-size:0.875rem;max-width:260px;display:none;z-index:2000;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(226,232,240,0.8)}
    .map-hint-bubble.active {display:block;animation:fadeIn 0.2s ease-out}
    .map-hint-bubble-header {display:flex;align-items:center;gap:8px;margin-bottom:6px}
    .map-hint-bubble-icon {font-size:16px;line-height:1;flex-shrink:0}
    .map-hint-bubble-close {background:none;border:none;color:#94a3b8;cursor:pointer;font-size:18px;line-height:1;padding:0;width:18px;height:18px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:color 0.2s;margin-left:auto;margin-top:-2px;margin-right:-4px}
    .map-hint-bubble-close:hover {color:#64748b}
    .map-hint-bubble-title {font-weight:600;font-size:0.875rem;line-height:1.4;color:#0f172a;flex:1}
    .map-hint-bubble-body {font-size:0.8125rem;line-height:1.5;color:#64748b}
    @media (max-width:700px) {
      .map-hint-bubble {top:12px;right:12px;left:12px;max-width:calc(100vw - 24px);width:calc(100vw - 24px);box-sizing:border-box}
    }
    .map-tip-bubble {position:absolute;top:16px;right:16px;background:rgba(255,255,255,0.98);padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(15,23,42,0.18);font-size:0.8125rem;max-width:240px;display:none;z-index:2001;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(226,232,240,0.8)}
    /* Adjust tip position when hint bubbles are visible to avoid overlap */
    .map-hint-bubble.active ~ .map-tip-bubble {top:80px}
    .map-tip-bubble.active {display:block;animation:fadeIn 0.2s ease-out}
    .map-tip-bubble-content {display:flex;align-items:center;gap:8px}
    .map-tip-bubble-icon {font-size:14px;line-height:1;flex-shrink:0}
    .map-tip-bubble-text {font-size:0.8125rem;line-height:1.4;color:#0f172a;flex:1}
    .map-tip-bubble-close {background:none;border:none;color:#94a3b8;cursor:pointer;font-size:16px;line-height:1;padding:0;width:16px;height:16px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:color 0.2s;margin-left:4px}
    .map-tip-bubble-close:hover {color:#64748b}
    @media (max-width:700px) {
      .map-tip-bubble {top:12px;right:12px;left:12px;max-width:none;font-size:0.75rem;padding:8px 10px}
      .map-tip-bubble-icon {font-size:12px}
    }
    .leaflet-tooltip {background:#fff;color:#0f172a;border:1px solid #e2e8f0;border-radius:6px;font-size:12px;font-weight:500;padding:4px 8px;box-shadow:0 2px 6px rgba(0,0,0,.1)}
    .loading {display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;padding:20px;border-radius:12px;box-shadow:0 10px 25px rgba(15,23,42,.15);z-index:1000}
    .loading.active {display:block}
    .error {display:none;background:#fee;color:#c33;padding:12px;border-radius:8px;margin:12px;border:1px solid #fcc}
    .error.active {display:block}
    .site-footer {background:#fff;border-top:1px solid #e2e8f0;padding:10px 16px;font-size:12px;color:#94A3B8;text-align:center}
    .feedback-button {position:fixed;bottom:18px;right:18px;background:#2563eb;color:#fff;border:none;padding:10px 16px;border-radius:8px;font-family:Inter,sans-serif;font-size:14px;font-weight:500;cursor:pointer;box-shadow:0 4px 12px rgba(37,99,235,0.3);z-index:1000;transition:all 0.2s ease}
    .feedback-button:hover {background:#1d4ed8;box-shadow:0 6px 16px rgba(37,99,235,0.4);transform:translateY(-2px)}
    .feedback-button.hidden {display:none}
    .feedback-popup {position:fixed;bottom:70px;right:18px;width:280px;background:#fff;border-radius:12px;box-shadow:0 10px 25px rgba(15,23,42,.15);border:1px solid #e2e8f0;z-index:1001;padding:20px;display:none;animation:fadeIn 0.2s ease-out}
    .feedback-popup.active {display:block}
    .feedback-popup-header {display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px;margin-top:-2px}
    .feedback-popup-close {background:none;border:none;font-size:24px;color:#94a3b8;cursor:pointer;line-height:1;padding:0;width:24px;height:24px;display:flex;align-items:center;justify-content:center;transition:color 0.2s}
    .feedback-popup-close:hover {color:#64748b}
    .feedback-popup-message {font-size:14px;color:#0f172a;line-height:1.5;margin-bottom:16px}
    .feedback-popup-button {display:inline-block;background:#2563eb;color:#fff;border:none;padding:10px 28px;border-radius:8px;font-family:Inter,sans-serif;font-size:14px;font-weight:500;cursor:pointer;transition:background 0.2s}
    .feedback-popup-button-wrapper {text-align:center;margin-bottom:12px}
    .feedback-popup-button:hover {background:#1d4ed8}
    .feedback-popup-dismiss {display:block;text-align:center;font-size:12px;color:#94a3b8;text-decoration:none;cursor:pointer;transition:color 0.2s}
    .feedback-popup-dismiss:hover {color:#64748b}
    @media (max-width:700px){
      .feedback-popup {width:calc(100% - 36px);max-width:280px;right:18px;left:auto}
    }
    .radius-circle {stroke:#2563eb;stroke-width:2;stroke-dasharray:5,5;fill:none;opacity:0.5;pointer-events:none}
    .address-autocomplete {position:relative;z-index:10;isolation:isolate}
    .address-autocomplete.autocomplete-active {z-index:3000}
    .autocomplete-suggestions {display:none;position:absolute;top:calc(100% + 4px);left:0;right:0;background:#fff;border:none;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.1),0 8px 24px rgba(0,0,0,0.12);max-height:400px;overflow-y:auto;overflow-x:hidden;z-index:1001;margin-top:0;pointer-events:auto;transform:translateZ(0);will-change:transform}
    .autocomplete-suggestions.active {display:block;animation:fadeIn 0.15s ease-out}
    @keyframes fadeIn {from{opacity:0;transform:translateY(-4px)} to{opacity:1;transform:translateY(0)}}
    .autocomplete-item {padding:0;cursor:pointer;border-bottom:none;font-size:14px;transition:background-color 0.1s;min-height:48px;display:flex;flex-direction:row;align-items:center;position:relative;width:100%;pointer-events:auto;user-select:none;-webkit-user-select:none}
    .autocomplete-item:not(:last-child)::after {content:'';position:absolute;bottom:0;left:56px;right:0;height:1px;background:#f1f5f9}
    .autocomplete-item:hover,.autocomplete-item.highlighted {background-color:#f8f9fa}
    .autocomplete-item:focus {outline:2px solid #4285f4;outline-offset:-2px;background-color:#f8f9fa}
    .autocomplete-item-icon {width:40px;height:40px;display:flex;align-items:center;justify-content:center;flex-shrink:0;margin-left:8px}
    .autocomplete-item-icon svg {width:20px;height:20px;fill:#5f6368;display:block}
    .autocomplete-item.highlighted .autocomplete-item-icon svg,.autocomplete-item:hover .autocomplete-item-icon svg {fill:#4285f4}
    .autocomplete-item-content {flex:1;padding:12px 8px 12px 0;min-width:0;display:flex;flex-direction:column;justify-content:center}
    .autocomplete-item .address-name {font-weight:400;color:#202124;margin-bottom:2px;font-size:15px;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .autocomplete-item .address-name strong {font-weight:500;color:#202124}
    .autocomplete-item.highlighted .address-name,.autocomplete-item:hover .address-name {color:#1a73e8}
    .autocomplete-item.highlighted .address-name strong,.autocomplete-item:hover .address-name strong {color:#1a73e8;font-weight:500}
    .autocomplete-item .address-details {font-size:13px;color:#5f6368;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .autocomplete-loading {padding:16px;text-align:center;color:#5f6368;font-size:14px;display:flex;align-items:center;justify-content:center;gap:8px}
    .autocomplete-loading::before {content:'';width:16px;height:16px;border:2px solid #e0e0e0;border-top-color:#4285f4;border-radius:50%;animation:spin 0.8s linear infinite}
    @keyframes spin {to{transform:rotate(360deg)}}
    .autocomplete-empty {padding:24px;text-align:center;color:#5f6368;font-size:14px}
    .autocomplete-section-title{padding:10px 16px;font-size:12px;letter-spacing:0.08em;text-transform:uppercase;color:#94a3b8;font-weight:600}
    .autocomplete-divider{height:1px;background:#e2e8f0;margin:4px 0}
    @media (max-width: 700px) {
      .autocomplete-item {min-height:52px}
      .autocomplete-item-icon {width:44px;height:44px;margin-left:12px}
      .autocomplete-item-content {padding:14px 12px 14px 0}
      .row-nearby{flex-direction:column;gap:6px}
      .row-nearby .pill.address-autocomplete{flex-direction:row;align-items:center;flex-wrap:wrap}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:11px !important;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:12px !important}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-nearby .pill:not(.address-autocomplete){flex-direction:row;align-items:center;flex-wrap:wrap}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:11px !important;font-weight:600;color:#475569}
      .row-nearby #radius{width:50px !important;flex:0 0 auto;max-width:50px;font-size:12px !important}
      .row-nearby #units{width:48px !important;flex:0 0 auto;max-width:48px;font-size:12px !important}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-route{flex-direction:column;gap:6px}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex-direction:row;align-items:center}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:40px !important;margin-bottom:0;width:auto;margin-right:5px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:12px !important}
      .row-route .pill:has(#routeMaxDistance){flex-direction:row;align-items:center;flex-wrap:nowrap}
      .row-route .pill:has(#routeMaxDistance) label{min-width:60px !important;margin-bottom:0;width:auto;margin-right:4px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:50px !important;flex:0 0 auto;max-width:50px;padding:4px 5px !important;font-size:12px !important}
      .row-route #routeUnits{width:48px !important;flex:0 0 auto;max-width:48px;font-size:12px !important;padding:4px 3px !important}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-route #clearRoute{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
    }
    @media (max-width: 480px) {
      .container{padding:4px;}
      .controls{padding:8px 4px;}
      .row{gap:6px;}
      .pill{padding:8px;}
    }
    @media (min-width: 701px) and (max-width: 1024px) {
      .row-filters{flex-direction:row;gap:6px;flex-wrap:nowrap;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);min-width:0;}
      .row-filters .pill label{display:none}
      .row-filters .pill select{width:100%;font-size:12px;padding:6px 8px;}
      .row-filters .pill-search{display:none}
      .row-search{display:flex}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .controls{flex-direction:row;flex-wrap:wrap;align-items:flex-start}
      .row-filters{flex:1 1 100%;margin-bottom:3px}
      .row-search{flex:1 1 100%;margin-bottom:3px}
      .row-nearby{display:flex;flex-direction:row;gap:6px;flex-wrap:nowrap;margin-bottom:0}
      .row-nearby .pill.address-autocomplete{flex:1 1 auto;min-width:0}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:12px}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:6px 10px;margin-left:4px;font-size:12px}
      .row-nearby .pill:not(.address-autocomplete){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-nearby #radius{width:65px;flex:0 0 auto;max-width:65px;font-size:12px}
      .row-nearby #units{width:50px;flex:0 0 auto;max-width:50px;font-size:12px}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .row-route{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:0}
      .row-route .pill:first-child,.row-route .pill:nth-child(2){width:100%;box-sizing:border-box;padding:4px 6px}
      .row-route .pill:first-child label,.row-route .pill:nth-child(2) label{min-width:40px;max-width:40px;margin-bottom:0;width:40px;margin-right:5px;font-size:12px;font-weight:600;color:#475569;flex-shrink:0}
      .row-route .pill:first-child input,.row-route .pill:nth-child(2) input{min-width:0;flex:1 1 0;padding:5px 6px;font-size:12px;box-sizing:border-box}
      .row-route .pill:last-child{grid-column:1 / -1;flex-direction:row;align-items:center;margin-top:0;padding:4px 6px}
      .row-route .pill:last-child label{min-width:70px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:65px;flex:0 0 auto;max-width:65px;padding:5px 6px;font-size:12px}
      .row-route #routeUnits{width:50px;flex:0 0 auto;max-width:50px;padding:5px 4px;font-size:12px}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .row-route #clearRoute{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .filter-section {margin-top:3px}
      .filter-section summary {padding:8px 10px;font-size:13px}
      .filter-section-content {padding:0 10px 8px}
    }
    .filter-section {background:#f8fafc;border-radius:12px;border:1px solid #e2e8f0;margin-top:4px;overflow:visible;width:100%;flex:1 1 100%;position:relative;transition:box-shadow 0.2s ease}
    .filter-section-content {overflow:visible}
    .filter-section summary {font-weight:600;color:#0f172a;font-size:14px;padding:8px 12px;cursor:pointer;list-style:none;user-select:none;display:flex;align-items:center;gap:8px}
    .filter-section summary::-webkit-details-marker {display:none}
    .filter-section summary::before {content:'‚ñº';font-size:10px;transition:transform 0.2s;display:inline-block}
    .filter-section[open] summary::before {transform:rotate(-90deg)}
    .filter-section summary:hover {background:#f1f5f9}
    .filter-section-content {padding:0 12px 8px;display:flex;flex-direction:column;gap:3px}
    .filter-section.active {box-shadow:0 4px 12px rgba(37,99,235,0.15),0 2px 4px rgba(0,0,0,0.1);border-left:4px solid #2563eb}
    .filter-section.active summary {background:#f0f7ff}
    .about-map {max-width:1100px;margin:16px auto 24px;font-size:13px;color:#475569;background:#f8fafc;border-radius:12px;padding:10px 16px 14px;border:1px solid #e2e8f0}
    .about-map-title {font-weight:600;color:#0f172a;font-size:15px;margin:0 0 12px 0;text-align:center;padding-bottom:12px;border-bottom:2px solid #fff}
    .info-snippets {display:grid;grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));gap:14px;padding-top:8px}
    .snippet h2 {font-size:14px;font-weight:600;margin-bottom:4px;color:#1e293b}
    .snippet h2 .star-icon {font-size:0.75em;display:inline-block;vertical-align:top;margin-right:4px;margin-top:2pt}
    .snippet p {font-size:13px;color:#64748b;line-height:1.5}
    @media (max-width:700px) {
      .info-snippets {grid-template-columns:1fr}
      .filter-section {margin-top:3px}
      .filter-section summary {padding:10px 12px;font-size:13px}
      .filter-section-content {padding:0 12px 10px}
    }
  </style>
</head>
<body>
<div class="main-container">
<header class="app-header">
    <div class="header-logo-tagline">
  <!-- Logo optimization: Ideal source image size ‚âà 280√ó70px (4:1 ratio) for header usage at 70px height on desktop, 56px on mobile -->
  <!-- Using width/height attributes for layout stability and to prevent layout shift during load -->
  <img src="us-college-map-logo.png" alt="U.S. College Map interactive tool for exploring colleges by type, region, and location" class="site-logo" width="280" height="70">
      <h1 class="sr-only">U.S. College Map | Explore Colleges by Location, Type, and State</h1>
      <p class="tagline">Planning campus visits? U.S. College Map helps you explore schools by type, region, or name ‚Äî and easily find colleges near any location or along any trip.</p>
    </div>
</header>

  <main>
  <nav class="container controls" aria-label="College search filters">
    <div class="row row-filters">
      <div class="pill"><label for="type">Type</label><select id="type"><option value="">All college types</option></select></div>
      <div class="pill"><label for="region">Region</label><select id="region"><option value="">All regions</option></select></div>
      <div class="pill"><label for="state">State</label><select id="state" autocomplete="one-time-code" data-prevent-autofill="true"><option value="">All states</option></select></div>
      <div class="pill pill-search"><label for="search">Search</label><input id="search" placeholder="Enter college name" /></div>
  </div>
    <div class="row row-search">
      <div class="pill"><label for="search-mobile">Search</label><input id="search-mobile" placeholder="Enter college name" /></div>
  </div>
    
    <details class="filter-section">
      <summary>Find Colleges Nearby</summary>
      <div class="filter-section-content">
        <div class="row row-nearby">
          <div class="pill address-autocomplete"><label for="address">Address</label><input id="address" placeholder="Enter a location or home address" autocomplete="new-password" aria-autocomplete="list" aria-expanded="false" aria-controls="addressSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="addressSuggestions" role="listbox" aria-label="Address suggestions"></div></div>
    <div class="pill"><label for="radius">Radius</label><input id="radius" type="number" min="0" step="10" value="30" style="width:90px"><select id="units"><option value="mi" selected>mi</option><option value="km">km</option></select><button id="geocodeBtn">Locate</button><button id="clearRadius" style="background:transparent;color:#0f172a;border:1px solid #e2e8f0;">Clear</button></div>
</div>
</div>
    </details>
    
    <details class="filter-section">
      <summary>Find Colleges Along a Route</summary>
      <div class="filter-section-content">
        <div class="row row-route">
          <div class="pill address-autocomplete"><label for="routeStart">From</label><input id="routeStart" placeholder="Enter starting address" autocomplete="new-password" aria-autocomplete="list" aria-expanded="false" aria-controls="routeStartSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="routeStartSuggestions" role="listbox" aria-label="From address suggestions"></div></div>
          <div class="pill address-autocomplete"><label for="routeEnd">To</label><input id="routeEnd" placeholder="Enter destination address" autocomplete="new-password" aria-autocomplete="list" aria-expanded="false" aria-controls="routeEndSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="routeEndSuggestions" role="listbox" aria-label="To address suggestions"></div></div>
          <div class="pill"><label for="routeMaxDistance">Max Distance</label><input id="routeMaxDistance" type="number" min="0" step="10" value="30" style="width:90px"><select id="routeUnits"><option value="mi" selected>mi</option><option value="km">km</option></select><button id="findRouteBtn">Explore</button><button id="clearRoute" style="background:transparent;color:#0f172a;border:1px solid #e2e8f0;">Clear</button></div>
        </div>
      </div>
    </details>
  </nav>

  <section id="map" aria-label="Interactive college map">
    <!-- Smart map hint popups -->
    <div class="map-hint-bubble" id="hint-too-many-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">üéØ</span>
        <div class="map-hint-bubble-title">Too many colleges shown?</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('tooMany')">√ó</button>
      </div>
      <div class="map-hint-bubble-body">Try using the "Type" filter above to narrow down your school options.</div>
    </div>
    <div class="map-hint-bubble" id="hint-no-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">üîç</span>
        <div class="map-hint-bubble-title">No colleges found?</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('noResults')">√ó</button>
      </div>
      <div class="map-hint-bubble-body">Your filters may be too narrow ‚Äî Check your Type, Region or State selections above.</div>
    </div>
    <!-- Helper tip bubble - appears once per session -->
    <div class="map-tip-bubble" id="map-tip-bubble" role="alert">
      <div class="map-tip-bubble-content">
        <span class="map-tip-bubble-icon">üí°</span>
        <span class="map-tip-bubble-text">Tip: Tap a blue dot to see college details</span>
        <button class="map-tip-bubble-close" aria-label="Dismiss tip" onclick="dismissMapTip()">√ó</button>
      </div>
    </div>
  </section>
<div aria-label="College map powered by OpenStreetMap data" class="sr-only"></div>
<div class="legend" id="legend">Showing <span id="count">0</span> schools</div>
  <div class="loading" id="loading">Loading colleges data...</div>
  <div class="error" id="error"></div>
  
  <section class="about-map">
    <h2 class="about-map-title">About This Map</h2>
    <div class="info-snippets" aria-label="College visit planning resources">
      <div class="snippet">
        <h2><span class="star-icon">‚≠ê</span> How to plan a college visit</h2>
        <p>Planning campus visits can feel overwhelming, especially when you're juggling school, activities, and travel. U.S. College Map helps you find colleges near any address or along any route, making it easy to group visits efficiently and make the most of trips you're already taking.</p>
      </div>
      <div class="snippet">
        <h2><span class="star-icon">‚≠ê</span> Explore colleges by region or location</h2>
        <p>Whether you're searching in a specific region or looking for certain types of schools, the map shows every college in that area so you can compare locations quickly and discover options you may not have considered.</p>
      </div>
      <div class="snippet">
        <h2><span class="star-icon">‚≠ê</span> Why a visual map helps your college search</h2>
        <p>Seeing colleges on a map makes early research much easier. It helps families understand distance, proximity, and travel patterns ‚Äî and highlights nearby schools that don't always show up on ranked lists.</p>
      </div>
    </div>
  </section>
  </main>
</div>
<footer class="site-footer">¬© 2025 U.S. College Map</footer>

<script>
const localMode = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
const DATA_URL = localMode ? 'colleges_usa_2024.csv' : 'https://uscollegemap.org/colleges_usa_2024.csv';

// Cache DOM references for performance
const elements = {
  state: document.getElementById('state'),
  region: document.getElementById('region'),
  type: document.getElementById('type'),
  search: document.getElementById('search'),
  address: document.getElementById('address'),
  radius: document.getElementById('radius'),
  units: document.getElementById('units'),
  count: document.getElementById('count'),
  loading: document.getElementById('loading'),
  error: document.getElementById('error'),
  geocodeBtn: document.getElementById('geocodeBtn'),
  clearRadius: document.getElementById('clearRadius'),
  addressSuggestions: document.getElementById('addressSuggestions'),
  routeStart: document.getElementById('routeStart'),
  routeEnd: document.getElementById('routeEnd'),
  routeMaxDistance: document.getElementById('routeMaxDistance'),
  routeUnits: document.getElementById('routeUnits'),
  findRouteBtn: document.getElementById('findRouteBtn'),
  clearRoute: document.getElementById('clearRoute'),
  routeStartSuggestions: document.getElementById('routeStartSuggestions'),
  routeEndSuggestions: document.getElementById('routeEndSuggestions')
};

document.addEventListener('DOMContentLoaded', () => {
  const ua = navigator.userAgent || '';
  const isIOS =
    /iPad|iPhone|iPod/.test(ua) ||
    (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  if (isIOS) {
    document.documentElement.classList.add('ios-device');
  }
});

if (elements.addressSuggestions) elements.addressSuggestions.dataset.field = 'address';
if (elements.routeStartSuggestions) elements.routeStartSuggestions.dataset.field = 'routeStart';
if (elements.routeEndSuggestions) elements.routeEndSuggestions.dataset.field = 'routeEnd';

let addressAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

// Route autocomplete objects
let routeStartAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

let routeEndAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

const americasBounds = L.latLngBounds([[-60,-180],[85,-30]]);
const INITIAL_DESKTOP_VIEW = { center: { lat: 39.5, lng: -98.35 }, zoom: 4 };
const INITIAL_MOBILE_VIEW = { center: { lat: 39.5, lng: -98.35 }, zoom: 3.5 };
function getInitialNearbyView() {
  return window.innerWidth <= 700 ? INITIAL_MOBILE_VIEW : INITIAL_DESKTOP_VIEW;
}
const mapViewState = {
  nearby: { ...getInitialNearbyView() },
  route: null
};
const map = L.map('map',{maxBounds:americasBounds,maxBoundsViscosity:1}).setView(
  [mapViewState.nearby.center.lat, mapViewState.nearby.center.lng],
  mapViewState.nearby.zoom
);
map.whenReady(() => {
  setTimeout(() => {
    map.invalidateSize();
    if (!home && !lastNearbyFilters && mapViewState.nearby) {
      map.setView([mapViewState.nearby.center.lat, mapViewState.nearby.center.lng], mapViewState.nearby.zoom);
      captureMapView('nearby');
    }
  }, 150);
});
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap contributors',attributionControl:true}).addTo(map);

const markersLayer = L.layerGroup().addTo(map);

const homeLayer = L.layerGroup().addTo(map);
const radiusLayer = L.layerGroup().addTo(map);
const routeLayer = L.layerGroup().addTo(map);
const ROUTE_START_PIN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#10b981" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
const ROUTE_END_PIN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
const ROUTE_START_PIN_ICON = 'data:image/svg+xml;base64,' + btoa(ROUTE_START_PIN_SVG);
const ROUTE_END_PIN_ICON = 'data:image/svg+xml;base64,' + btoa(ROUTE_END_PIN_SVG);
let colleges = [], home = null;
function captureMapView(mode) {
  if (!mode) return;
  const center = map.getCenter();
  mapViewState[mode] = {
    center: { lat: center.lat, lng: center.lng },
    zoom: map.getZoom()
  };
}
function applySavedMapView(mode) {
  const view = mode ? mapViewState[mode] : null;
  if (view && view.center && typeof view.zoom === 'number') {
    map.setView([view.center.lat, view.center.lng], view.zoom, { animate: false });
    return true;
  }
  return false;
}
map.on('moveend', () => {
  if (activeMode === 'nearby' || activeMode === 'route') {
    captureMapView(activeMode);
  }
});

// Active mode state: 'nearby' or 'route'
let activeMode = 'nearby';

// Track if user has actively used search controls (Locate or Find Route buttons)
let hasUsedSearchControls = false;

// Route state
let route = {
  start: null, // { description, lat, lon }
  end: null,
  lastSearch: null, // { start, end, maxDistance, units }
  lastResult: null // Cached visualization data for restoring route view quickly
};

// Nearby state (for restoration)
let nearbyState = {
  address: null,
  home: null,
  radius: null,
  units: null
};
let lastNearbyFilters = null;

const TYPE_ORDER = ["Ivy League","Elite Private Universities","Public Flagship Universities","Private Liberal Arts Colleges","STEM / Technology Institutes","Business / Arts / Specialty Schools","Health & Medical Colleges","Faith-Based","Public Regional Universities","Community Colleges","Online / For-Profit"];

// Region mapping for better performance
const REGION_MAP = {
  'Northeast': ['ME','NH','VT','MA','RI','CT','NY','NJ','PA'],
  'Midwest': ['OH','MI','IN','IL','WI','MN','IA','MO','ND','SD','NE','KS'],
  'South': ['DE','MD','DC','VA','WV','NC','SC','GA','FL','KY','TN','AL','MS','AR','LA','TX','OK'],
  'West': ['MT','ID','WY','CO','NM','AZ','UT','NV','CA','OR','WA','HI','AK'],
  'Territories': ['PR','GU','VI','AS','MP']
};

// Calculate distance between two coordinates (Haversine formula)
function calculateDistance(lat1, lon1, lat2, lon2, unit = 'mi') {
  const R = unit === 'mi' ? 3959 : 6371; // Earth radius in miles or km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Debounce function for search input
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function showError(message) {
  if (elements.error) {
    elements.error.textContent = message;
    elements.error.classList.add('active');
    setTimeout(() => {
      if (elements.error) {
        elements.error.classList.remove('active');
      }
    }, 5000);
  }
}

const RECENT_STORAGE_KEYS = {
  nearby: 'ucm_recentAddresses',
  routeStart: 'ucm_routeRecentStart',
  routeEnd: 'ucm_routeRecentEnd'
};
const MAX_RECENT_ITEMS = 5;
const SHARED_RECENT_KEY = 'ucm_recentLocations';
const MAX_SHARED_RECENT_ITEMS = 10;

function escapeHtml(text = '') {
  return text.replace(/&/g, '&amp;')
             .replace(/</g, '&lt;')
             .replace(/>/g, '&gt;')
             .replace(/"/g, '&quot;')
             .replace(/'/g, '&#39;');
}

function loadRecents(storageKey) {
  try {
    const stored = localStorage.getItem(storageKey);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(item => typeof item === 'string' && item.trim().length);
  } catch (error) {
    console.warn('Unable to load recents for key', storageKey, error);
    return [];
  }
}

function loadSharedLocations() {
  try {
    const stored = localStorage.getItem(SHARED_RECENT_KEY);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(item => {
      return item && typeof item.description === 'string' &&
             typeof item.lat === 'number' && !isNaN(item.lat) &&
             typeof item.lon === 'number' && !isNaN(item.lon);
    });
  } catch (error) {
    console.warn('Unable to load shared locations', error);
    return [];
  }
}

function saveSharedLocation(description, lat, lon) {
  if (!description || typeof description !== 'string') return;
  const trimmed = description.trim();
  const latNum = typeof lat === 'number' ? lat : parseFloat(lat);
  const lonNum = typeof lon === 'number' ? lon : parseFloat(lon);
  if (!trimmed || isNaN(latNum) || isNaN(lonNum)) return;
  const normalizedKey = `${trimmed.toLowerCase()}|${latNum.toFixed(6)}|${lonNum.toFixed(6)}`;
  const existing = loadSharedLocations().filter(item => {
    const itemKey = `${(item.description || '').toLowerCase()}|${item.lat.toFixed(6)}|${item.lon.toFixed(6)}`;
    return itemKey !== normalizedKey;
  });
  existing.unshift({ description: trimmed, lat: latNum, lon: lonNum });
  try {
    localStorage.setItem(SHARED_RECENT_KEY, JSON.stringify(existing.slice(0, MAX_SHARED_RECENT_ITEMS)));
  } catch (error) {
    console.warn('Unable to persist shared locations', error);
  }
}

function saveRecent(storageKey, value) {
  if (!storageKey || typeof value !== 'string') return;
  const trimmed = value.trim();
  if (!trimmed.length) return;
  const existing = loadRecents(storageKey).filter(item => item.toLowerCase() !== trimmed.toLowerCase());
  existing.unshift(trimmed);
  try {
    localStorage.setItem(storageKey, JSON.stringify(existing.slice(0, MAX_RECENT_ITEMS)));
  } catch (error) {
    console.warn('Unable to persist recents for key', storageKey, error);
  }
}

function getFallbackRecentsForField(field) {
  if (!field) return [];
  if (field === 'address') return loadRecents(RECENT_STORAGE_KEYS.nearby);
  if (field === 'routeStart') return loadRecents(RECENT_STORAGE_KEYS.routeStart);
  if (field === 'routeEnd') return loadRecents(RECENT_STORAGE_KEYS.routeEnd);
  return [];
}

function clearRecentState(container) {
  if (!container) return;
  delete container.dataset.showingRecents;
  delete container.dataset.recentContext;
}

function shouldShowRecentsForInput(inputElement) {
  if (!inputElement) return false;
  if (document.activeElement !== inputElement) return false;
  return (inputElement.value || '').trim().length < 3;
}

function buildUnifiedRecentSection(fallbackRecents = [], options = {}) {
  const query = (options.query || '').trim().toLowerCase();
  const shouldFilterShared = options.filterShared && query.length > 0;
  const shouldFilterFallback = options.filterFallback && query.length > 0;
  const sharedLocations = loadSharedLocations();
  let sharedItems = sharedLocations;
  if (shouldFilterShared) {
    sharedItems = sharedLocations.filter(loc => (loc.description || '').toLowerCase().startsWith(query));
  }
  let sectionItems = '';
  if (sharedItems.length) {
    sectionItems = sharedItems.map(loc => {
      const encodedDescription = encodeURIComponent(loc.description || '');
      const safeDescription = escapeHtml(loc.description || '');
      const safeDetails = `${loc.lat.toFixed(3)}, ${loc.lon.toFixed(3)}`;
      return `
        <div class="autocomplete-item shared-location" role="option" tabindex="0"
             data-shared="true"
             data-description="${encodedDescription}"
             data-lat="${loc.lat}"
             data-lon="${loc.lon}">
          <div class="autocomplete-item-icon">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
            </svg>
          </div>
          <div class="autocomplete-item-content">
            <div class="address-name">${safeDescription}</div>
            <div class="address-details">${safeDetails}</div>
          </div>
        </div>`;
    }).join('');
  } else {
    let fallbackItems = fallbackRecents;
    if (shouldFilterFallback) {
      fallbackItems = fallbackRecents.filter(value => value.toLowerCase().startsWith(query));
    }
    if (fallbackItems.length) {
      sectionItems = fallbackItems.map(value => {
        const encodedValue = encodeURIComponent(value);
        const safeValue = escapeHtml(value);
        return `
          <div class="autocomplete-item recent-suggestion" role="option" tabindex="0" data-recent="true" data-value="${encodedValue}">
            <div class="autocomplete-item-icon">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2a10 10 0 1 0 10 10A10.011 10.011 0 0 0 12 2zm0 18a8 8 0 1 1 8-8a8.009 8.009 0 0 1-8 8zm.75-12h-1.5v5l4.25 2.55l.75-1.23l-3.5-2.07z"/>
              </svg>
            </div>
            <div class="autocomplete-item-content">
              <div class="address-name">${safeValue}</div>
            </div>
          </div>`;
      }).join('');
    }
  }
  if (!sectionItems) {
    return '';
  }
  return `
    <div class="autocomplete-section-title">Recent locations</div>
    ${sectionItems}
    <div class="autocomplete-divider" role="separator"></div>`;
}

function toggleAutocompleteLayer(inputElement, isActive) {
  const wrapper = inputElement ? inputElement.closest('.address-autocomplete') : null;
  if (!wrapper) return;
  if (isActive) {
    wrapper.classList.add('autocomplete-active');
  } else {
    wrapper.classList.remove('autocomplete-active');
  }
}

function showRecentSuggestions(container, recents, inputElement, context, options = {}) {
  if (!container || !inputElement) return false;
  const unifiedSection = buildUnifiedRecentSection(recents, options);
  if (!unifiedSection) {
    clearRecentState(container);
    return false;
  }
  container.innerHTML = unifiedSection;
  container.classList.add('active');
  container.dataset.showingRecents = 'true';
  container.dataset.recentContext = context || '';
  inputElement.setAttribute('aria-expanded', 'true');
  return true;
}

function showAddressRecentsIfEligible() {
  if (!elements.address || !elements.addressSuggestions) return false;
  const queryValue = (elements.address.value || '').trim();
  if (!shouldShowRecentsForInput(elements.address)) {
    return false;
  }
  const recents = loadRecents(RECENT_STORAGE_KEYS.nearby);
  const shown = showRecentSuggestions(
    elements.addressSuggestions,
    recents,
    elements.address,
    'address',
    {
      query: queryValue,
      filterShared: true,
      filterFallback: true
    }
  );
  if (shown) {
    addressAutocomplete.suggestions = [];
    addressAutocomplete.selectedIndex = -1;
  }
  return shown;
}

function showRouteRecentsIfEligible(inputElement, suggestionsContainer, autocompleteObj, storageKey, context) {
  if (!inputElement || !suggestionsContainer) return false;
  const queryValue = (inputElement.value || '').trim();
  if (!shouldShowRecentsForInput(inputElement)) {
    return false;
  }
  const recents = loadRecents(storageKey);
  const shown = showRecentSuggestions(
    suggestionsContainer,
    recents,
    inputElement,
    context,
    {
      query: queryValue,
      filterShared: true,
      filterFallback: true
    }
  );
  if (shown && autocompleteObj) {
    autocompleteObj.suggestions = [];
    autocompleteObj.selectedIndex = -1;
  }
  return shown;
}

function handleRecentAddressSelection(value) {
  if (!value) return;
  addressAutocomplete.suggestions = [{ description: value }];
  selectSuggestion(0);
}

function handleRecentRouteSelection(value, context) {
  if (!value) return;
  if (context === 'routeStart' && elements.routeStart && elements.routeStartSuggestions) {
    routeStartAutocomplete.suggestions = [{ description: value }];
    selectRouteSuggestion(0, routeStartAutocomplete, elements.routeStart, elements.routeStartSuggestions);
  } else if (context === 'routeEnd' && elements.routeEnd && elements.routeEndSuggestions) {
    routeEndAutocomplete.suggestions = [{ description: value }];
    selectRouteSuggestion(0, routeEndAutocomplete, elements.routeEnd, elements.routeEndSuggestions);
  }
}

function handleSharedLocationSelection(field, description) {
  if (!field || !description) return;
  if (field === 'address') {
    handleRecentAddressSelection(description);
  } else if (field === 'routeStart') {
    handleRecentRouteSelection(description, 'routeStart');
  } else if (field === 'routeEnd') {
    handleRecentRouteSelection(description, 'routeEnd');
  }
}

function getRouteFilterSignature() {
  const typeVal = elements.type ? elements.type.value.trim() : '';
  const regionVal = elements.region ? elements.region.value.trim() : '';
  const stateVal = elements.state ? elements.state.value.trim() : '';
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  const maxDistance = parseFloat(elements.routeMaxDistance?.value || '30') || 30;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  return { typeVal, regionVal, stateVal, searchVal, maxDistance, units };
}

function addRouteCollegeMarker(college, distanceText, units) {
  try {
    if (isNaN(college.lat) || isNaN(college.lon) || college.lat === 0 || college.lon === 0) {
      console.warn(`Invalid coordinates for ${college.name}:`, college.lat, college.lon);
      return;
    }

    const tuition = college.tuition ? (college.tuition.toString().includes('$') ? college.tuition : `$${Number(college.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = college.acceptance ? (college.acceptance.toString().includes('%') ? college.acceptance : `${parseFloat(college.acceptance).toFixed(1)}%`) : 'N/A';

    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${college.name}</b><br>
        ${college.state} ¬∑ ${(college.type||'Unknown')}${distanceText || ''}<br>
        ${college.control ? college.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${college.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${college.url ? `<a href="https://${college.url.replace(/^https?:\/\//,'')}" target="_blank">${college.url}</a>` : ''}
      </div>`;

    L.circleMarker([college.lat, college.lon], {
      radius: 5,
      color: '#2563eb',
      weight: 2,
      fillOpacity: 0.7
    })
      .bindTooltip(college.name, {permanent: false, direction: 'top'})
      .bindPopup(popupContent)
      .addTo(markersLayer);
  } catch (e) {
    console.error(`Error creating marker for ${college.name}:`, e);
  }
}

function areNearbySignaturesEqual(a, b) {
  if (!a || !b) return false;
  const keys = ['typeVal', 'regionVal', 'stateVal', 'searchVal', 'radiusVal', 'unitsVal', 'homeLat', 'homeLon'];
  return keys.every(key => (a[key] ?? '') === (b[key] ?? ''));
}

function isRouteCacheValid(cache, filters, currentStart, currentEnd) {
  if (!cache || !cache.filters || !filters) return false;
  const keys = ['typeVal', 'regionVal', 'stateVal', 'searchVal', 'maxDistance', 'units'];
  const filtersMatch = keys.every(key => (cache.filters[key] || '') === (filters[key] || ''));
  const sameStart = cache.start && currentStart &&
    cache.start.lat === currentStart.lat &&
    cache.start.lon === currentStart.lon &&
    (cache.start.description || '') === (currentStart.description || '');
  const sameEnd = cache.end && currentEnd &&
    cache.end.lat === currentEnd.lat &&
    cache.end.lon === currentEnd.lon &&
    (cache.end.description || '') === (currentEnd.description || '');
  return filtersMatch && sameStart && sameEnd && Array.isArray(cache.routeCoords) && cache.routeCoords.length > 0;
}

function restoreRouteFromCache(cache, options = {}) {
  if (!cache) return false;
  markersLayer.clearLayers();
  routeLayer.clearLayers();

  L.polyline(cache.routeCoords, {
    color: '#2563eb',
    weight: 4,
    opacity: 0.8
  }).addTo(routeLayer);

  const startData = cache.start;
  if (startData) {
    L.marker([startData.lat, startData.lon], {
      icon: L.icon({
        iconUrl: ROUTE_START_PIN_ICON,
        iconSize: [24, 30],
        iconAnchor: [12, 30],
        popupAnchor: [0, -30]
      })
    }).addTo(routeLayer).bindPopup('From');
  }

  const endData = cache.end;
  if (endData) {
    L.marker([endData.lat, endData.lon], {
      icon: L.icon({
        iconUrl: ROUTE_END_PIN_ICON,
        iconSize: [24, 30],
        iconAnchor: [12, 30],
        popupAnchor: [0, -30]
      })
    }).addTo(routeLayer).bindPopup('To');
  }

  const units = cache.filters?.units || 'mi';
  (cache.colleges || []).forEach(item => {
    addRouteCollegeMarker(item.college, item.distanceText || '', units);
  });

  if (elements.count) elements.count.textContent = (cache.colleges || []).length;
  updateMapHints(
    (cache.colleges || []).length,
    cache.filters?.typeVal || '',
    cache.filters?.regionVal || '',
    cache.filters?.stateVal || '',
    cache.filters?.searchVal || ''
  );

  if (!options.preserveView) {
    if (cache.bounds && cache.bounds.isValid()) {
      map.fitBounds(cache.bounds.pad(0.15));
    } else if (cache.routeCoords && cache.routeCoords.length) {
      map.fitBounds(L.latLngBounds(cache.routeCoords), { padding: [50, 50] });
    }
  }
  if (elements.loading) elements.loading.classList.remove('active');
  return true;
}

/**
 * Render colleges on the map based on current filters.
 * 
 * Performance: This function is NOT called during map pan/zoom interactions.
 * Markers are only re-rendered when:
 * - User changes filters (Type, Region, State, Search)
 * - User sets/changes address/radius
 * - User switches between Nearby/Route modes
 * - NOT during map dragging/zooming (Leaflet handles marker visibility automatically)
 */
function render(){
  // Only render in nearby mode - route mode uses findCollegesAlongRoute()
  if (activeMode === 'route') {
    // If route search has been performed, re-run it with updated filters
    if (route.lastSearch) {
      findCollegesAlongRoute();
    } else {
      // If in route mode but no route search, show colleges based on filters only
      // Clear route visualization
      routeLayer.clearLayers();
  markersLayer.clearLayers();
      
      // Apply filters from dropdowns
      const stateVal = elements.state ? elements.state.value : '';
      const regionVal = elements.region ? elements.region.value : '';
      const typeVal = elements.type ? elements.type.value : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      
      let filtered = colleges.filter(c => {
        // Region filter
        const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
        if (!regionMatch) return false;
        
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        
        // Type filter
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        return true;
      });
      
      // Render filtered colleges
      filtered.forEach(c => {
        try {
          if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
            return;
          }
          
    const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
          
    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${c.name}</b><br>
        ${c.state} ¬∑ ${(c.type||'Unknown')}<br>
        ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${c.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
      </div>`;

          L.circleMarker([c.lat, c.lon], {radius: 5, color: '#2563eb', weight: 2, fillOpacity: 0.7})
            .bindTooltip(c.name, {permanent: false, direction: 'top'})
      .bindPopup(popupContent)
      .addTo(markersLayer);
        } catch (e) {
          console.error(`Error creating marker for ${c.name}:`, e);
        }
      });
      
      if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
      
      // Update map hints for route mode (no route search yet)
      updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
    }
    return;
  }
  
  // Clear route visualization when in nearby mode
  routeLayer.clearLayers();
  
  // Check if colleges data is loaded
  if (!colleges || colleges.length === 0) {
    console.log('No colleges data available yet');
    if (elements.count) elements.count.textContent = '0';
    return;
  }
  
  markersLayer.clearLayers();
  radiusLayer.clearLayers();
  
  const stateVal = elements.state ? elements.state.value : '';
  const regionVal = elements.region ? elements.region.value : '';
  const typeVal = elements.type ? elements.type.value : '';
  // Get search value from either desktop or mobile search field (prefer the one with a value, or desktop first)
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  const radiusVal = parseFloat(elements.radius?.value || '0') || 0;
  const unitsVal = elements.units ? elements.units.value : 'mi';
  const nearbySignature = {
    typeVal,
    regionVal,
    stateVal,
    searchVal,
    radiusVal,
    unitsVal,
    homeLat: home ? Number(home.lat.toFixed(6)) : null,
    homeLon: home ? Number(home.lon.toFixed(6)) : null
  };
  const shouldAutoFrameNearby = !lastNearbyFilters || !mapViewState.nearby || !areNearbySignaturesEqual(lastNearbyFilters, nearbySignature);
  const isDefaultNearbyState = !home && !regionVal && !stateVal && !typeVal && !searchVal;
  const isSearchOnlyFilter = !!searchVal && !home && !regionVal && !stateVal && !typeVal;

  let filtered = colleges.filter(c => {
    // Region filter
    const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
    if (!regionMatch) return false;
    
    // State filter
    if (stateVal && c.state !== stateVal) return false;
    
    // Type filter
    if (typeVal && (c.type || c.tier) !== typeVal) return false;
    
    // Search filter
    if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
    
    // Radius filter (if home location is set)
    if (home && radiusVal > 0) {
      const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
      if (distance > radiusVal) return false;
    }
    
    return true;
  });

  // Draw radius circle if home and radius are set
  if (home && radiusVal > 0) {
    const radiusMeters = radiusVal * (unitsVal === 'mi' ? 1609.34 : 1000);
    L.circle([home.lat, home.lon], {
      radius: radiusMeters,
      color: '#2563eb',
      fillColor: '#2563eb',
      fillOpacity: 0.1,
      weight: 2,
      dashArray: '5, 5'
    }).addTo(radiusLayer);
  }

  console.log(`Rendering ${filtered.length} colleges (activeMode: ${activeMode}, home: ${home ? 'set' : 'null'})`);
  
  const nearbyBounds = filtered.length > 1 ? L.latLngBounds([]) : null;
  filtered.forEach(c => {
    try {
      // Validate coordinates
      if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
        console.warn(`Invalid coordinates for ${c.name}:`, c.lat, c.lon);
        return;
      }
      
    const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
      
      // Calculate distance if home is set
      let distanceText = '';
      if (home) {
        const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
        distanceText = `<br>Distance: ${distance.toFixed(1)} ${unitsVal}`;
      }
      
    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${c.name}</b><br>
          ${c.state} ¬∑ ${(c.type||'Unknown')}${distanceText}<br>
        ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${c.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
      </div>`;

    const marker = L.circleMarker([c.lat, c.lon], {radius: 5, color: '#2563eb', weight: 2, fillOpacity: 0.7})
      .bindTooltip(c.name, {permanent: false, direction: 'top'})
      .bindPopup(popupContent)
      .addTo(markersLayer);
    if (nearbyBounds) {
      nearbyBounds.extend(marker.getLatLng());
    }
    } catch (e) {
      console.error(`Error creating marker for ${c.name}:`, e);
    }
  });

  if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
  console.log(`Added ${filtered.length} markers to map`);
  
  // Update map hints based on filtered results
  updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
  
  if (shouldAutoFrameNearby) {
    if ((isDefaultNearbyState || isSearchOnlyFilter) && mapViewState.nearby) {
      map.setView([mapViewState.nearby.center.lat, mapViewState.nearby.center.lng], mapViewState.nearby.zoom);
      captureMapView('nearby');
    } else if (filtered.length === 0) {
      if (home) {
        map.setView([home.lat, home.lon], 8);
      } else {
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    } else if (filtered.length === 1) {
      map.setView([filtered[0].lat, filtered[0].lon], 8);
    } else if (nearbyBounds && nearbyBounds.isValid()) {
      map.fitBounds(nearbyBounds.pad(0.15));
    } else if (home) {
      map.setView([home.lat, home.lon], 8);
    } else {
      map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
    }
  } else {
    if (!applySavedMapView('nearby')) {
      if (home) {
        map.setView([home.lat, home.lon], 8);
      } else {
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    }
  }
  lastNearbyFilters = nearbySignature;
}

function refreshDropdown(id, values, placeholder) {
  const select = document.getElementById(id);
  select.innerHTML = `<option value="">${placeholder}</option>` + values.map(v => `<option>${v}</option>`).join('');
}

/**
 * Update map hint popups based on filtered results and filter state
 * Only shows hints when user has actively used search controls
 * Priority: No Results > Too Many Colleges (never show both)
 */
function updateMapHints(visibleCount, typeVal, regionVal, stateVal, searchVal) {
  const hintTooMany = document.getElementById('hint-too-many-colleges');
  const hintNoResults = document.getElementById('hint-no-colleges');
  
  if (!hintTooMany || !hintNoResults) {
    console.warn('Map hint elements not found');
    return;
  }
  
  // Don't show any hints if user hasn't actively used search controls
  if (!hasUsedSearchControls) {
    hintTooMany.classList.remove('active');
    hintNoResults.classList.remove('active');
    return;
  }
  
  // Only show hints when in nearby or route mode
  if (activeMode !== 'nearby' && activeMode !== 'route') {
    hintTooMany.classList.remove('active');
    hintNoResults.classList.remove('active');
    return;
  }
  
  // Check if hints have been dismissed this session
  const seenTooMany = sessionStorage.getItem('ucm_seenTooManyColleges') === '1';
  const seenNoResults = sessionStorage.getItem('ucm_seenNoResults') === '1';
  
  // Check if any filter is non-default
  const hasNonDefaultFilter = regionVal || stateVal || searchVal;
  const hasAnyFilter = typeVal || hasNonDefaultFilter;
  
  // Priority 1: No Results hint
  if (visibleCount === 0 && hasAnyFilter && !seenNoResults) {
    hintNoResults.classList.add('active');
    hintTooMany.classList.remove('active');
    console.log('Showing No Results hint', {visibleCount, hasAnyFilter, seenNoResults});
    return;
  } else {
    hintNoResults.classList.remove('active');
  }
  
  // Priority 2: Too Many Colleges hint (only if No Results is not showing)
  if (visibleCount > 30 && !typeVal && !seenTooMany) {
    hintTooMany.classList.add('active');
    console.log('Showing Too Many Colleges hint', {visibleCount, typeVal, seenTooMany});
  } else {
    hintTooMany.classList.remove('active');
  }
}

/**
 * Dismiss a map hint and store in sessionStorage
 */
function dismissMapHint(type) {
  if (type === 'tooMany') {
    sessionStorage.setItem('ucm_seenTooManyColleges', '1');
    const hint = document.getElementById('hint-too-many-colleges');
    if (hint) hint.classList.remove('active');
  } else if (type === 'noResults') {
    sessionStorage.setItem('ucm_seenNoResults', '1');
    const hint = document.getElementById('hint-no-colleges');
    if (hint) hint.classList.remove('active');
  }
}

/**
 * Show the map tip bubble if it hasn't been seen this session
 */
function showMapTip() {
  const tipBubble = document.getElementById('map-tip-bubble');
  if (!tipBubble) return;
  
  // Check if already seen this session
  if (sessionStorage.getItem('ucm_seenTapDotHint') === '1') {
    return;
  }
  
  // Show the tip bubble
  tipBubble.classList.add('active');
  
  // Auto-hide after 15 seconds
  setTimeout(() => {
    dismissMapTip();
  }, 15000);
}

/**
 * Dismiss the map tip bubble and store in sessionStorage
 */
function dismissMapTip() {
  sessionStorage.setItem('ucm_seenTapDotHint', '1');
  const tipBubble = document.getElementById('map-tip-bubble');
  if (tipBubble) tipBubble.classList.remove('active');
}



function loadCSV(url){
  if (elements.loading) elements.loading.classList.add('active');
  
  // Try to load from cache first
  const cacheKey = 'colleges_data_cache';
  const cacheTime = 'colleges_data_time';
  const cacheExpiry = 24 * 60 * 60 * 1000; // 24 hours
  
  try {
    const cachedData = localStorage.getItem(cacheKey);
    const cachedTime = localStorage.getItem(cacheTime);
    
    if (cachedData && cachedTime && Date.now() - parseInt(cachedTime) < cacheExpiry) {
      const data = JSON.parse(cachedData);
      processCollegesData(data);
      if (elements.loading) elements.loading.classList.remove('active');
      return;
    }
  } catch (e) {
    // Cache read failed, proceed with download
  }
  
  Papa.parse(url, {
    header: true,
    dynamicTyping: true,
    download: true,
    complete: (results) => {
      if (elements.loading) elements.loading.classList.remove('active');
      
      console.log('CSV parsing complete. Rows:', results.data?.length);
      
      if (results.errors && results.errors.length > 0) {
        console.warn('CSV parsing errors:', results.errors);
      }
      
      if (!results.data || results.data.length === 0) {
        showError('Failed to load colleges data. Please refresh the page.');
        console.error('No data in CSV results');
        return;
      }
      
      // Cache the data
      try {
        localStorage.setItem(cacheKey, JSON.stringify(results.data));
        localStorage.setItem(cacheTime, Date.now().toString());
        console.log('Data cached successfully');
      } catch (e) {
        console.warn('Cache write failed:', e);
      }
      
      processCollegesData(results.data);
    },
    error: (error) => {
      if (elements.loading) elements.loading.classList.remove('active');
      showError('Error loading colleges data: ' + (error.message || 'Unknown error'));
      console.error('CSV load error:', error);
    }
  });
}

/**
 * Process CSV data and map to internal college objects.
 * 
 * REQUIRED CSV COLUMNS (for creating a "slim" CSV):
 * - name: College name (used in search, popups, tooltips)
 * - lat: Latitude (required for map markers, radius/route filtering)
 * - lon: Longitude (required for map markers, radius/route filtering)
 * - state: State code (used in state filter, region filter, popups)
 * - type: College type (used in type filter dropdown, popups, TYPE_ORDER ranking)
 * - tier: Alternative type field (used as fallback in type filter: c.type || c.tier)
 * - control: Control type (used in popups: "Public | Private")
 * - acceptance: Acceptance rate (used in popups)
 * - enrollment: Enrollment number (used in popups)
 * - tuition: Tuition cost (used in popups)
 * - url: College website URL (used in popups as clickable link)
 * 
 * All other CSV columns can be removed to reduce payload size.
 */
function processCollegesData(data) {
  colleges = data.filter(r => r.name && r.lat && r.lon).map(r => ({
    name: r.name,
    lat: +r.lat,
    lon: +r.lon,
    state: (r.state || '').toUpperCase(),
    type: r.type || 'Unknown',
    tier: r.tier || '', // Used as fallback in type filter: (c.type || c.tier)
    control: r.control || '',
    acceptance: r.acceptance || '',
    enrollment: r.enrollment || '',
    tuition: r.tuition || '',
    url: r.url || ''
  }));
  
  console.log(`Loaded ${colleges.length} colleges`);
  
  if (colleges.length === 0) {
    showError('No college data found. Please check the CSV file.');
    return;
  }
  
  const states = [...new Set(colleges.map(c => c.state))].sort();
  const types = [...new Set(colleges.map(c => c.type))].filter(Boolean);
  const ranked = [...TYPE_ORDER.filter(t => types.includes(t))];
  const leftovers = types.filter(t => !TYPE_ORDER.includes(t)).sort();
  const orderedTypes = ranked.concat(leftovers);
  
  refreshDropdown('state', states, 'All states');
  refreshDropdown('type', orderedTypes, 'All college types');
  refreshDropdown('region', ['Northeast', 'Midwest', 'South', 'West', 'Territories'], 'All regions');
  
  // Ensure we're in nearby mode on initial load (default section is open)
  activeMode = 'nearby';
  
  // Render colleges on initial load
    render();
  
  // Show the tip bubble after map is ready (only once per session)
  setTimeout(() => {
    showMapTip();
  }, 500);
}

function geocodeAddress(address, mode = 'nearby'){
  if(!address) {
    if (mode === 'nearby') {
      showError('Please enter an address');
    }
    return Promise.resolve(null);
  }
  
  // Only update map if in the correct active mode
  const shouldUpdateMap = (mode === 'nearby' && activeMode === 'nearby') || (mode === 'route' && activeMode === 'route');
  
  if (mode === 'nearby') {
    closeAutocomplete();
  }
  if (shouldUpdateMap && elements.loading) {
    elements.loading.classList.add('active');
  }
  
  // Note: Address geocoding is independent of state filter - it does not modify state/region/type filters
  // Rate limiting: Nominatim requires a User-Agent and has strict rate limits
  return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`, {
    headers: {
      'User-Agent': 'USCollegeMap/1.0'
    }
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (shouldUpdateMap && elements.loading) {
        elements.loading.classList.remove('active');
      }
      
      if (data && data[0]) {
        const lat = +data[0].lat;
        const lon = +data[0].lon;
        
        if (mode === 'nearby') {
          // Store in nearby state
          home = { lat, lon };
          nearbyState.home = { lat, lon };
          nearbyState.address = address;
          nearbyState.radius = elements.radius ? elements.radius.value : '30';
          nearbyState.units = elements.units ? elements.units.value : 'mi';
          
          // Only update map if nearby mode is active
          if (activeMode === 'nearby') {
        homeLayer.clearLayers();
            radiusLayer.clearLayers();
            
            // Add "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([lat, lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
            
            map.setView([lat, lon], 8);
            render(); // Re-render to apply radius filter
          }
          saveSharedLocation(address, lat, lon);
          saveRecent(RECENT_STORAGE_KEYS.nearby, address);
          return { lat, lon };
        } else if (mode === 'route') {
          // Return for route mode (caller will store it)
          saveSharedLocation(address, lat, lon);
          return { lat, lon, description: address };
        }
      } else {
        if (shouldUpdateMap) {
          showError('Address not found. Please try a different address.');
        }
        return null;
      }
    })
    .catch(error => {
      if (shouldUpdateMap && elements.loading) {
        elements.loading.classList.remove('active');
        showError('Error geocoding address: ' + (error.message || 'Please try again later'));
        console.error('Geocoding error:', error);
      }
      return null;
    });
}

// Address autocomplete functions
function searchAddresses(query) {
  if (!query || query.length < 3) {
    if (!showAddressRecentsIfEligible()) {
      closeAutocomplete();
    }
    return;
  }
  clearRecentState(elements.addressSuggestions);
  
  // Cancel previous request if any
  if (addressAutocomplete.abortController) {
    addressAutocomplete.abortController.abort();
  }
  
  // Show loading state
  addressAutocomplete.suggestions = [];
  addressAutocomplete.selectedIndex = -1;
  elements.addressSuggestions.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
  elements.addressSuggestions.classList.add('active');
  addressAutocomplete.isOpen = true;
  
  // Create new abort controller
  addressAutocomplete.abortController = new AbortController();
  
  // URL encoding prevents XSS and handles special characters
  const sanitizedQuery = query.trim().substring(0, 200); // Limit query length
  
  // Use Cloudflare proxy for Google Places Autocomplete API
  fetch(`https://cold-bread-f865.cannahere2007.workers.dev/?input=${encodeURIComponent(sanitizedQuery)}`, {
    signal: addressAutocomplete.abortController.signal
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      // Handle empty array or invalid response
      if (!Array.isArray(data) || data.length === 0) {
        addressAutocomplete.suggestions = [];
        renderSuggestions();
        return;
      }
      
      // Google Places API already returns well-ranked results
      // Map the response to our format, keeping up to 5 results
      const results = data.slice(0, 5).map(item => ({
        description: item.description || '',
        place_id: item.place_id || '',
        matchedQuery: query
      }));
      
      addressAutocomplete.suggestions = results;
      renderSuggestions();
    })
    .catch(error => {
      if (error.name === 'AbortError') {
        return; // Request was cancelled, ignore
      }
      console.error('Autocomplete error:', error);
      elements.addressSuggestions.innerHTML = '<div class="autocomplete-empty" style="color:#d93025;">Unable to load suggestions. Please try again.</div>';
    });
}

function formatAddressName(displayName, query = '') {
  // Clean up the display name - remove awkward commas after street numbers
  let cleanedName = displayName.replace(/(\d+),\s+/g, '$1 '); // "25, " becomes "25 "
  
  const parts = cleanedName.split(',').map(p => p.trim()).filter(p => p);
  let primary, secondary;
  
  // Format like Google Maps: primary address on first line, location details on second
  if (parts.length >= 3) {
    // Full address: "Street Address, City, State, Country"
    // Primary: Street Address (first part)
    // Secondary: City, State, Country (remaining parts)
    primary = parts[0];
    secondary = parts.slice(1).join(', ');
  } else if (parts.length === 2) {
    // Two parts: check if first is just a number
    if (/^\d+$/.test(parts[0])) {
      // If "25, Location" -> combine to "25 Location"
      primary = parts.join(' ');
      secondary = '';
    } else {
      // "Street, City" -> Primary: Street, Secondary: City
      primary = parts[0];
      secondary = parts[1];
    }
  } else {
    // Single part
    primary = cleanedName;
    secondary = '';
  }
  
  // Escape HTML first, then apply highlighting
  // This is simpler and safer - we'll find matches in escaped text
  const escapeHtml = (text) => text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  
  // Escape the text first
  let escapedPrimary = escapeHtml(primary);
  secondary = escapeHtml(secondary);
  
  // Now apply highlighting on the escaped text
  if (query && query.length >= 2) {
    const queryLower = query.toLowerCase().trim();
    const escapedQueryLower = escapeHtml(query).toLowerCase();
    const escapedPrimaryLower = escapedPrimary.toLowerCase();
    const matchIndex = escapedPrimaryLower.indexOf(escapedQueryLower);
    
    if (matchIndex !== -1) {
      const before = escapedPrimary.substring(0, matchIndex);
      const match = escapedPrimary.substring(matchIndex, matchIndex + escapeHtml(query).length);
      const after = escapedPrimary.substring(matchIndex + escapeHtml(query).length);
      escapedPrimary = `${before}<strong>${match}</strong>${after}`;
    }
  }
  
  primary = escapedPrimary;
  
  return { primary, secondary };
}

function getAddressTypeIcon(type) {
  // Determine icon based on address type
  const icons = {
    'place': '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>',
    'house': '<path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>',
    'default': '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>'
  };
  
  const addressType = (type || '').toLowerCase();
  if (addressType.includes('house') || addressType.includes('building') || addressType.includes('residential')) {
    return icons.house;
  }
  if (addressType.includes('place') || addressType.includes('point')) {
    return icons.place;
  }
  return icons.default;
}

function renderSuggestions() {
  clearRecentState(elements.addressSuggestions);
  const queryValue = (elements.address?.value || '').trim();
  const unifiedSection = buildUnifiedRecentSection(getFallbackRecentsForField('address'), {
    query: queryValue,
    filterShared: true,
    filterFallback: true
  });
  if (addressAutocomplete.suggestions.length === 0) {
    const emptyHtml = '<div class="autocomplete-empty" role="option">No suggestions found</div>';
    elements.addressSuggestions.innerHTML = unifiedSection ? unifiedSection + emptyHtml : emptyHtml;
    return;
  }
  
  const html = addressAutocomplete.suggestions.map((item, index) => {
    const isSelected = index === addressAutocomplete.selectedIndex;
    const query = item.matchedQuery || '';
    const formatted = formatAddressName(item.description, query);
    
    // formatAddressName already escapes HTML and handles <strong> tags
    const safePrimary = formatted.primary;
    const safeSecondary = formatted.secondary;
    const safeFullName = item.description.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;');
    
    // Get icon - Google Places API doesn't provide type in autocomplete, use default
    const iconPath = getAddressTypeIcon('place');
    
    return `
      <div class="autocomplete-item ${isSelected ? 'highlighted' : ''}" 
           role="option"
           id="suggestion-${index}"
           aria-selected="${isSelected}"
           tabindex="${isSelected ? '0' : '-1'}"
           data-index="${index}">
        <div class="autocomplete-item-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            ${iconPath}
          </svg>
        </div>
        <div class="autocomplete-item-content">
          <div class="address-name">${safePrimary}</div>
          ${safeSecondary ? `<div class="address-details">${safeSecondary}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  elements.addressSuggestions.innerHTML = unifiedSection + html;
  elements.address.setAttribute('aria-expanded', 'true');
  
  // Add mouseenter handlers for highlighting
  elements.addressSuggestions.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    // Ensure item is properly clickable
    item.style.pointerEvents = 'auto';
    item.style.cursor = 'pointer';
    
    // Add direct click handler - this is the primary method
    const handleClick = (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      e.stopPropagation();
      selectSuggestion(index);
      return false;
    };
    
    item.addEventListener('click', handleClick, true);
    item.addEventListener('mousedown', (e) => {
      e.preventDefault(); // Prevent input blur
    });
    
    // Update highlight without re-rendering - just update classes
    item.addEventListener('mouseenter', () => {
      addressAutocomplete.selectedIndex = index;
      updateHighlight();
    });
    
    // Also handle touch events for mobile
    item.addEventListener('touchend', handleClick, { passive: false, capture: true });
  });
}

function selectSuggestion(index) {
  if (!addressAutocomplete.suggestions || !addressAutocomplete.suggestions[index]) {
    console.warn('No suggestion at index:', index, 'Available:', addressAutocomplete.suggestions.length);
    return;
  }
  
  const suggestion = addressAutocomplete.suggestions[index];
  const description = suggestion.description || '';
  
  if (!description) {
    console.warn('No description found for suggestion at index:', index);
    return;
  }
  
  // Mark that we're programmatically setting the value (prevents triggering new search)
  addressAutocomplete.isSelecting = true;
  
  // Close dropdown FIRST - instant visual feedback
  closeAutocomplete();
  
  // Set the input value immediately - user sees it instantly
  elements.address.value = description;
  saveRecent(RECENT_STORAGE_KEYS.nearby, description);
  
  // Clear the flag after a brief delay to allow the value to be set
  setTimeout(() => {
    addressAutocomplete.isSelecting = false;
  }, 100);
  
  // Geocode the address to update the map (this happens asynchronously)
  // Always geocode and show pin if we're in nearby mode
  // Also check if the nearby section is open (even if activeMode hasn't been set yet)
  const nearbySection = document.querySelector('details.filter-section[open] summary');
  const isNearbySectionOpen = nearbySection && nearbySection.textContent.trim().includes('Find Colleges Nearby');
  
  if (activeMode === 'nearby' || isNearbySectionOpen) {
    // Ensure activeMode is set to nearby if section is open
    if (isNearbySectionOpen && activeMode !== 'nearby') {
      activeMode = 'nearby';
    }
    geocodeAddress(description, 'nearby');
  } else {
    // Store the address value but don't update map if in route mode
    nearbyState.address = description;
  }
}

function closeAutocomplete() {
  clearRecentState(elements.addressSuggestions);
  elements.addressSuggestions.classList.remove('active');
  elements.address.setAttribute('aria-expanded', 'false');
  addressAutocomplete.isOpen = false;
  addressAutocomplete.selectedIndex = -1;
}

function updateHighlight() {
  // Update highlight without re-rendering - just update classes
  elements.addressSuggestions.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    if (index === addressAutocomplete.selectedIndex) {
      item.classList.add('highlighted');
      item.setAttribute('aria-selected', 'true');
      item.setAttribute('tabindex', '0');
    } else {
      item.classList.remove('highlighted');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('tabindex', '-1');
    }
  });
}

function handleAutocompleteKeydown(e) {
  if (!addressAutocomplete.isOpen || addressAutocomplete.suggestions.length === 0) {
    if (e.key === 'Enter') {
      e.preventDefault();
      geocodeAddress(elements.address.value);
    }
    return;
  }
  
  switch(e.key) {
    case 'ArrowDown':
      e.preventDefault();
      addressAutocomplete.selectedIndex = Math.min(
        addressAutocomplete.selectedIndex + 1,
        addressAutocomplete.suggestions.length - 1
      );
      updateHighlight();
      scrollToSelected();
      break;
      
    case 'ArrowUp':
      e.preventDefault();
      addressAutocomplete.selectedIndex = Math.max(addressAutocomplete.selectedIndex - 1, -1);
      updateHighlight();
      scrollToSelected();
      break;
      
    case 'Enter':
      e.preventDefault();
      if (addressAutocomplete.selectedIndex >= 0) {
        selectSuggestion(addressAutocomplete.selectedIndex);
      } else {
        geocodeAddress(elements.address.value);
      }
      break;
      
    case 'Escape':
      e.preventDefault();
      closeAutocomplete();
      break;
  }
}

function scrollToSelected() {
  const selected = elements.addressSuggestions.querySelector('.autocomplete-item.highlighted');
  if (selected) {
    selected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

// Route autocomplete functions (similar to address autocomplete but for route fields)
function searchRouteAddresses(query, autocompleteObj, inputElement, suggestionsContainer) {
  const storageKey = inputElement && inputElement.id === 'routeStart' ? RECENT_STORAGE_KEYS.routeStart : RECENT_STORAGE_KEYS.routeEnd;
  const context = inputElement && inputElement.id === 'routeStart' ? 'routeStart' : 'routeEnd';
  if (!query || query.length < 3) {
    if (!showRouteRecentsIfEligible(inputElement, suggestionsContainer, autocompleteObj, storageKey, context)) {
      closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement);
    }
    return;
  }
  clearRecentState(suggestionsContainer);
  
  if (autocompleteObj.abortController) {
    autocompleteObj.abortController.abort();
  }
  
  autocompleteObj.suggestions = [];
  autocompleteObj.selectedIndex = -1;
  suggestionsContainer.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
  suggestionsContainer.classList.add('active');
  autocompleteObj.isOpen = true;
  
  autocompleteObj.abortController = new AbortController();
  const sanitizedQuery = query.trim().substring(0, 200);
  
  fetch(`https://cold-bread-f865.cannahere2007.workers.dev/?input=${encodeURIComponent(sanitizedQuery)}`, {
    signal: autocompleteObj.abortController.signal
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (!data || !Array.isArray(data) || data.length === 0) {
        autocompleteObj.suggestions = [];
        renderRouteSuggestions(autocompleteObj, suggestionsContainer);
        return;
      }
      
      const results = data.slice(0, 5).map(item => ({
        description: item.description || '',
        place_id: item.place_id || ''
      }));
      
      autocompleteObj.suggestions = results;
      renderRouteSuggestions(autocompleteObj, suggestionsContainer, inputElement);
    })
    .catch(error => {
      if (error.name !== 'AbortError') {
        console.error('Route autocomplete error:', error);
        autocompleteObj.suggestions = [];
        if (suggestionsContainer) {
          suggestionsContainer.innerHTML = '<div class="autocomplete-empty" style="color:#d93025;">Unable to load suggestions. Please try again.</div>';
        }
      }
    });
}

function renderRouteSuggestions(autocompleteObj, suggestionsContainer, inputElement) {
  clearRecentState(suggestionsContainer);
  const fieldId = (inputElement && inputElement.id === 'routeEnd') ? 'routeEnd' :
                  (inputElement && inputElement.id === 'routeStart') ? 'routeStart' :
                  (suggestionsContainer && suggestionsContainer.dataset.field) || '';
  const queryValue = (inputElement?.value || '').trim();
  const unifiedSection = buildUnifiedRecentSection(getFallbackRecentsForField(fieldId), {
    query: queryValue,
    filterShared: true,
    filterFallback: true
  });
  if (autocompleteObj.suggestions.length === 0) {
    const emptyHtml = '<div class="autocomplete-empty" role="option">No suggestions found</div>';
    suggestionsContainer.innerHTML = unifiedSection ? unifiedSection + emptyHtml : emptyHtml;
    return;
  }
  
  // Get icon function (same as nearby autocomplete)
  const getAddressTypeIcon = (type) => {
    const icons = {
      place: '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>',
      default: '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>'
    };
    return icons[type] || icons.default;
  };
  
  const html = autocompleteObj.suggestions.map((item, index) => {
    const isSelected = index === autocompleteObj.selectedIndex;
    const formatted = formatAddressName(item.description, '');
    const iconPath = getAddressTypeIcon('place');
    
    return `
      <div class="autocomplete-item ${isSelected ? 'highlighted' : ''}" 
           role="option" 
           aria-selected="${isSelected}" 
           tabindex="${isSelected ? '0' : '-1'}"
           data-index="${index}">
        <div class="autocomplete-item-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            ${iconPath}
          </svg>
        </div>
        <div class="autocomplete-item-content">
          <div class="address-name">${formatted.primary}</div>
          ${formatted.secondary ? `<div class="address-details">${formatted.secondary}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  suggestionsContainer.innerHTML = unifiedSection + html;
  inputElement.setAttribute('aria-expanded', 'true');
  
  suggestionsContainer.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    item.style.pointerEvents = 'auto';
    item.style.cursor = 'pointer';
    
    const handleClick = (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      e.stopPropagation();
      selectRouteSuggestion(index, autocompleteObj, inputElement, suggestionsContainer);
      return false;
    };
    
    item.addEventListener('click', handleClick, true);
    item.addEventListener('mousedown', (e) => {
      e.preventDefault();
    });
    
    item.addEventListener('mouseenter', () => {
      autocompleteObj.selectedIndex = index;
      updateRouteHighlight(autocompleteObj, suggestionsContainer);
    });
    
    item.addEventListener('touchend', handleClick, { passive: false, capture: true });
  });
}

function selectRouteSuggestion(index, autocompleteObj, inputElement, suggestionsContainer) {
  if (!autocompleteObj.suggestions || !autocompleteObj.suggestions[index]) {
    return;
  }
  
  const suggestion = autocompleteObj.suggestions[index];
  const description = suggestion.description || '';
  
  if (!description) {
    return;
  }
  
  autocompleteObj.isSelecting = true;
  closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement);
  inputElement.value = description;
  if (inputElement.id === 'routeStart') {
    saveRecent(RECENT_STORAGE_KEYS.routeStart, description);
  } else if (inputElement.id === 'routeEnd') {
    saveRecent(RECENT_STORAGE_KEYS.routeEnd, description);
  }
  
  setTimeout(() => {
    autocompleteObj.isSelecting = false;
  }, 100);
  
  // Geocode and store in route state (but don't update map yet)
  geocodeAddress(description, 'route').then(result => {
    if (result) {
      if (inputElement.id === 'routeStart') {
        route.start = { description, lat: result.lat, lon: result.lon };
        console.log('Route start set:', route.start);
      } else if (inputElement.id === 'routeEnd') {
        route.end = { description, lat: result.lat, lon: result.lon };
        console.log('Route end set:', route.end);
      }
    } else {
      console.warn('Geocoding failed for route address:', description);
    }
  }).catch(error => {
    console.error('Error geocoding route address:', error);
  });
}

function closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement) {
  clearRecentState(suggestionsContainer);
  suggestionsContainer.classList.remove('active');
  inputElement.setAttribute('aria-expanded', 'false');
  autocompleteObj.isOpen = false;
  autocompleteObj.selectedIndex = -1;
}

function updateRouteHighlight(autocompleteObj, suggestionsContainer) {
  suggestionsContainer.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    if (index === autocompleteObj.selectedIndex) {
      item.classList.add('highlighted');
      item.setAttribute('aria-selected', 'true');
      item.setAttribute('tabindex', '0');
    } else {
      item.classList.remove('highlighted');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('tabindex', '-1');
    }
  });
}

/**
 * LAZY LOADED: Route calculation function - only executed when route mode is first used
 * Calculate perpendicular distance from a point to a line segment (using Haversine formula)
 * Returns the shortest distance from point P to line segment AB
 * 
 * Performance: This heavy computation is only executed when user interacts with route mode
 */
function distanceToLineSegment(pointLat, pointLon, lineStartLat, lineStartLon, lineEndLat, lineEndLon, units = 'mi') {
  // Calculate distances to endpoints
  const dAP = calculateDistance(lineStartLat, lineStartLon, pointLat, pointLon, units);
  const dBP = calculateDistance(lineEndLat, lineEndLon, pointLat, pointLon, units);
  const dAB = calculateDistance(lineStartLat, lineStartLon, lineEndLat, lineEndLon, units);
  
  // If the line segment is very short, return distance to nearest endpoint
  if (dAB < 0.01) {
    return Math.min(dAP, dBP);
  }
  
  // Use the law of cosines to find the angle at point A
  // cos(angle) = (a¬≤ + c¬≤ - b¬≤) / (2ac)
  // where a = dAP, b = dBP, c = dAB
  const cosAngle = (dAP * dAP + dAB * dAB - dBP * dBP) / (2 * dAP * dAB);
  
  // Clamp cosAngle to [-1, 1] to avoid NaN from acos
  const clampedCos = Math.max(-1, Math.min(1, cosAngle));
  const angle = Math.acos(clampedCos);
  
  // Calculate perpendicular distance using sine
  // distance = dAP * sin(angle)
  const perpendicularDist = dAP * Math.sin(angle);
  
  // Check if the perpendicular point is within the segment
  // If angle > 90 degrees, the perpendicular is beyond point A
  // If the distance along AB from A is > dAB, it's beyond point B
  const distAlongAB = dAP * Math.cos(angle);
  
  if (distAlongAB < 0 || distAlongAB > dAB) {
    // Perpendicular point is outside the segment, return distance to nearest endpoint
    return Math.min(dAP, dBP);
  }
  
  return Math.abs(perpendicularDist);
}

/**
 * LAZY LOADED: Route search function - only executed when user clicks "Find" in route mode
 * Prevents infinite loops by checking if already processing
 * 
 * Performance: Heavy OSRM API calls and distance calculations only run when:
 * - User enters start/end addresses AND clicks "Find" button
 * - NOT on initial page load
 * - NOT when just switching to route mode
 */
let isProcessingRoute = false;

function findCollegesAlongRoute() {
  // Guard against infinite loops
  if (isProcessingRoute) {
    console.log('Route already processing, skipping...');
    return;
  }
  
  if (activeMode !== 'route') {
    console.log('Not in route mode, current mode:', activeMode);
    return;
  }
  
  if (!route.start || !route.end) {
    showError('Please enter both starting and destination addresses.');
    console.log('Route start or end missing:', { start: route.start, end: route.end });
    return;
  }
  
  console.log('Starting route search...', { start: route.start, end: route.end });
  isProcessingRoute = true;
  
  const maxDistance = parseFloat(elements.routeMaxDistance?.value || '30') || 30;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  
  // Store route search state
  route.lastSearch = {
    start: route.start,
    end: route.end,
    maxDistance,
    units
  };
  
  if (elements.loading) elements.loading.classList.add('active');
  
  // Clear previous route visualization
  routeLayer.clearLayers();
  homeLayer.clearLayers();
  radiusLayer.clearLayers();
  
  // Get actual driving route using OSRM (Open Source Routing Machine)
  // Format: lon,lat (OSRM uses lon,lat order)
  const startCoords = `${route.start.lon},${route.start.lat}`;
  const endCoords = `${route.end.lon},${route.end.lat}`;
  const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${startCoords};${endCoords}?overview=full&geometries=geojson`;
  
  fetch(osrmUrl)
    .then(r => {
      if (!r.ok) throw new Error(`Routing failed: ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
        throw new Error('No route found');
      }
      
      const routeGeometry = data.routes[0].geometry.coordinates;
      // Convert from [lon, lat] to [lat, lon] for Leaflet
      const routeCoords = routeGeometry.map(coord => [coord[1], coord[0]]);
      
      // Draw the actual driving route
      const routeLine = L.polyline(routeCoords, {
        color: '#2563eb',
        weight: 4,
        opacity: 0.8
      }).addTo(routeLayer);
      
      // Draw start and destination markers (map pins - smaller size)
      // Start pin (green)
      const startPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#10b981" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
      L.marker([route.start.lat, route.start.lon], {
        icon: L.icon({
          iconUrl: 'data:image/svg+xml;base64,' + btoa(startPinSvg),
          iconSize: [24, 30],
          iconAnchor: [12, 30],
          popupAnchor: [0, -30]
        })
      }).addTo(routeLayer).bindPopup('From');
      
      // Destination pin (red)
      const destinationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
      L.marker([route.end.lat, route.end.lon], {
        icon: L.icon({
          iconUrl: 'data:image/svg+xml;base64,' + btoa(destinationPinSvg),
          iconSize: [24, 30],
          iconAnchor: [12, 30],
          popupAnchor: [0, -30]
        })
      }).addTo(routeLayer).bindPopup('To');
      
      // Calculate route bounds and fit map
      const polylineBounds = L.latLngBounds(routeCoords);
      let routeBounds = L.latLngBounds(routeCoords);
      
      // Filter colleges along the route using perpendicular distance
      // Sample route points to improve performance (check every 10th point for long routes)
      const sampleRate = routeCoords.length > 100 ? 10 : 1;
      const sampledRoute = [];
      for (let i = 0; i < routeCoords.length; i += sampleRate) {
        sampledRoute.push(routeCoords[i]);
      }
      // Always include the last point
      if (sampledRoute[sampledRoute.length - 1] !== routeCoords[routeCoords.length - 1]) {
        sampledRoute.push(routeCoords[routeCoords.length - 1]);
      }
      
      const filtered = colleges.filter(c => {
        // Check distance to each segment of the sampled route
        let minDistance = Infinity;
        
        for (let i = 0; i < sampledRoute.length - 1; i++) {
          const segmentStart = sampledRoute[i];
          const segmentEnd = sampledRoute[i + 1];
          
          const dist = distanceToLineSegment(
            c.lat, c.lon,
            segmentStart[0], segmentStart[1],
            segmentEnd[0], segmentEnd[1],
            units
          );
          
          minDistance = Math.min(minDistance, dist);
          
          // Early exit if we're already within range
          if (minDistance <= maxDistance) {
            break;
          }
        }
        
        return minDistance <= maxDistance;
      });
      
      // Apply other filters (type, region, state, search)
      const typeVal = elements.type ? elements.type.value.trim() : '';
      const regionVal = elements.region ? elements.region.value.trim() : '';
      const stateVal = elements.state ? elements.state.value.trim() : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      const filtersSnapshot = { typeVal, regionVal, stateVal, searchVal, maxDistance, units };
      const cachedColleges = [];
      const finalFiltered = filtered.filter(c => {
        // Type filter - check both type and tier fields
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        // Region filter - use REGION_MAP to check if state is in region
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        return true;
      });
      
      // Clear and render markers (using same style as nearby mode - blue circle dots)
      markersLayer.clearLayers();
      finalFiltered.forEach(c => {
        let distanceText = '';
        let minRouteDist = Infinity;
        for (let i = 0; i < sampledRoute.length - 1; i++) {
          const dist = distanceToLineSegment(
            c.lat, c.lon,
            sampledRoute[i][0], sampledRoute[i][1],
            sampledRoute[i + 1][0], sampledRoute[i + 1][1],
            units
          );
          minRouteDist = Math.min(minRouteDist, dist);
        }
        if (minRouteDist < Infinity) {
          distanceText = `<br>Distance from route: ${minRouteDist.toFixed(1)} ${units}`;
        }
        addRouteCollegeMarker(c, distanceText, units);
        cachedColleges.push({ college: c, distanceText });
        routeBounds.extend([c.lat, c.lon]);
      });
      
      if (elements.count) elements.count.textContent = finalFiltered.length;
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Update map hints for route mode
      updateMapHints(finalFiltered.length, typeVal, regionVal, stateVal, searchVal);
      
      // Store route visualization for restoration
      if (routeBounds.isValid()) {
        if (finalFiltered.length > 0) {
          map.fitBounds(routeBounds.pad(0.15));
        } else {
          map.fitBounds(polylineBounds.pad(0.15));
        }
      }

      route.lastResult = {
        bounds: routeBounds.isValid() ? routeBounds : polylineBounds,
        routeCoords,
        colleges: cachedColleges,
        filters: filtersSnapshot,
        start: route.start ? { ...route.start } : null,
        end: route.end ? { ...route.end } : null
      };
      
      isProcessingRoute = false;
    })
    .catch(error => {
      console.error('Route calculation error:', error);
      // Fallback to straight line if routing fails
      const fallbackRouteCoords = [
        [route.start.lat, route.start.lon],
        [route.end.lat, route.end.lon]
      ];
      L.polyline(
        fallbackRouteCoords,
        { color: '#2563eb', weight: 3, opacity: 0.7 }
      ).addTo(routeLayer);
      const fallbackBounds = L.latLngBounds(fallbackRouteCoords);
      
      // Use simple distance calculation as fallback
      const filtered = colleges.filter(c => {
        const distToStart = calculateDistance(route.start.lat, route.start.lon, c.lat, c.lon, units);
        const distToEnd = calculateDistance(route.end.lat, route.end.lon, c.lat, c.lon, units);
        const routeLength = calculateDistance(route.start.lat, route.start.lon, route.end.lat, route.end.lon, units);
        
        // Simple approximation: if within maxDistance of the straight line
        const minDist = Math.min(distToStart, distToEnd);
        if (minDist <= maxDistance) return true;
        
        // Check if point is within corridor (rough approximation)
        const midLat = (route.start.lat + route.end.lat) / 2;
        const midLon = (route.start.lon + route.end.lon) / 2;
        const distToMid = calculateDistance(midLat, midLon, c.lat, c.lon, units);
        return distToMid <= maxDistance * 1.5; // Slightly more lenient for fallback
      });
      
      // Apply other filters
      const typeVal = elements.type ? elements.type.value.trim() : '';
      const regionVal = elements.region ? elements.region.value.trim() : '';
      const stateVal = elements.state ? elements.state.value.trim() : '';
      const searchVal = (elements.search ? elements.search.value.trim().toLowerCase() : '') || 
                        (document.getElementById('search-mobile') ? document.getElementById('search-mobile').value.trim().toLowerCase() : '');
      
      const filtersSnapshot = { typeVal, regionVal, stateVal, searchVal, maxDistance, units };
      const finalFiltered = filtered.filter(c => {
        // Type filter - check both type and tier fields
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        // Region filter - use REGION_MAP to check if state is in region
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        return true;
      });
      
      // Clear and render markers (using same style as nearby mode)
      markersLayer.clearLayers();
      const cachedColleges = [];
      const fallbackCollegeBounds = L.latLngBounds(fallbackRouteCoords);
      finalFiltered.forEach(c => {
        const distToStart = calculateDistance(route.start.lat, route.start.lon, c.lat, c.lon, units);
        const distToEnd = calculateDistance(route.end.lat, route.end.lon, c.lat, c.lon, units);
        const minDist = Math.min(distToStart, distToEnd);
        const distanceText = `<br>Approx. distance from route: ${minDist.toFixed(1)} ${units}`;
        addRouteCollegeMarker(c, distanceText, units);
        cachedColleges.push({ college: c, distanceText });
        fallbackCollegeBounds.extend([c.lat, c.lon]);
      });
      
      if (elements.count) elements.count.textContent = finalFiltered.length;
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Update map hints for route mode (fallback)
      updateMapHints(finalFiltered.length, typeVal, regionVal, stateVal, searchVal);
      if (fallbackCollegeBounds.isValid()) {
        map.fitBounds(fallbackCollegeBounds.pad(0.15));
      } else if (fallbackBounds.isValid()) {
        map.fitBounds(fallbackBounds.pad(0.15));
      }

      route.lastResult = {
        bounds: fallbackCollegeBounds.isValid() ? fallbackCollegeBounds : fallbackBounds,
        routeCoords: fallbackRouteCoords,
        colleges: cachedColleges,
        filters: filtersSnapshot,
        start: route.start ? { ...route.start } : null,
        end: route.end ? { ...route.end } : null
      };
      
      showError('Could not calculate driving route. Showing approximate results.');
      
      isProcessingRoute = false;
    });
}

// Initialize dropdowns immediately
// Region dropdown (doesn't depend on CSV)
refreshDropdown('region', ['Northeast', 'Midwest', 'South', 'West', 'Territories'], 'All regions');

// Type dropdown (initialize with common types, will be updated when CSV loads)
try {
  refreshDropdown('type', TYPE_ORDER.filter(Boolean), 'Any college type');
} catch (e) {
  console.error('Error initializing type dropdown:', e);
  // Fallback: ensure dropdown at least exists
  const typeSelect = document.getElementById('type');
  if (typeSelect) {
    typeSelect.innerHTML = '<option value="">All college types</option>';
  }
}

// Event listeners
if (elements.geocodeBtn) {
  elements.geocodeBtn.onclick = () => {
    if (activeMode === 'nearby' && elements.address) {
      hasUsedSearchControls = true; // User actively clicked Locate button
      geocodeAddress(elements.address.value, 'nearby');
    }
  };
}

// Address autocomplete
if (elements.address) {
  elements.address.addEventListener('input', debounce((e) => {
    // Don't trigger search if we're programmatically setting the value
    if (addressAutocomplete.isSelecting) {
      return;
    }
    searchAddresses(e.target.value);
  }, 400));

  elements.address.addEventListener('keydown', handleAutocompleteKeydown);
  elements.address.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.address, true);
    showAddressRecentsIfEligible();
  });
  elements.address.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.address, false);
      closeAutocomplete();
    }, 120);
  });
}

// Event delegation as backup (items have direct handlers, but this catches edge cases)
if (elements.addressSuggestions) {
  elements.addressSuggestions.addEventListener('click', (e) => {
    const item = e.target.closest('.autocomplete-item');
    if (item) {
      if (item.dataset.recent === 'true') {
        e.preventDefault();
        e.stopPropagation();
        const decodedValue = item.dataset.value ? decodeURIComponent(item.dataset.value) : '';
        handleRecentAddressSelection(decodedValue);
        return;
      }
      if (item.classList.contains('shared-location')) {
        e.preventDefault();
        e.stopPropagation();
        const field = elements.addressSuggestions?.dataset.field || 'address';
        const description = item.dataset.description ? decodeURIComponent(item.dataset.description) : '';
        handleSharedLocationSelection(field, description);
        return;
      }
      const index = parseInt(item.dataset.index, 10);
      if (!isNaN(index) && index >= 0) {
        e.preventDefault();
        e.stopPropagation();
        selectSuggestion(index);
      }
    }
  }, true);
  elements.addressSuggestions.addEventListener('mousedown', (e) => {
    if (e.target.closest('.recent-suggestion') || e.target.closest('.shared-location')) {
      e.preventDefault();
    }
  }, true);
}

// Handle route recents in suggestion containers
[elements.routeStartSuggestions, elements.routeEndSuggestions].forEach(container => {
  if (!container) return;
  container.addEventListener('click', (e) => {
    const recentItem = e.target.closest('.recent-suggestion');
    if (recentItem) {
      e.preventDefault();
      e.stopPropagation();
      const decodedValue = recentItem.dataset.value ? decodeURIComponent(recentItem.dataset.value) : '';
      handleRecentRouteSelection(decodedValue, container.dataset.recentContext || '');
      return;
    }
    const sharedItem = e.target.closest('.shared-location');
    if (sharedItem) {
      e.preventDefault();
      e.stopPropagation();
      const description = sharedItem.dataset.description ? decodeURIComponent(sharedItem.dataset.description) : '';
      const field = container.dataset.field || '';
      handleSharedLocationSelection(field, description);
    }
  }, true);
  container.addEventListener('mousedown', (e) => {
    if (e.target.closest('.recent-suggestion') || e.target.closest('.shared-location')) {
      e.preventDefault();
    }
  }, true);
});

// Close autocomplete when clicking outside
document.addEventListener('click', (e) => {
  // Only close if click is truly outside
  if (elements.address && elements.addressSuggestions && 
      !elements.address.contains(e.target) && 
      !elements.addressSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeAutocomplete();
  }
  // Close route autocompletes
  if (elements.routeStart && elements.routeStartSuggestions && 
      !elements.routeStart.contains(e.target) && 
      !elements.routeStartSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
  }
  if (elements.routeEnd && elements.routeEndSuggestions && 
      !elements.routeEnd.contains(e.target) && 
      !elements.routeEndSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
  }
}, true);

// Route autocomplete event listeners
if (elements.routeStart) {
  elements.routeStart.addEventListener('input', debounce((e) => {
    if (routeStartAutocomplete.isSelecting) {
      return;
    }
    searchRouteAddresses(e.target.value, routeStartAutocomplete, elements.routeStart, elements.routeStartSuggestions);
  }, 400));
  elements.routeStart.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.routeStart, true);
    showRouteRecentsIfEligible(elements.routeStart, elements.routeStartSuggestions, routeStartAutocomplete, RECENT_STORAGE_KEYS.routeStart, 'routeStart');
  });
  elements.routeStart.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.routeStart, false);
      if (elements.routeStartSuggestions) {
        closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
      }
    }, 120);
  });
}

if (elements.routeEnd) {
  elements.routeEnd.addEventListener('input', debounce((e) => {
    if (routeEndAutocomplete.isSelecting) {
      return;
    }
    searchRouteAddresses(e.target.value, routeEndAutocomplete, elements.routeEnd, elements.routeEndSuggestions);
  }, 400));
  elements.routeEnd.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.routeEnd, true);
    showRouteRecentsIfEligible(elements.routeEnd, elements.routeEndSuggestions, routeEndAutocomplete, RECENT_STORAGE_KEYS.routeEnd, 'routeEnd');
  });
  elements.routeEnd.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.routeEnd, false);
      if (elements.routeEndSuggestions) {
        closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
      }
    }, 120);
  });
}

// Route search button
if (elements.findRouteBtn) {
  elements.findRouteBtn.onclick = async () => {
    // If addresses are entered but not geocoded yet, geocode them first
    if (elements.routeStart && elements.routeStart.value && !route.start) {
      const startAddress = elements.routeStart.value;
      const startResult = await geocodeAddress(startAddress, 'route');
      if (startResult) {
        route.start = { description: startAddress, lat: startResult.lat, lon: startResult.lon };
        saveRecent(RECENT_STORAGE_KEYS.routeStart, startAddress);
      }
    }
    
    if (elements.routeEnd && elements.routeEnd.value && !route.end) {
      const endAddress = elements.routeEnd.value;
      const endResult = await geocodeAddress(endAddress, 'route');
      if (endResult) {
        route.end = { description: endAddress, lat: endResult.lat, lon: endResult.lon };
        saveRecent(RECENT_STORAGE_KEYS.routeEnd, endAddress);
      }
    }
    
    hasUsedSearchControls = true; // User actively clicked Find Route button
    // Now call the route search function
    findCollegesAlongRoute();
  };
}

// Route clear button
if (elements.clearRoute) {
  elements.clearRoute.onclick = () => {
    if (elements.routeStart) elements.routeStart.value = '';
    if (elements.routeEnd) elements.routeEnd.value = '';
    if (elements.routeMaxDistance) elements.routeMaxDistance.value = '30';
    if (elements.routeUnits) elements.routeUnits.value = 'mi';
    route.start = null;
    route.end = null;
    route.lastSearch = null;
     route.lastResult = null;
    routeLayer.clearLayers();
    if (elements.routeStartSuggestions && elements.routeStart) {
      closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
    }
    if (elements.routeEndSuggestions && elements.routeEnd) {
      closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
    }
    // When clearing route, show colleges based on current filter settings
    if (activeMode === 'route') {
      // Clear route visualization
      routeLayer.clearLayers();
      // Show all colleges filtered by type, region, state, and search
      markersLayer.clearLayers();
      
      // Apply filters from dropdowns
      const stateVal = elements.state ? elements.state.value : '';
      const regionVal = elements.region ? elements.region.value : '';
      const typeVal = elements.type ? elements.type.value : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      
      let filtered = colleges.filter(c => {
        // Region filter
        const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
        if (!regionMatch) return false;
        
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        
        // Type filter
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        return true;
      });
      
      // Render filtered colleges
      filtered.forEach(c => {
        try {
          if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
            return;
          }
          
          const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
          const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
          
          const popupContent = `
            <div style="font-size:12px;line-height:1.4">
              <b>${c.name}</b><br>
              ${c.state} ¬∑ ${(c.type||'Unknown')}<br>
              ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
              Enrollment: ${c.enrollment || 'N/A'}<br>
              Tuition: ${tuition}<br>
              ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
            </div>`;
          
          L.circleMarker([c.lat, c.lon], {radius: 5, color: '#2563eb', weight: 2, fillOpacity: 0.7})
            .bindTooltip(c.name, {permanent: false, direction: 'top'})
            .bindPopup(popupContent)
            .addTo(markersLayer);
        } catch (e) {
          console.error(`Error creating marker for ${c.name}:`, e);
        }
      });
      
      if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
      
      // Update map hints after clearing route
      updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
      
      map.setView([39.5, -98.35], 4);
    }
  };
}

if (elements.clearRadius) {
  elements.clearRadius.onclick = () => {
    if (elements.radius) elements.radius.value = '30';
    if (elements.address) elements.address.value = '';
    // Clear both desktop and mobile search fields
    if (elements.search) elements.search.value = '';
    const mobileSearch = document.getElementById('search-mobile');
    if (mobileSearch) mobileSearch.value = '';
    home = null;
    homeLayer.clearLayers();
    radiusLayer.clearLayers();
    closeAutocomplete();
    map.setView([39.5, -98.35], 4);
    render();
  };
}

// Accordion behavior for filter sections - when one opens, close the other
const filterSections = document.querySelectorAll('.filter-section');
if (filterSections.length) {
  const isMobileViewport = window.innerWidth <= 700;
  if (!isMobileViewport) {
    filterSections[0].setAttribute('open', '');
  } else {
    filterSections[0].removeAttribute('open');
  }
}
filterSections.forEach(section => {
  section.addEventListener('toggle', (e) => {
    // Remove active class from all sections first
    filterSections.forEach(s => s.classList.remove('active'));
    
    // Find the currently open section and mark it as active
    const openSection = Array.from(filterSections).find(s => s.open);
    if (openSection) {
      openSection.classList.add('active');
    }
    
    // Only act if this section is now open (was just opened)
    if (section.open) {
      // Determine which section opened
      const summary = section.querySelector('summary');
      const isNearby = summary && summary.textContent.trim().includes('Find Colleges Nearby');
      const isRoute = summary && summary.textContent.trim().includes('Find Colleges Along a Route');
      
      // Set active mode
      if (isNearby) {
        activeMode = 'nearby';
        // Clear route visualization when switching to nearby mode
        routeLayer.clearLayers();
        // Restore nearby state if available
        if (nearbyState.home) {
          home = nearbyState.home;
          if (elements.address && nearbyState.address) {
            elements.address.value = nearbyState.address;
          }
          if (elements.radius && nearbyState.radius) {
            elements.radius.value = nearbyState.radius;
          }
          if (elements.units && nearbyState.units) {
            elements.units.value = nearbyState.units;
          }
          // Re-apply the search and recreate the pin marker
          if (home) {
            // Clear and recreate the pin marker
            homeLayer.clearLayers();
            radiusLayer.clearLayers();
            
            // Recreate "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([home.lat, home.lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
            
            render();
          }
        } else {
          // If no nearby state, rely on render to determine framing
          render();
        }
      } else if (isRoute) {
        activeMode = 'route';
        // Clear nearby visualization when switching to route mode
        homeLayer.clearLayers();
        radiusLayer.clearLayers();
        // Restore route state if available
        if (route.lastSearch && route.start && route.end) {
          // Restore input values
          if (elements.routeStart && route.start.description) {
            elements.routeStart.value = route.start.description;
          }
          if (elements.routeEnd && route.end.description) {
            elements.routeEnd.value = route.end.description;
          }
          if (elements.routeMaxDistance && route.lastSearch.maxDistance) {
            elements.routeMaxDistance.value = route.lastSearch.maxDistance;
          }
          if (elements.routeUnits && route.lastSearch.units) {
            elements.routeUnits.value = route.lastSearch.units;
          }
          const currentFilters = getRouteFilterSignature();
          if (route.lastResult && isRouteCacheValid(route.lastResult, currentFilters, route.start, route.end)) {
            restoreRouteFromCache(route.lastResult, { preserveView: true });
            if (!applySavedMapView('route')) {
              if (route.lastResult.bounds && route.lastResult.bounds.isValid()) {
                map.fitBounds(route.lastResult.bounds.pad(0.15));
              } else if (route.lastResult.routeCoords && route.lastResult.routeCoords.length) {
                map.fitBounds(L.latLngBounds(route.lastResult.routeCoords), { padding: [50, 50] });
              }
            }
          } else {
            // Redraw the route
            findCollegesAlongRoute();
          }
        } else {
          // If no route state, show colleges based on current filters (type, region, state, search)
          // Clear only route visualization layers, keep markers showing filtered colleges
          routeLayer.clearLayers();
          render();
        }
      }
      
      // This section just opened, close all other sections
      filterSections.forEach(otherSection => {
        if (otherSection !== section && otherSection.open) {
          otherSection.open = false;
        }
      });
    }
  });
});

// Set initial active state for the default open section
const openSection = document.querySelector('.filter-section[open]');
if (openSection) {
  openSection.classList.add('active');
}

// Store the last user-selected state value to prevent autofill from changing it
let lastUserSelectedState = '';
let isUserChangingState = false;
let autofillWatchInterval = null;

// Prevent autofill from changing the state dropdown
if (elements.state) {
  // Store initial value
  lastUserSelectedState = elements.state.value;
  
  // Track when address field is being filled (autofill detection)
  if (elements.address) {
    // Store state value before address field changes
    elements.address.addEventListener('focus', () => {
      lastUserSelectedState = elements.state.value;
      // Start watching for autofill changes to state dropdown
      if (autofillWatchInterval) {
        clearInterval(autofillWatchInterval);
      }
      autofillWatchInterval = setInterval(() => {
        if (!isUserChangingState && elements.state.value !== lastUserSelectedState) {
          // State was changed by autofill - restore it immediately
          elements.state.value = lastUserSelectedState;
        }
      }, 50); // Check every 50ms during autofill window
    });
    
    // Handle browser autofill event (some browsers fire this)
    elements.address.addEventListener('change', () => {
      // Allow browser autofill to fill the address field (including state in the address text)
      // But prevent it from changing the state dropdown
      if (!isUserChangingState && elements.state.value !== lastUserSelectedState) {
        elements.state.value = lastUserSelectedState;
      }
    });
    
    // Stop watching when address field loses focus
    elements.address.addEventListener('blur', () => {
      if (autofillWatchInterval) {
        clearInterval(autofillWatchInterval);
        autofillWatchInterval = null;
      }
      // Final check and restore if needed
      if (!isUserChangingState && elements.state.value !== lastUserSelectedState) {
        elements.state.value = lastUserSelectedState;
      }
    });
    
    // Also stop watching after user finishes typing (debounced)
    let stopWatchTimeout = null;
    elements.address.addEventListener('input', () => {
      // Clear existing timeout
      if (stopWatchTimeout) {
        clearTimeout(stopWatchTimeout);
      }
      // Stop watching after 500ms of no input (autofill is usually instant)
      stopWatchTimeout = setTimeout(() => {
        if (autofillWatchInterval) {
          clearInterval(autofillWatchInterval);
          autofillWatchInterval = null;
        }
        // Final check and restore if needed
        if (!isUserChangingState && elements.state.value !== lastUserSelectedState) {
          elements.state.value = lastUserSelectedState;
        }
      }, 500);
    });
  }
  
  // Listen for user-initiated changes to state dropdown
  elements.state.addEventListener('mousedown', () => {
    isUserChangingState = true;
  });
  
  elements.state.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter' || e.key === ' ') {
      isUserChangingState = true;
    }
  });
  
  elements.state.addEventListener('change', function(e) {
    const currentValue = e.target.value;
    
    // If this change was initiated by user, update stored value
    if (isUserChangingState) {
      lastUserSelectedState = currentValue;
      isUserChangingState = false;
      
      // Continue with normal change handling
      if (activeMode === 'route' && route.lastSearch) {
        // Re-run route search with updated filters
        findCollegesAlongRoute();
      } else {
        render();
      }
    } else {
      // This change was NOT from user - likely autofill - restore previous value
      e.target.value = lastUserSelectedState;
      // Don't trigger render since this wasn't a real change
    }
  });
  
  // Reset flag after a short delay
  elements.state.addEventListener('blur', () => {
    setTimeout(() => {
      isUserChangingState = false;
    }, 200);
  });
}

['region', 'type', 'radius', 'units'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    if (activeMode === 'route' && route.lastSearch) {
      // Re-run route search with updated filters
      findCollegesAlongRoute();
    } else {
      render();
    }
  });
});

// Debounced search input - use event delegation to handle both desktop and mobile search fields
// Performance: Debounced to 300ms to avoid heavy re-renders on every keystroke
// Dropdown changes (Type, Region, State) are NOT debounced - they update immediately for better UX
document.querySelector('.controls').addEventListener('input', debounce((e) => {
  if (e.target.id === 'search' || e.target.id === 'search-mobile') {
    // Sync values between both search fields if they exist
    // Respect activeMode - only render in nearby mode, or re-run route search in route mode
    if (activeMode === 'route' && route.lastSearch) {
      findCollegesAlongRoute();
      return;
    }
    const desktopSearch = document.getElementById('search');
    const mobileSearch = document.getElementById('search-mobile');
    if (e.target.id === 'search' && mobileSearch) {
      mobileSearch.value = e.target.value;
    } else if (e.target.id === 'search-mobile' && desktopSearch) {
      desktopSearch.value = e.target.value;
    }
    render();
  }
}, 300));

// Check if running from file:// protocol (won't work due to CORS)
if (window.location.protocol === 'file:') {
  showError('Please use a web server to test this page. CSV files cannot load from file:// protocol. Use: python3 -m http.server 8000');
  console.error('Cannot load CSV from file:// protocol due to CORS restrictions');
} else {
loadCSV(DATA_URL);
}
</script>

<!-- Feedback Widget -->
<div class="feedback-button" id="feedbackButton">Feedback</div>
<div class="feedback-popup" id="feedbackPopup">
  <div class="feedback-popup-header">
    <div></div>
    <button class="feedback-popup-close" id="feedbackClose" aria-label="Close">√ó</button>
  </div>
  <div class="feedback-popup-message">We're improving U.S. College Map. Got 30 seconds to tell us what to fix next?</div>
  <div class="feedback-popup-button-wrapper">
    <a href="https://forms.gle/tGNzJr9THUYKfUPZ8" target="_blank" rel="noopener noreferrer" class="feedback-popup-button" style="text-decoration:none">Open feedback form</a>
  </div>
  <a href="#" class="feedback-popup-dismiss" id="feedbackDismiss">Don't show again</a>
</div>

<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E2KP0JHTMC"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-E2KP0JHTMC');
</script>

<script>
// Feedback Widget
(function() {
  'use strict';
  
  const feedbackButton = document.getElementById('feedbackButton');
  const feedbackPopup = document.getElementById('feedbackPopup');
  
  // Check if user has dismissed the feedback widget
  if (localStorage.getItem('uscm_feedback_dismissed') === 'true') {
    if (feedbackButton) feedbackButton.style.display = 'none';
    if (feedbackPopup) feedbackPopup.style.display = 'none';
    return; // Don't set up event listeners
  }
  
  const feedbackClose = document.getElementById('feedbackClose');
  const feedbackDismiss = document.getElementById('feedbackDismiss');
  
  // Open popup
  feedbackButton.addEventListener('click', function(e) {
    e.stopPropagation();
    feedbackPopup.classList.add('active');
  });
  
  // Close popup
  feedbackClose.addEventListener('click', function() {
    feedbackPopup.classList.remove('active');
  });
  
  // Dismiss permanently
  feedbackDismiss.addEventListener('click', function(e) {
    e.preventDefault();
    localStorage.setItem('uscm_feedback_dismissed', 'true');
    feedbackButton.classList.add('hidden');
    feedbackPopup.classList.remove('active');
  });
  
  // Close popup when clicking outside
  document.addEventListener('click', function(e) {
    if (feedbackPopup.classList.contains('active') && 
        !feedbackPopup.contains(e.target) && 
        !feedbackButton.contains(e.target)) {
      feedbackPopup.classList.remove('active');
    }
  });
})();
</script>

</body>
</html>
[elements.routeStartSuggestions, elements.routeEndSuggestions].forEach(container => {
    .ios-device input,
    .ios-device select,
    .ios-device textarea {
      font-size:16px !important;
    }
