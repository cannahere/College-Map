<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="google-site-verification" content="XLI_3QT03lSkcCEmteQWtQeDviYsA07lmIbGu_5GKCc" />
  <meta name="msvalidate.01" content="CA49DC12684491A5E489D6BA5BD08ED5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Branding and Icons -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="manifest" href="site.webmanifest">

  <!-- SEO Meta Tags -->
  <title>U.S. College Map | Find Colleges Near You & Along Any Route</title>
  <link rel="canonical" href="https://uscollegemap.org/">
  <meta name="description" content="Find schools by type, ranking or region on an interactive map, and discover colleges near you or along any route—ideal for early college search and campus visits. ">
  <meta name="keywords" content="US college map, college map, university map, interactive college map, colleges near me, colleges along route, college road trip, community colleges near me, colleges by location, community colleges by location, map of colleges, college visit map, campus visit planner, college trip planner, find colleges on a map, community college finder, campus visit planning, college map usa">
  <meta name="author" content="U.S. College Map">

  <!-- Open Graph (Social Media Preview) -->
  <meta property="og:title" content="U.S. College Map — Find Colleges Near You & Along Any Route">
  <meta property="og:description" content="Explore U.S. colleges on an interactive map. Find schools near you or along your route, filter by type or state, and save favorite colleges to your list for easy trip planning.">
  <meta property="og:image" content="https://uscollegemap.org/us-college-map-logo.png">
  <meta property="og:url" content="https://uscollegemap.org/">
  <meta property="og:type" content="website">
<meta property="og:site_name" content="U.S. College Map">

  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="U.S. College Map — Find Colleges Near You & Along Any Route">
  <meta name="twitter:description" content="Explore U.S. colleges on an interactive map. Find schools near you or along a route, filter by type or state, and save favorites for easy visit planning.">
  <meta name="twitter:image" content="https://uscollegemap.org/us-college-map-logo.png">

  <!-- Schema Markup (Structured Data) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "U.S. College Map",
    "url": "https://uscollegemap.org/",
    "description": "Explore U.S. colleges on an interactive map. Find schools near you or along a driving route, filter by type or state, and save favorite colleges to build your list for campus visit planning.",
    "applicationCategory": "Education",
    "operatingSystem": "All",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "creator": {
      "@type": "Organization",
      "name": "U.S. College Map"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "ratingCount": "150"
    },
    "featureList": [
      "Interactive map of all U.S. colleges",
      "Filter colleges by state, region, or school type",
      "Search by college name",
      "Find colleges near your location",
      "See colleges along any driving route",
      "Save favorite colleges to your personal list",
      "View only your saved schools on the map",
      "Plan early college visits efficiently"
    ]
  }
  </script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "url": "https://uscollegemap.org/",
    "name": "U.S. College Map",
    "alternateName": "US College Map",
    "description": "Interactive map of U.S. colleges where you can filter, search, save favorite schools, and explore colleges near you or along any route."
  }
  </script>
  
  <!-- BreadcrumbList Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [{
      "@type": "ListItem",
      "position": 1,
      "name": "Home",
      "item": "https://uscollegemap.org/"
    }]
  }
  </script>

  <!-- Resource Hints for Performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://nominatim.openstreetmap.org">

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body {margin:0;font-family:Inter,system-ui,sans-serif;background:#fff;color:#0f172a}
    .main-container {display:flex;flex-direction:column;min-height:100vh}
    .container {max-width:1100px;margin:0 auto;padding:16px}
    header.app-header {position:sticky;top:0;background:#fff;z-index:5000;border-bottom:1px solid #e2e8f0;box-shadow:0 10px 25px rgba(15,23,42,.08)}
    .shared-map-banner.active ~ .main-container header.app-header {top:auto}
    body:has(.shared-map-banner.active) header.app-header {top:auto}
    .app-header {display:flex;align-items:flex-start;justify-content:flex-start;padding:16px 40px;background:#fff;border-bottom:1px solid #e5e7eb;box-shadow:0 4px 10px rgba(0,0,0,0.05);transition:padding 0.25s ease, min-height 0.25s ease, box-shadow 0.25s ease}
    .header-logo-tagline {display:flex;flex-direction:column;align-items:flex-start;gap:0}
    .site-logo {height:64px;width:auto;object-fit:contain;transition:all 0.3s ease;margin-bottom:0;position: relative;z-index: 1}
    .tagline {font-family:Inter,sans-serif;font-size:14px;color:#6b7280;line-height:1.5;text-align:left;margin:0;margin-top:4px;margin-bottom:3px;margin-left:10px;font-weight:400;max-width:calc(100% - 10px)}
    .beta-badge {
      background: #2F80ED !important;
      color: white !important;
      font-size: 11px !important;
      padding: 2px 6px !important;
      border-radius: 6px !important;
      margin-left: 6px !important;
      font-weight: 600 !important;
      letter-spacing: 0.5px !important;
      display: inline-block !important;
      position: relative !important;
      z-index: 10000 !important;
      vertical-align: middle !important;
      line-height: 1 !important;
      visibility: visible !important;
      opacity: 1 !important;
      white-space: nowrap !important;
    }
    .sr-only {position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}
    @media (max-width:700px){
      .app-header{flex-direction:row;align-items:flex-start;text-align:left;padding:12px 16px;min-height:90px;}
      .app-header.collapsed{padding:6px 14px;min-height:64px;box-shadow:0 2px 6px rgba(15,23,42,0.12);}
      .header-logo-tagline{align-items:flex-start;text-align:left}
      .tagline{text-align:left;margin-left:0;max-width:100%;font-size:12px;color:#94A3B8;line-height:1.4;margin-top:4px;margin-bottom:6px;transition:opacity 0.25s ease,max-height 0.25s ease}
      .app-header.collapsed .tagline{opacity:0;max-height:0;margin:0;overflow:hidden}
      .site-logo{height:50px;width:auto;object-fit:contain;margin-bottom:0;transition:height 0.25s ease}
      .container{padding:6px;}
      .controls{padding:8px 8px;gap:2px;}
      /* Match live version exactly for type, region, state on mobile */
      .row-filters{flex-direction:row;gap:6px;flex-wrap:nowrap;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);min-width:0;padding:4px 6px;}
      .row-filters .pill label{display:none}
      .row-filters .pill select{width:100%;font-size:13px;padding:4px 8px;}
      .row-ranking .pill-ranking{padding:4px 6px;}
      .row-ranking .pill-ranking select{flex:1;margin-right:4px;width:100%;font-size:13px;padding:4px 8px;}
      .row-filters .pill-search{display:none !important}
      /* Ranking row - show on mobile only */
      .row-ranking{display:flex !important;gap:3px;justify-content:space-between;margin-bottom:3px;}
      .row-ranking .pill-ranking{flex:1 1 0;min-width:0;position:relative;display:flex !important;}
      .row-ranking .pill-ranking label{display:none !important;}
      /* Hide ranking in row-filters on mobile since it's now in row-ranking */
      .row-filters .pill-ranking{display:none !important;}
      .row-search{display:none !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .row-nearby .pill.address-autocomplete{flex:1 1 100%;}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:14px;}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:6px 10px;margin-left:4px;}
      .row-nearby .pill:not(.address-autocomplete){flex:1 1 100%;flex-direction:row;align-items:center;flex-wrap:wrap;padding:6px;}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:12px !important;font-weight:600;color:#475569;}
      .row-nearby #radius{width:70px;flex:0 0 auto;max-width:70px;}
      .row-nearby #units{width:70px;flex:0 0 auto;max-width:70px;}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:8px;}
      .pill{flex-direction:row;align-items:center;padding:6px;}
      .pill label{min-width:60px;margin-bottom:0;width:auto;font-size:11px;}
      .pill input,.pill select,.pill button{width:auto;flex:1;}
      .legend{position:relative;bottom:auto;left:auto;margin:6px;width:calc(100% - 12px);text-align:center;}
    }
    @media (max-width:399px){
      .row-filters{gap:6px;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);padding:4px 6px;}
      .row-filters .pill select{font-size:13px;padding:4px 8px;}
      .row-ranking .pill-ranking{padding:4px 6px;}
      .row-ranking .pill-ranking select{font-size:13px;padding:4px 8px;}
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .row-nearby{flex-direction:column;gap:6px}
      .row-nearby .pill.address-autocomplete{flex-direction:row;align-items:center;flex-wrap:wrap}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:11px !important;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:12px !important}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-nearby .pill:not(.address-autocomplete){flex-direction:row;align-items:center;flex-wrap:nowrap;gap:4px}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:11px !important;font-weight:600;color:#475569;flex-shrink:0}
      .row-nearby #radius{width:41px !important;flex:0 0 auto;max-width:41px;font-size:12px !important;padding:5px 4px !important}
      .row-nearby #units{width:41px !important;flex:0 0 auto;max-width:41px;font-size:12px !important;padding:5px 4px !important}
      .row-nearby #geocodeBtn{flex:0 0 auto;padding:5px 8px;font-size:12px !important;white-space:nowrap}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:5px 8px;margin-left:0;font-size:12px !important;white-space:nowrap}
      .row-route{flex-direction:column;gap:6px}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex-direction:row;align-items:center}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:40px !important;margin-bottom:0;width:auto;margin-right:5px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:12px !important}
      .row-route .pill:has(#routeMaxDistance){flex-direction:row;align-items:center;flex-wrap:nowrap}
      .row-route .pill:has(#routeMaxDistance) label{min-width:60px !important;margin-bottom:0;width:auto;margin-right:4px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:50px !important;flex:0 0 auto;max-width:50px;padding:4px 5px !important;font-size:12px !important}
      .row-route #routeUnits{width:48px !important;flex:0 0 auto;max-width:48px;font-size:12px !important;padding:4px 3px !important}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-route #clearRoute{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
    }
    @media (max-width:399px){
      .legend{position:relative;bottom:auto;left:auto;margin:6px;width:calc(100% - 12px);text-align:center;}
    }
    .controls {display:flex;flex-direction:column;gap:3px;padding:10px 12px 6px;border-top:1px solid #e5e7eb;background:#fff}
    .row {display:flex;gap:8px;justify-content:space-between}
    .row>.pill {flex:1}
    .row-filters{display:flex;gap:8px;justify-content:space-between}
    .row-filters .pill{flex:1 1 0;min-width:0;max-width:25%;}
    .row-filters .pill select,
    .row-ranking .pill-ranking select{width:100%;box-sizing:border-box;}
    .row-filters .pill-ranking{flex:1 1 0;min-width:0;max-width:25%;}
    .row-search{display:none}
    .row-filters .pill-search{display:none !important}
    /* Hide ranking row on desktop/tablet - only show on mobile (overridden in mobile media query) */
    .row-ranking{display:none;}
    @media (max-width:700px){
      .row-filters{gap:6px;justify-content:flex-start;flex-wrap:nowrap;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);max-width:none;}
    }
    @media (min-width:1025px) {
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .controls{flex-direction:row;flex-wrap:wrap;align-items:flex-start}
      .row-filters{flex:1 1 100%;margin-bottom:3px;gap:8px}
      .row-filters .pill:not(.pill-ranking){flex:1 1 0;min-width:0;max-width:23%;}
      .row-filters .pill-ranking{flex:1.2 1 0;min-width:0;max-width:31%;}
      .row-filters .pill-search{flex:1 1 auto;min-width:200px}
      .row-filters .pill-search input{font-size:14px}
      .row-filters .pill-ranking select{flex:1;margin-right:4px}
      .row-nearby{display:flex;flex-direction:row;gap:8px;flex-wrap:nowrap;margin-bottom:0;align-items:center}
      .row-nearby .pill.address-autocomplete{flex:1 1 auto;min-width:0}
      .row-nearby .pill.address-autocomplete label{min-width:60px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{font-size:14px}
      .row-nearby .pill.address-autocomplete button{font-size:14px}
      .row-nearby .pill:not(.address-autocomplete){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:60px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-nearby #radius{width:63px;flex:0 0 auto;font-size:14px}
      .row-nearby #units{width:62px;flex:0 0 auto;font-size:14px}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
      .row-route{display:flex;flex-direction:row;gap:8px;flex-wrap:nowrap;margin-bottom:0;align-items:center}
      .row-route .pill{flex:1 1 auto;min-width:0}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex:1 1 auto;min-width:0}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:45px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:14px}
      .row-route .pill:has(#routeMaxDistance){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-route .pill:has(#routeMaxDistance) label{min-width:75px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:70px;flex:0 0 auto;font-size:14px}
      .row-route #routeUnits{width:55px;flex:0 0 auto;font-size:14px}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
      .row-route #clearRoute{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
    }
    .pill {display:flex;align-items:center;gap:6px;background:#f1f5f9;border:1px solid #e2e8f0;padding:4px 8px;border-radius:12px;font-size:12px}
    .pill label {color:#475569;font-weight:600;font-size:12px;min-width:60px}
    .pill input,.pill select,.pill button {border:1px solid #e2e8f0;border-radius:10px;padding:6px 8px;background:#fff;color:#0f172a;font-size:14px;flex:1;transition:border-color 0.2s,box-shadow 0.2s}
    /* State dropdown divider */
    .pill select option.state-divider {
      background-color: #f3f4f6;
      color: #6b7280;
      font-weight: 500;
      font-size: 12px;
      padding: 8px;
      cursor: default;
    }
    .pill input:focus {outline:none;border-color:#4285f4;box-shadow:0 0 0 1px #4285f4}
    .pill button {background:#2563eb;color:#fff;border:none;font-weight:600;cursor:pointer;flex:0}
    @media (min-width:701px){
      .row-filters .pill label,
      .row-nearby .pill label,
      .row-route .pill label{font-size:14px}
      .row-filters .pill select,
      .row-filters .pill input,
      .row-nearby .pill input,
      .row-nearby .pill select,
      .row-route .pill input,
      .row-route .pill select{font-size:14px}
    }
    .pill-ranking {position:relative}
    .ranking-new-chat-bubble {display:block !important;position:fixed !important;background:#2563eb !important;color:#fff !important;padding:4px 8px !important;border-radius:8px !important;font-size:11px !important;font-weight:600 !important;white-space:nowrap !important;z-index:10001 !important;box-shadow:0 4px 12px rgba(37,99,235,0.3) !important;pointer-events:none !important;opacity:0;transform:translateY(4px);transition:opacity 0.3s ease,transform 0.3s ease;visibility:visible !important}
    .ranking-new-chat-bubble::after {content:'';position:absolute;top:100%;left:12px;border-width:6px 6px 0 6px;border-style:solid;border-color:#2563eb transparent transparent transparent}
    .ranking-new-chat-bubble.visible {opacity:1;transform:translateY(0)}
    .ranking-info-icon {width:18px !important;height:18px !important;min-width:18px !important;min-height:18px !important;max-width:18px !important;max-height:18px !important;border-radius:50% !important;background:#eff6ff !important;color:#2563eb !important;border:1px solid #3b82f6 !important;font-size:11px !important;font-weight:900 !important;-webkit-text-stroke:0.4px #2563eb !important;text-shadow:0 0 0.5px #2563eb !important;line-height:1 !important;padding:0 !important;margin:0 !important;display:inline-flex !important;align-items:center !important;justify-content:center !important;cursor:pointer !important;flex:0 0 18px !important;flex-shrink:0 !important;box-sizing:border-box !important;vertical-align:middle !important;transition:all 0.2s ease !important}
    .ranking-info-icon:hover {border-color:#2563eb !important;color:#1d4ed8 !important;background:#dbeafe !important;transform:scale(1.05) !important}
    .ranking-tooltip {position:absolute;top:calc(100% + 2px);right:0;margin-top:0;background:linear-gradient(180deg,rgba(255,249,219,0.98),rgba(255,243,191,0.98));padding:10px 12px;border-radius:12px;box-shadow:0 8px 18px rgba(15,23,42,0.18);font-size:0.75rem;max-width:260px;width:clamp(180px, calc(100vw - 32px), 260px);display:none;z-index:2000;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(234,179,8,0.5)}
    .ranking-tooltip.active {display:block;animation:fadeIn 0.2s ease-out}
    .ranking-tooltip::after {content:'';position:absolute;bottom:100%;right:9px;border-width:0 6px 6px 6px;border-style:solid;border-color:transparent transparent rgba(255,243,191,0.98) transparent;filter:drop-shadow(0 -2px 4px rgba(15,23,42,0.15))}
    .ranking-tooltip::before {content:'';position:absolute;bottom:calc(100% + 1px);right:8px;border-width:0 7px 7px 7px;border-style:solid;border-color:transparent transparent rgba(234,179,8,0.5) transparent}
    .ranking-tooltip-header {display:flex;align-items:flex-start;gap:8px;margin-bottom:0}
    .ranking-tooltip-close {position:absolute;top:8px;right:8px;background:none !important;border:none !important;color:#0f172a !important;font:inherit;font-size:14px;padding:0;line-height:1;cursor:pointer;box-shadow:none;appearance:none;width:auto;height:auto;min-width:0;min-height:0;border-radius:0;display:inline-block;flex:none}
    .ranking-tooltip-close:focus {outline:none;box-shadow:none}
    .ranking-tooltip-body {font-size:0.8125rem;line-height:1.5;color:#0f172a;padding-right:24px;flex:1}
    #map {height:calc(100vh - 280px);background:#e5e7eb;border-top:1px solid #e2e8f0;position:relative;min-height:500px}
    .legend {position:absolute;bottom:14px;left:14px;padding:0;border:none;font-size:11px;font-weight:500;color:#0f172a;text-shadow:none;z-index:1800;background:none;border-radius:0;line-height:1;text-align:left;transform:none}
    .map-hint-bubble {position:absolute;top:16px;left:16px;background:rgba(255,255,255,0.98);padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(15,23,42,0.18);font-size:0.75rem;max-width:260px;width:clamp(180px, calc(100vw - 32px), 260px);display:none;z-index:8500;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(226,232,240,0.8)}
    .map-hint-bubble.active {display:block;animation:fadeIn 0.2s ease-out}
    /* Teaching moment hint positioned near the toggle */
    #hint-saved-only-teaching {
      top: 60px;
      right: 12px;
      left: auto;
      max-width: 240px;
      width: clamp(200px, calc(100vw - 32px), 240px);
    }
    @media (max-width: 700px) {
      #hint-saved-only-teaching {
        top: 58px;
        right: 12px;
        left: 12px;
        width: calc(100vw - 24px);
        max-width: calc(100vw - 24px);
      }
    }
    .map-hint-bubble-header {display:flex;align-items:center;gap:8px;margin-bottom:6px}
    .map-hint-bubble-icon {font-size:16px;line-height:1;flex-shrink:0}
    .map-hint-bubble-close {background:none;border:none;color:#94a3b8;cursor:pointer;font-size:18px;line-height:1;padding:0;width:18px;height:18px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:color 0.2s;margin-left:auto;margin-top:-2px;margin-right:-4px}
    .map-hint-bubble-close:hover {color:#64748b}
    .map-hint-bubble-title {font-weight:600;font-size:0.875rem;line-height:1.4;color:#0f172a;flex:1}
    .map-hint-bubble-body {font-size:0.8125rem;line-height:1.5;color:#64748b}
    @media (max-width:700px) {
      .map-hint-bubble {top:16px;left:12px;right:12px;width:clamp(160px, calc(100vw - 24px), 260px);max-width:calc(100vw - 24px);box-sizing:border-box}
    }
    .map-tip-bubble {position:absolute;background:rgba(255,255,255,0.98);padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(15,23,42,0.18);font-size:0.8125rem;max-width:280px;width:clamp(200px, calc(100vw - 32px), 280px);display:none;z-index:2001;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(226,232,240,0.8)}
    .map-tip-bubble.active {display:block;animation:fadeIn 0.2s ease-out}
    .map-tip-bubble::after {content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border-width:6px 6px 0 6px;border-style:solid;border-color:rgba(255,255,255,0.98) transparent transparent transparent;filter:drop-shadow(0 2px 4px rgba(15,23,42,0.15))}
    .map-tip-bubble::before {content:'';position:absolute;top:calc(100% + 1px);left:calc(50% - 1px);transform:translateX(-50%);border-width:7px 7px 0 7px;border-style:solid;border-color:rgba(226,232,240,0.8) transparent transparent transparent}
    .map-tip-bubble-content {display:flex;align-items:center;gap:8px}
    .map-tip-bubble-icon {font-size:14px;line-height:1;flex-shrink:0}
    .map-tip-bubble-text {font-size:0.8125rem;line-height:1.4;color:#0f172a;flex:1}
    .map-tip-bubble-close {background:none;border:none;color:#94a3b8;cursor:pointer;font-size:16px;line-height:1;padding:0;width:16px;height:16px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:color 0.2s;margin-left:4px}
    .map-tip-bubble-close:hover {color:#64748b}
    /* Glowing effect for blue dot when tip bubble is shown */
    @keyframes blueDotGlow {
      0%, 100% {
        filter: drop-shadow(0 0 20px rgba(0, 255, 255, 1)) drop-shadow(0 0 35px rgba(0, 255, 255, 0.9)) drop-shadow(0 0 50px rgba(0, 255, 255, 0.8)) drop-shadow(0 0 70px rgba(0, 255, 255, 0.6));
        opacity: 1;
      }
      50% {
        filter: drop-shadow(0 0 30px rgba(0, 255, 255, 1)) drop-shadow(0 0 50px rgba(0, 255, 255, 1)) drop-shadow(0 0 70px rgba(0, 255, 255, 0.9)) drop-shadow(0 0 100px rgba(0, 255, 255, 0.7));
        opacity: 1;
      }
    }
    .blue-dot-glow {
      animation: blueDotGlow 1s ease-in-out infinite;
      z-index: 2000 !important;
    }
    /* Pulsing ring around the glowing dot */
    .blue-dot-glow-ring {
      position: absolute;
      border-radius: 50%;
      border: 3px solid rgba(0, 255, 255, 0.6);
      pointer-events: none;
      z-index: 1999;
      animation: pulseRing 1s ease-in-out infinite;
    }
    @keyframes pulseRing {
      0% {
        transform: scale(1);
        opacity: 0.6;
        border-width: 3px;
      }
      50% {
        transform: scale(2.5);
        opacity: 0.25;
        border-width: 2px;
      }
      100% {
        transform: scale(3);
        opacity: 0;
        border-width: 1px;
      }
    }
    @media (max-width:700px) {
      .map-tip-bubble {max-width:calc(100vw - 24px);width:clamp(180px, calc(100vw - 24px), 280px);font-size:0.75rem;padding:8px 10px;box-sizing:border-box}
      .map-tip-bubble-icon {font-size:12px}
    }
    .leaflet-tooltip {background:#fff;color:#0f172a;border:1px solid #e2e8f0;border-radius:6px;font-size:12px;font-weight:500;padding:4px 8px;box-shadow:0 2px 6px rgba(0,0,0,.1)}
    /* Override Leaflet's default orange tap highlight on mobile/iPad - match desktop (white/no highlight) */
    .leaflet-interactive:active,
    .leaflet-interactive:focus,
    .leaflet-interactive.leaflet-touch-active {
      outline: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    /* Remove orange tap highlight and use white styling (matching desktop behavior) */
    /* Target both SVG circle elements and path elements used by Leaflet circleMarker */
    .leaflet-interactive.leaflet-touch-active circle,
    .leaflet-interactive:active circle,
    .leaflet-interactive:focus circle,
    .leaflet-interactive.leaflet-touch-active path,
    .leaflet-interactive:active path,
    .leaflet-interactive:focus path {
      /* Use white stroke instead of orange (matching desktop tap behavior) */
      stroke: #ffffff !important;
      stroke-width: 2 !important;
      /* Keep original blue fill */
      fill: #2563eb !important;
      fill-opacity: 0.7 !important;
      /* Remove any orange filter or effects */
      filter: none !important;
    }
    .route-hint-bubble {position:fixed;background:linear-gradient(180deg,rgba(255,249,219,0.98),rgba(255,243,191,0.98));padding:8px 12px;border-radius:12px;box-shadow:0 8px 18px rgba(15,23,42,0.18);font-size:12px;max-width:210px;display:none;z-index:6500;border:1px solid rgba(234,179,8,0.5);pointer-events:auto;opacity:0;transform:translateY(6px);transition:opacity 0.2s ease,transform 0.2s ease}
    .route-hint-bubble.visible {opacity:1;transform:translateY(0)}
    .route-hint-bubble-content {display:flex;align-items:center;font-weight:500;color:#0f172a}
    .route-hint-bubble::after {content:'';position:absolute;bottom:-8px;left:50%;transform:translateX(-50%);border-width:8px 8px 0 8px;border-style:solid;border-color:rgba(255,243,191,0.98) transparent transparent transparent;filter:drop-shadow(0 2px 4px rgba(15,23,42,0.15))}
    .route-hint-bubble::before {content:'';position:absolute;bottom:-9px;left:50%;transform:translateX(-50%);border-width:9px 9px 0 9px;border-style:solid;border-color:rgba(234,179,8,0.5) transparent transparent transparent}
    .route-hint-bubble.below::after {top:-8px;bottom:auto;border-width:0 8px 8px 8px;border-color:transparent transparent rgba(255,243,191,0.98) transparent}
    .route-hint-bubble.below::before {top:-9px;bottom:auto;border-width:0 9px 9px 9px;border-color:transparent transparent rgba(234,179,8,0.5) transparent}
    .route-hint-bubble-text {line-height:1.3;display:block;white-space:nowrap}
    .loading {display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;padding:20px;border-radius:12px;box-shadow:0 10px 25px rgba(15,23,42,.15);z-index:1000}
    .loading.active {display:block}
    .error {display:none;background:#fee;color:#c33;padding:12px;border-radius:8px;margin:12px;border:1px solid #fcc}
    .error.active {display:block}
    .site-footer {background:#fff;border-top:1px solid #e2e8f0;padding:10px 16px;font-size:12px;color:#94A3B8;text-align:center}
    .site-footer a {color:#2563eb;text-decoration:none;transition:color 0.2s}
    .site-footer a:hover {color:#1d4ed8;text-decoration:underline}
    .feedback-button {position:fixed;bottom:18px;right:18px;background:#2563eb;color:#fff;border:none;padding:10px 16px;border-radius:8px;font-family:Inter,sans-serif;font-size:14px;font-weight:500;cursor:pointer;box-shadow:0 4px 12px rgba(37,99,235,0.3);z-index:1000;transition:all 0.2s ease}
    .feedback-button:hover {background:#1d4ed8;box-shadow:0 6px 16px rgba(37,99,235,0.4);transform:translateY(-2px)}
    .feedback-button.hidden {display:none}
    .feedback-popup {position:fixed;bottom:70px;right:18px;width:280px;background:#fff;border-radius:12px;box-shadow:0 10px 25px rgba(15,23,42,.15);border:1px solid #e2e8f0;z-index:1001;padding:20px;display:none;animation:fadeIn 0.2s ease-out}
    .feedback-popup.active {display:block}
    .feedback-popup-header {display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px;margin-top:-2px}
    .feedback-popup-close {background:none;border:none;font-size:24px;color:#94a3b8;cursor:pointer;line-height:1;padding:0;width:24px;height:24px;display:flex;align-items:center;justify-content:center;transition:color 0.2s}
    .feedback-popup-close:hover {color:#64748b}
    .feedback-popup-message {font-size:14px;color:#0f172a;line-height:1.5;margin-bottom:16px}
    .feedback-popup-button {display:inline-block;background:#2563eb;color:#fff;border:none;padding:10px 28px;border-radius:8px;font-family:Inter,sans-serif;font-size:14px;font-weight:500;cursor:pointer;transition:background 0.2s}
    .feedback-popup-button-wrapper {text-align:center;margin-bottom:12px}
    .feedback-popup-button:hover {background:#1d4ed8}
    .feedback-popup-dismiss {display:block;text-align:center;font-size:12px;color:#94a3b8;text-decoration:none;cursor:pointer;transition:color 0.2s}
    .feedback-popup-dismiss:hover {color:#64748b}
    @media (max-width:700px){
      .feedback-popup {width:calc(100% - 36px);max-width:280px;right:18px;left:auto}
    }
    .radius-circle {stroke:#2563eb;stroke-width:2;stroke-dasharray:5,5;fill:none;opacity:0.5;pointer-events:none}
    .address-autocomplete {position:relative;z-index:10;isolation:isolate}
    .address-autocomplete.autocomplete-active {z-index:8500}
    .autocomplete-suggestions {display:none;position:absolute;top:calc(100% + 4px);left:0;right:0;background:#fff;border:none;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.1),0 8px 24px rgba(0,0,0,0.12);max-height:400px;overflow-y:auto;overflow-x:hidden;z-index:8500;margin-top:0;pointer-events:auto;transform:translateZ(0);will-change:transform}
    .autocomplete-suggestions.active {display:block;animation:fadeIn 0.15s ease-out}
    @keyframes fadeIn {from{opacity:0;transform:translateY(-4px)} to{opacity:1;transform:translateY(0)}}
    .autocomplete-item {padding:0;cursor:pointer;border-bottom:none;font-size:14px;transition:background-color 0.1s;min-height:48px;display:flex;flex-direction:row;align-items:center;position:relative;width:100%;pointer-events:auto;user-select:none;-webkit-user-select:none}
    .autocomplete-item:not(:last-child)::after {content:'';position:absolute;bottom:0;left:56px;right:0;height:1px;background:#f1f5f9}
    .autocomplete-item:hover,.autocomplete-item.highlighted {background-color:#f8f9fa}
    .autocomplete-item:focus {outline:2px solid #4285f4;outline-offset:-2px;background-color:#f8f9fa}
    .autocomplete-item-icon {width:40px;height:40px;display:flex;align-items:center;justify-content:center;flex-shrink:0;margin-left:8px}
    .autocomplete-item-icon svg {width:20px;height:20px;fill:#5f6368;display:block}
    .autocomplete-item.highlighted .autocomplete-item-icon svg,.autocomplete-item:hover .autocomplete-item-icon svg {fill:#4285f4}
    .autocomplete-item-content {flex:1;padding:12px 8px 12px 0;min-width:0;display:flex;flex-direction:column;justify-content:center}
    .autocomplete-item .address-name {font-weight:400;color:#202124;margin-bottom:2px;font-size:15px;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .autocomplete-item .address-name strong {font-weight:500;color:#202124}
    .autocomplete-item.highlighted .address-name,.autocomplete-item:hover .address-name {color:#1a73e8}
    .autocomplete-item.highlighted .address-name strong,.autocomplete-item:hover .address-name strong {color:#1a73e8;font-weight:500}
    .autocomplete-item .address-details {font-size:13px;color:#5f6368;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .autocomplete-loading {padding:16px;text-align:center;color:#5f6368;font-size:14px;display:flex;align-items:center;justify-content:center;gap:8px}
    .autocomplete-loading::before {content:'';width:16px;height:16px;border:2px solid #e0e0e0;border-top-color:#4285f4;border-radius:50%;animation:spin 0.8s linear infinite}
    @keyframes spin {to{transform:rotate(360deg)}}
    .autocomplete-empty {padding:24px;text-align:center;color:#5f6368;font-size:14px}
    .autocomplete-section-title{padding:10px 16px;font-size:12px;letter-spacing:0.08em;text-transform:uppercase;color:#94a3b8;font-weight:600}
    .autocomplete-divider{height:1px;background:#e2e8f0;margin:4px 0}
    @media (max-width: 700px) {
      .autocomplete-item {min-height:52px}
      .autocomplete-item-icon {width:44px;height:44px;margin-left:12px}
      .autocomplete-item-content {padding:14px 12px 14px 0}
      .row-nearby{flex-direction:column;gap:6px}
      .row-nearby .pill.address-autocomplete{flex-direction:row;align-items:center;flex-wrap:wrap}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:11px !important;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:12px !important}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-nearby .pill:not(.address-autocomplete){flex-direction:row;align-items:center;flex-wrap:nowrap;gap:4px}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:11px !important;font-weight:600;color:#475569;flex-shrink:0}
      .row-nearby #radius{width:41px !important;flex:0 0 auto;max-width:41px;font-size:12px !important;padding:5px 4px !important}
      .row-nearby #units{width:41px !important;flex:0 0 auto;max-width:41px;font-size:12px !important;padding:5px 4px !important}
      .row-nearby #geocodeBtn{flex:0 0 auto;padding:5px 8px;font-size:12px !important;white-space:nowrap}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:5px 8px;margin-left:0;font-size:12px !important;white-space:nowrap}
      .row-route{flex-direction:column;gap:6px}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex-direction:row;align-items:center}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:40px !important;margin-bottom:0;width:auto;margin-right:5px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:12px !important}
      .row-route .pill:has(#routeMaxDistance){flex-direction:row;align-items:center;flex-wrap:nowrap}
      .row-route .pill:has(#routeMaxDistance) label{min-width:60px !important;margin-bottom:0;width:auto;margin-right:4px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:50px !important;flex:0 0 auto;max-width:50px;padding:4px 5px !important;font-size:12px !important}
      .row-route #routeUnits{width:48px !important;flex:0 0 auto;max-width:48px;font-size:12px !important;padding:4px 3px !important}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-route #clearRoute{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
    }
    @media (max-width: 700px) {
      html.ios-device .row-nearby #units {
        width:70px !important;
        max-width:70px !important;
      }
      html.ios-device .row-route .pill:has(#routeStart) label,
      html.ios-device .row-route .pill:has(#routeEnd) label,
      html.ios-device .row-route .pill:has(#routeMaxDistance) label {
        font-size:16px !important;
      }
    }
    @media (max-width: 480px) {
      .container{padding:4px;}
      .controls{padding:8px 4px;}
      .row{gap:6px;}
      .pill{padding:8px;}
    }
    @media (min-width: 701px) and (max-width: 1024px) {
      .row-filters{flex-direction:row;gap:6px;flex-wrap:nowrap;}
      .row-filters .pill:not(.pill-ranking){flex:1 1 0;min-width:0;max-width:23%;}
      .row-filters .pill-ranking{flex:1.2 1 0;min-width:0;max-width:31%;}
      .row-filters .pill label{display:none}
      .row-filters .pill select{width:100%;font-size:14px;padding:6px 8px;}
      .row-filters .pill-ranking select{flex:1;margin-right:4px;font-size:14px;}
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .controls{flex-direction:row;flex-wrap:wrap;align-items:flex-start}
      .row-filters{flex:1 1 100%;margin-bottom:3px}
      .row-search{flex:1 1 100%;margin-bottom:3px}
      .row-nearby{display:flex;flex-direction:row;gap:6px;flex-wrap:nowrap;margin-bottom:0}
      .row-nearby .pill.address-autocomplete{flex:1 1 auto;min-width:0}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:14px;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:14px}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:6px 10px;margin-left:4px;font-size:14px}
      .row-nearby .pill:not(.address-autocomplete){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-nearby #radius{width:57px;flex:0 0 auto;max-width:57px;font-size:14px}
      .row-nearby #units{width:58px;flex:0 0 auto;max-width:58px;font-size:14px}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:14px}
      .row-route{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:0}
      .row-route .pill:first-child,.row-route .pill:nth-child(2){width:100%;box-sizing:border-box;padding:4px 6px}
      .row-route .pill:first-child label,.row-route .pill:nth-child(2) label{min-width:40px;max-width:40px;margin-bottom:0;width:40px;margin-right:5px;font-size:14px;font-weight:600;color:#475569;flex-shrink:0}
      .row-route .pill:first-child input,.row-route .pill:nth-child(2) input{min-width:0;flex:1 1 0;padding:5px 6px;font-size:14px;box-sizing:border-box}
      .row-route .pill:last-child{grid-column:1 / -1;flex-direction:row;align-items:center;margin-top:0;padding:4px 6px}
      .row-route .pill:last-child label{min-width:70px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:65px;flex:0 0 auto;max-width:65px;padding:5px 6px;font-size:14px}
      .row-route #routeUnits{width:50px;flex:0 0 auto;max-width:50px;padding:5px 4px;font-size:14px}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .row-route #clearRoute{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .filter-section {margin-top:3px}
      .filter-section summary {padding:8px 10px;font-size:13px}
      .filter-section-content {padding:0 10px 8px}
    }
    .filter-section {background:#f8fafc;border-radius:12px;border:1px solid #e2e8f0;margin-top:4px;overflow:visible;width:100%;flex:1 1 100%;position:relative;transition:box-shadow 0.2s ease}
    .filter-section-content {overflow:visible}
    .filter-section summary {font-weight:600;color:#0f172a;font-size:14px;padding:8px 12px;cursor:pointer;list-style:none;user-select:none;display:flex;align-items:center;gap:8px}
    .filter-section summary::-webkit-details-marker {display:none}
    .filter-section summary::before {content:'▶';font-size:10px;transition:transform 0.2s;display:inline-block}
    .filter-section[open] summary::before {transform:rotate(90deg)}
    .filter-section summary:hover {background:#f1f5f9}
    .filter-section-content {padding:0 12px 8px;display:flex;flex-direction:column;gap:3px}
    .filter-section.active {box-shadow:0 4px 12px rgba(37,99,235,0.15),0 2px 4px rgba(0,0,0,0.1);border-left:4px solid #2563eb}
    .filter-section.active summary {background:#f0f7ff}
    .about-map {max-width:1100px;margin:16px auto 24px;font-size:13px;color:#475569;background:#f8fafc;border-radius:12px;padding:10px 16px 14px;border:1px solid #e2e8f0}
    .about-map-title {font-weight:600;color:#0f172a;font-size:15px;margin:0 0 12px 0;text-align:center;padding-bottom:12px;border-bottom:2px solid #fff}
    .about-map-video {margin:16px 0 20px 0;max-width:100%}
    .about-map-video-wrapper {position:relative;padding-bottom:56.25%;height:0;overflow:hidden;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.1)}
    .about-map-video-wrapper iframe {position:absolute;top:0;left:0;width:100%;height:100%;border:0}
    .info-snippets {display:grid;grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));gap:14px;padding-top:8px}
    .snippet h2 {font-size:14px;font-weight:600;margin-bottom:4px;color:#1e293b;display:flex;align-items:center;gap:4px}
    .snippet h2 .star-icon {font-size:0.85em;line-height:1;display:inline-flex;align-items:center;margin-top:0}
    .snippet p {font-size:13px;color:#64748b;line-height:1.5}
    .site-disclaimer {max-width:1100px;margin:0 auto 24px;font-size:10px;line-height:1.5;color:#475569;padding:0 16px;text-align:left}
    @media (max-width:700px) {
      .info-snippets {grid-template-columns:1fr}
      .filter-section {margin-top:3px}
      .filter-section summary {padding:10px 12px;font-size:13px}
      .filter-section-content {padding:0 12px 10px}
    }
    @media (max-width:768px) {
      html.ios-device .row-search .pill,
      html.ios-device .row-search .pill input,
      html.ios-device .row-search .pill button,
      html.ios-device .row-nearby,
      html.ios-device .row-nearby .pill,
      html.ios-device .row-nearby .pill input,
      html.ios-device .row-nearby .pill select,
      html.ios-device .row-nearby .pill button,
      html.ios-device .row-route,
      html.ios-device .row-route .pill,
      html.ios-device .row-route .pill label,
      html.ios-device .row-route .pill input,
      html.ios-device .row-route .pill select,
      html.ios-device .row-route .pill button,
      html.ios-device #radius,
      html.ios-device #units,
      html.ios-device #geocodeBtn,
      html.ios-device #clearRadius,
      html.ios-device #routeMaxDistance,
      html.ios-device #routeUnits,
      html.ios-device #findRouteBtn,
      html.ios-device #clearRoute,
      html.ios-device details.filter-section summary {
        font-size:16px !important;
      }
      html.ios-device .row-route .pill input::placeholder,
      html.ios-device .row-nearby .pill input::placeholder {
        font-size:16px !important;
      }
      html.ios-device label[for="type"],
      html.ios-device label[for="region"],
      html.ios-device label[for="state"],
      html.ios-device #type,
      html.ios-device #region,
      html.ios-device #state {
        font-size:16px !important;
      }
    }
    html.ios-device .row-search .pill label,
    html.ios-device .row-nearby .pill label,
    html.ios-device .row-route .pill label,
    html.ios-device .row-filters .pill-search label {
      font-size:16px !important;
    }
    html.ios-device .row-route .pill label {
      font-size:16px !important;
    }
    /* Force 16px inputs on iOS — MUST BE AT BOTTOM OF FILE */
    html.ios-device input,
    html.ios-device textarea,
    html.ios-device select {
      font-size:16px !important;
    }
      /* iOS mobile: 16px for filter dropdowns */
      @media (max-width:700px) {
        html.ios-device .row-filters .pill select,
        html.ios-device .row-ranking .pill-ranking select,
        html.ios-device #type,
        html.ios-device #region,
        html.ios-device #state,
        html.ios-device #ranking {
          font-size:16px !important;
        }
        /* Make ranking dropdown full width on iOS mobile */
        html.ios-device .row-ranking .pill-ranking select {
          width: 100% !important;
          flex: 1 1 100% !important;
          margin-right: 0 !important;
        }
      }
      @media (min-width:701px) and (max-width:1024px) {
        html.ios-device .row-filters .pill select,
        html.ios-device .row-ranking .pill-ranking select,
        html.ios-device #type,
        html.ios-device #region,
        html.ios-device #state,
        html.ios-device #ranking {
          font-size:16px !important;
        }
      }
    /* iOS: keep route inputs at 16px so Safari doesn't zoom */
    html.ios-device #routeStart,
    html.ios-device #routeEnd {
      font-size: 16px !important;
    }
    html.ios-device .row-route .pill input,
    html.ios-device .row-nearby .pill input {
      font-size:16px !important;
    }
    @media (max-width:768px) {
      /* iOS-only: fix Safari zoom issue */
      html.ios-device .row-route .pill:has(#routeStart) input,
      html.ios-device .row-route .pill:has(#routeEnd) input {
        font-size: 16px !important;
      }
    }
    /* Popup save button styling */
    .popup-save-row {
      display: flex;
      justify-content: flex-end;
      margin-top: 8px;
      padding-top: 4px;
    }
    .popup-save-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      font-weight: 500;
      font-family: Inter, sans-serif;
      color: #64748b;
      background: #f1f5f9;
      border: 1px solid #e2e8f0;
      border-radius: 9999px;
      padding: 4px 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      line-height: 1.4;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .popup-save-btn .popup-save-label {
      min-width: 40px;
      text-align: center;
      display: inline-block;
    }
    .popup-save-btn:hover {
      background: #e2e8f0;
      color: #475569;
    }
    .popup-save-btn .popup-save-icon {
      font-size: 12px;
      line-height: 1;
      color: #64748b;
    }
    .popup-save-btn.saved {
      color: #15803d;
      background: #dcfce7;
      border-color: #86efac;
    }
    .popup-save-btn.saved .popup-save-icon {
      color: #16a34a;
    }
    .popup-save-btn.saved:hover {
      background: #bbf7d0;
      color: #15803d;
    }
    /* Celebration animation when college is saved */
    @keyframes savedPop {
      0% {
        transform: scale(1);
        background: #dcfce7;
      }
      50% {
        transform: scale(1.06);
        background: #bbf7d0;
      }
      100% {
        transform: scale(1);
        background: #dcfce7;
      }
    }
    .popup-save-btn.saved-pop {
      animation: savedPop 200ms ease-out;
    }
    /* Animation for marker transition from blue dot to green icon - balloon grow effect */
    .marker-save-transition {
      animation: markerSaveTransition 500ms cubic-bezier(0.34, 1.56, 0.64, 1) forwards !important;
      transform-origin: center bottom !important;
    }
    .marker-save-transition img {
      animation: markerSaveTransition 500ms cubic-bezier(0.34, 1.56, 0.64, 1) forwards !important;
      transform-origin: center bottom !important;
    }
    @keyframes markerSaveTransition {
      0% {
        opacity: 0 !important;
        transform: scale(0) !important;
      }
      60% {
        opacity: 1 !important;
        transform: scale(1.2) !important;
      }
      100% {
        opacity: 1 !important;
        transform: scale(1) !important;
      }
    }
    /* Ensure Leaflet popups appear above everything, including header and logo */
    .leaflet-popup-pane {
      z-index: 10000 !important;
    }
    .leaflet-popup {
      z-index: 10000 !important;
    }
    /* Saved controls overlay */
    .saved-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #E5E7EB;
      border-radius: 9999px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      height: 38px;
      padding: 0 6px;
      z-index: 8000;
      font-family: Inter, sans-serif;
      font-weight: 500;
      color: #374151;
      font-size: 12px;
      pointer-events: auto;
      gap: 4px;
    }
    /* Lower z-index for saved-controls when overlay is active so pill appears behind overlay */
    body:has(.route-planner-overlay.active) .saved-controls {
      z-index: 1;
    }
    body:has(.saved-colleges-overlay.active) .saved-controls {
      z-index: 2500;
    }
    .saved-list-section,
    .saved-only-section {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 0 4px;
      cursor: pointer;
      transition: opacity 0.2s, color 0.2s, padding-right 0.15s ease;
      user-select: none;
      position: relative;
    }
    .saved-only-section.saved-only-active {
      padding-right: 36px;
    }
    /* Expand pill when navigation icon is visible */
    .saved-only-section.saved-only-active:has(.saved-navigation-icon.visible) {
      padding-right: 64px;
    }
    .saved-only-main {
      display: flex;
      align-items: center;
      gap: 5px;
      transition: transform 0.15s ease;
    }
    .saved-only-section.saved-only-active .saved-only-main {
      transform: translateX(-2px);
    }
    .saved-only-divider {
      position: absolute;
      right: 30px; /* Default position: between "Map Saved Only" and share icon (when navigation icon is hidden) */
      width: 1px;
      height: 20px;
      background: #E5E7EB;
      opacity: 0;
      pointer-events: none;
      flex-shrink: 0;
      transition: opacity 0.15s ease, right 0.15s ease;
    }
    .saved-only-section.saved-only-active .saved-only-divider {
      opacity: 1;
    }
    /* Adjust divider position when navigation icon is visible - move it to the left of navigation icon */
    .saved-only-section.saved-only-active:has(.saved-navigation-icon.visible) .saved-only-divider {
      right: 59px;
    }
    .saved-navigation-icon {
      position: absolute;
      right: 28px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transform: translateX(8px);
      transition: opacity 0.15s ease, transform 0.15s ease, right 0.15s ease;
      pointer-events: none;
      cursor: pointer;
      flex-shrink: 0;
      z-index: 1;
    }
    /* Show navigation icon when visible class is added AND saved-only section is active */
    /* Position navigation icon at right: 28px when visible */
    .saved-only-section.saved-only-active .saved-navigation-icon.visible {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
      right: 28px;
    }
    .saved-navigation-icon svg {
      width: 18px;
      height: 18px;
      stroke: #1d4ed8;
      stroke-width: 2;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.2s;
    }
    .saved-navigation-tooltip {
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      background: linear-gradient(180deg, rgba(255, 249, 219, 0.98), rgba(255, 243, 191, 0.98));
      color: #0f172a;
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
      border: 1px solid rgba(234, 179, 8, 0.5);
      font-size: 0.75rem;
      font-family: Inter, sans-serif;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      transform: translateY(-4px);
      z-index: 7000 !important;
      display: none;
    }
    .saved-navigation-icon:hover .saved-navigation-tooltip {
      opacity: 1;
      transform: translateY(0);
      display: block;
    }
    .saved-navigation-tooltip::after {
      content: '';
      position: absolute;
      top: -6px;
      right: 10px;
      border-width: 0 6px 6px 6px;
      border-style: solid;
      border-color: transparent transparent rgba(255, 243, 191, 0.98) transparent;
      filter: drop-shadow(0 2px 4px rgba(15, 23, 42, 0.15));
    }
    .saved-navigation-tooltip::before {
      content: '';
      position: absolute;
      top: -7px;
      right: 9px;
      border-width: 0 7px 7px 7px;
      border-style: solid;
      border-color: transparent transparent rgba(234, 179, 8, 0.5) transparent;
    }
    .saved-share-icon {
      position: absolute;
      right: 4px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transform: translateX(8px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      pointer-events: none;
      cursor: pointer;
      flex-shrink: 0;
    }
    .saved-only-section.saved-only-active .saved-share-icon {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }
    .saved-share-icon svg {
      width: 18px;
      height: 18px;
      stroke: #1d4ed8;
      stroke-width: 2;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.2s;
    }
    .saved-share-tooltip {
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      background: linear-gradient(180deg, rgba(255, 249, 219, 0.98), rgba(255, 243, 191, 0.98));
      color: #0f172a;
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
      border: 1px solid rgba(234, 179, 8, 0.5);
      font-size: 0.75rem;
      font-family: Inter, sans-serif;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      transform: translateY(-4px);
      z-index: 7000 !important;
      display: none;
    }
    .saved-share-icon:hover .saved-share-tooltip {
      opacity: 1;
      transform: translateY(0);
    }
    .saved-share-tooltip::after {
      content: '';
      position: absolute;
      top: -6px;
      right: 10px;
      border-width: 0 6px 6px 6px;
      border-style: solid;
      border-color: transparent transparent rgba(255, 243, 191, 0.98) transparent;
      filter: drop-shadow(0 2px 4px rgba(15, 23, 42, 0.15));
    }
    .saved-share-tooltip::before {
      content: '';
      position: absolute;
      top: -7px;
      right: 9px;
      border-width: 0 7px 7px 7px;
      border-style: solid;
      border-color: transparent transparent rgba(234, 179, 8, 0.5) transparent;
    }
    /* Tooltip and hover effects only on desktop (hover-capable devices) */
    @media (hover: hover) and (pointer: fine) {
      .saved-navigation-icon:hover svg {
        stroke: #1e40af;
      }
      .saved-navigation-tooltip {
        display: block;
      }
      .saved-navigation-icon:hover .saved-navigation-tooltip {
        opacity: 1;
        transform: translateY(0);
      }
      .saved-share-icon:hover svg {
        stroke: #1e40af;
      }
      .saved-share-tooltip {
        display: block;
      }
      .saved-share-icon:hover .saved-share-tooltip:not(.tooltip-hidden) {
        opacity: 1;
      }
      .saved-share-tooltip.tooltip-hidden {
        opacity: 0 !important;
        pointer-events: none !important;
      }
    }
    /* On mobile/tablet (touch devices), hide tooltip completely and ensure tap works */
    @media (hover: none) or (pointer: coarse) {
      .saved-share-tooltip {
        display: none !important;
      }
    }
    /* Toast notification */
    .toast {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, calc(-50% + 40px));
      background: #fff;
      color: #0f172a;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
      border: 1px solid #e2e8f0;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 200px;
      max-width: 90vw;
      opacity: 0;
      pointer-events: none;
      z-index: 10000;
      font-size: 14px;
      line-height: 1.4;
      transition: opacity 0.3s ease, transform 0.3s ease;
      font-family: Inter, sans-serif;
    }
    .toast.active {
      opacity: 1;
      transform: translate(-50%, -50%);
      pointer-events: auto;
    }
    .toast-message {
      flex: 1;
      white-space: normal;
      word-wrap: break-word;
      text-align: center;
    }
    @media (min-width: 600px) {
      .toast {
        max-width: 400px;
        width: auto;
      }
    }
    /* Shared map banner */
    .shared-map-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #fef3c7;
      border-bottom: 2px solid #fbbf24;
      padding: 12px 16px;
      display: none;
      align-items: center;
      justify-content: space-between;
      z-index: 10000;
      font-size: 14px;
      color: #dc2626;
      font-weight: 700;
      font-family: Inter, sans-serif;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .shared-map-banner.active {
      display: flex;
    }
    .shared-map-banner-message {
      flex: 1;
      line-height: 1.4;
      font-weight: 700;
      color: #dc2626;
    }
    .shared-map-banner-close {
      background: none;
      border: none;
      color: #dc2626;
      cursor: pointer;
      font-size: 20px;
      line-height: 1;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 12px;
      flex-shrink: 0;
      transition: color 0.2s;
      font-weight: 700;
    }
    .shared-map-banner-close:hover {
      color: #b91c1c;
      background: rgba(220, 38, 38, 0.1);
      border-radius: 4px;
    }
    @media (max-width: 700px) {
      .shared-map-banner {
        padding: 10px 12px;
        font-size: 13px;
      }
      .shared-map-banner-message {
        font-size: 13px;
      }
    }
    .saved-list-section {
      color: #1d4ed8;
      text-decoration: none;
      gap: 6px;
    }
    .saved-pill {
      display: inline-flex;
      align-items: center;
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      border-radius: 9999px;
      padding: 3px 10px;
      box-shadow: 0 6px 16px rgba(37, 99, 235, 0.12);
      transition: background 0.2s, border-color 0.2s, color 0.2s;
      font-weight: 600;
    }
    .saved-list-section:hover .saved-pill {
      color: #1e40af;
      background: #e0e7ff;
      border-color: #a5b4fc;
    }
    .saved-list-section:focus-visible .saved-pill {
      outline: 2px solid #1d4ed8;
      outline-offset: 2px;
    }
    .saved-icon {
      width: 22px;
      height: 22px;
      flex-shrink: 0;
    }
    .saved-count-x {
      font-size: 12px;
      line-height: 1;
      font-weight: 400;
      color: #374151;
      white-space: nowrap;
      margin-left: 0.1px;
      margin-right: 0.1px;
      display: none;
      align-self: center;
    }
    .saved-count-x:not(:empty) {
      display: inline;
    }
    .saved-count {
      font-size: 12px;
      line-height: 1;
      font-weight: 600;
      color: #64D85B;
      white-space: nowrap;
      margin-left: 0.1px;
      margin-right: 4px;
      display: none;
      align-self: center;
    }
    .saved-count:not(:empty) {
      display: inline;
    }
    .saved-text {
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    }
    .saved-controls-divider {
      width: 1px;
      height: 20px;
      background: #E5E7EB;
      margin: 0 2px;
      flex-shrink: 0;
    }
    .saved-toggle {
      flex-shrink: 0;
      margin-right: 3px;
    }
    .saved-toggle-track {
      width: 30px;
      height: 16px;
      background: #D1D5DB;
      border-radius: 9999px;
      position: relative;
      transition: background-color 0.2s;
      cursor: pointer;
    }
    .saved-toggle-thumb {
      width: 12px;
      height: 12px;
      background: white;
      border-radius: 50%;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    .saved-controls.saved-only-active .saved-toggle-track {
      background: #64D85B;
    }
    .saved-controls.saved-only-active .saved-toggle-thumb {
      transform: translateX(12px);
    }
    @media (max-width: 1024px) {
      .saved-controls {
        padding: 0 5px;
      }
      .saved-list-section,
      .saved-only-section {
        padding: 0 3px;
        gap: 4px;
      }
      .saved-only-section.saved-only-active {
        padding-right: 32px;
      }
      .saved-only-divider {
        right: 28px; /* Default: between "Map Saved Only" and share icon */
        height: 20px;
      }
      /* When navigation icon is visible on tablet */
      .saved-only-section.saved-only-active:has(.saved-navigation-icon.visible) .saved-only-divider {
        right: 57px;
      }
      .saved-share-icon {
        right: 3px;
        width: 18px;
        height: 18px;
      }
      .saved-share-icon svg {
        width: 16px;
        height: 16px;
      }
      .saved-pill {
        padding: 3px 9px;
      }
      .saved-icon {
        width: 20px;
        height: 20px;
      }
      .saved-count {
        font-size: 12px;
        margin-left: 1px;
        margin-right: 3px;
      }
      .saved-count-x {
        font-size: 12px;
      }
      .saved-toggle-track {
        width: 28px;
        height: 16px;
      }
      .saved-toggle-thumb {
        width: 12px;
        height: 12px;
      }
      .saved-controls.saved-only-active .saved-toggle-thumb {
        transform: translateX(12px);
      }
    }
    @media (max-width: 700px) {
      .saved-controls {
        height: 36px;
        top: 10px;
        right: 10px;
      }
      .saved-toggle-track {
        width: 24px;
        height: 14px;
      }
      .saved-toggle-thumb {
        width: 10px;
        height: 10px;
        top: 2px;
        left: 2px;
      }
      .saved-controls.saved-only-active .saved-toggle-thumb {
      transform: translateX(10px);
    }
      .saved-only-section.saved-only-active {
        padding-right: 30px;
      }
      .saved-only-divider {
        right: 26px; /* Default: between "Map Saved Only" and share icon */
        height: 18px;
      }
      /* When navigation icon is visible on mobile */
      .saved-only-section.saved-only-active:has(.saved-navigation-icon.visible) .saved-only-divider {
        right: 55px;
      }
      .saved-count-x {
        font-size: 12px;
        margin-left: 0.1px;
        margin-right: 0.1px;
      }
      .saved-count {
        font-size: 12px;
        margin-left: 0.1px;
        margin-right: 3px;
      }
      .saved-share-icon {
        right: 3px;
        width: 16px;
        height: 16px;
      }
      .saved-share-icon svg {
        width: 14px;
        height: 14px;
      }
  }
  /* Filter chips */
  .filter-chips {
    position: absolute;
    top: 60px;
    right: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 1500;
    pointer-events: auto;
    font-family: Inter, sans-serif;
    font-size: 12px;
    font-weight: 400;
  }
  .filter-chips:empty {
    display: none;
  }
  .filter-chip {
    display: flex;
    align-items: center;
    gap: 6px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #E5E7EB;
    border-radius: 9999px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    padding: 4px 8px 4px 12px;
    color: #374151;
    white-space: nowrap;
    max-width: 200px;
    font-size: 11px;
    animation: slideInFromRight 0.3s ease-out;
    transform-origin: right center;
    /* iOS hardware acceleration fixes */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    will-change: transform, opacity;
    -webkit-perspective: 1000;
    perspective: 1000;
  }
  
  @keyframes slideInFromRight {
    from {
      opacity: 0;
      -webkit-transform: translateX(100%) translateZ(0);
      transform: translateX(100%) translateZ(0);
    }
    to {
      opacity: 1;
      -webkit-transform: translateX(0) translateZ(0);
      transform: translateX(0) translateZ(0);
    }
  }
  
  @-webkit-keyframes slideInFromRight {
    from {
      opacity: 0;
      -webkit-transform: translateX(100%) translateZ(0);
      transform: translateX(100%) translateZ(0);
    }
    to {
      opacity: 1;
      -webkit-transform: translateX(0) translateZ(0);
      transform: translateX(0) translateZ(0);
    }
  }
  
  @keyframes slideOutToRight {
    from {
      opacity: 1;
      -webkit-transform: translateX(0) translateZ(0);
      transform: translateX(0) translateZ(0);
    }
    to {
      opacity: 0;
      -webkit-transform: translateX(100%) translateZ(0);
      transform: translateX(100%) translateZ(0);
    }
  }
  
  @-webkit-keyframes slideOutToRight {
    from {
      opacity: 1;
      -webkit-transform: translateX(0) translateZ(0);
      transform: translateX(0) translateZ(0);
    }
    to {
      opacity: 0;
      -webkit-transform: translateX(100%) translateZ(0);
      transform: translateX(100%) translateZ(0);
    }
  }
  
  .filter-chip.slide-out {
    animation: slideOutToRight 0.3s ease-in forwards;
    -webkit-animation: slideOutToRight 0.3s ease-in forwards;
  }
  .filter-chip-label {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .filter-chip-close {
    background: none;
    border: none;
    color: #6B7280;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    padding: 0;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: color 0.2s;
  }
  .filter-chip-close:hover {
    color: #374151;
  }
  .filter-chip-clear-all {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 4px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #E5E7EB;
    border-radius: 9999px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    padding: 4px 8px 4px 12px;
    color: #374151;
    white-space: nowrap;
    max-width: 200px;
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
    font-size: 11px;
    /* iOS hardware acceleration fixes */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    will-change: transform;
    -webkit-perspective: 1000;
    perspective: 1000;
  }
  .filter-chip-clear-all span:first-child {
    flex: 1;
    text-align: left;
  }
  .filter-chip-clear-all.filter-chip-new {
    animation: slideInFromRight 0.3s ease-out;
    transform-origin: right center;
  }
  .filter-chip-clear-all:hover {
    background: rgba(249, 250, 251, 0.95);
    border-color: #D1D5DB;
  }
  .filter-chip-clear-all:active {
    background: rgba(243, 244, 246, 0.95);
  }
  .filter-chip-clear-all-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 18px;
    flex-shrink: 0;
    font-size: 18px;
    line-height: 1;
    color: #374151;
    font-weight: 400;
  }
  .filter-chip-clear-all.slide-out {
    animation: slideOutToRight 0.3s ease-in forwards;
    -webkit-animation: slideOutToRight 0.3s ease-in forwards;
  }
  @media (max-width: 700px) {
    .filter-chips {
      top: 58px;
      right: 8px;
      gap: 5px;
    }
    .filter-chip {
      padding: 3px 6px 3px 10px;
      font-size: 10px;
      max-width: 180px;
    }
    .filter-chip-clear-all {
      padding: 3px 6px 3px 10px;
      font-size: 10px;
      max-width: 180px;
      gap: 4px;
    }
    .filter-chip-clear-all-icon {
      width: 16px;
      height: 16px;
      font-size: 16px;
    }
  }
    /* Saved Colleges Overlay */
    .saved-colleges-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 9000;
      display: none;
      align-items: center;
      justify-content: center;
      font-family: Inter, sans-serif;
      touch-action: none;
    }
    .saved-colleges-overlay.active {
      display: flex;
      touch-action: auto;
    }
    .saved-colleges-modal {
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      touch-action: pan-y;
    }
    .saved-colleges-modal.compare-mode {
      max-width: 95vw;
      width: 95%;
    }
    .saved-overlay-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px;
      border-bottom: 1px solid #E5E7EB;
      flex-shrink: 0;
      background: #ffffff;
    }
    .saved-overlay-header-actions {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .saved-compare-btn {
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 500;
      color: #2563eb;
      background: transparent;
      border: 1px solid #2563eb;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: Inter, sans-serif;
      white-space: nowrap;
    }
    .saved-compare-btn:hover {
      background: #EFF6FF;
      border-color: #1d4ed8;
    }
    .saved-compare-btn:not(.visible) {
      display: none;
    }
    .saved-back-btn {
      padding: 8px;
      background: transparent;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      color: #0f172a;
      font-size: 24px;
      font-weight: 700;
      line-height: 1;
      width: 40px;
      height: 40px;
    }
    .saved-back-btn:hover {
      background: #F9FAFB;
      color: #0f172a;
    }
    .saved-print-btn {
      padding: 8px;
      background: transparent;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #2563eb;
      width: 40px;
      height: 40px;
    }
    .saved-print-btn:hover {
      background: #EFF6FF;
      color: #1d4ed8;
    }
    .saved-print-btn svg {
      width: 24px;
      height: 24px;
    }
    .saved-overlay-title-section {
      flex: 1;
    }
    .saved-overlay-title {
      font-size: 20px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 4px 0;
    }
    .saved-overlay-subtitle {
      font-size: 13px;
      color: #64748b;
      margin: 0;
    }
    .saved-overlay-close {
      background: none;
      border: none;
      font-size: 28px;
      color: #94a3b8;
      cursor: pointer;
      line-height: 1;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
      flex-shrink: 0;
    }
    .saved-overlay-close:hover {
      color: #64748b;
    }
    .saved-overlay-content {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
    }
    .saved-overlay-section {
      margin-bottom: 32px;
    }
    .saved-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .saved-section-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin: 0 0 12px 0;
    }
    .saved-section-header .saved-section-title {
      margin: 0;
      flex: 1;
    }
    .saved-count-number {
      font-weight: 600;
      color: #2563eb;
    }
    .saved-actions {
      margin-top: 8px;
      padding-top: 16px;
      margin-bottom: 0;
      border-top: 1px solid #E5E7EB;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .saved-primary-btn {
      width: 100%;
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: #2563eb;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: Inter, sans-serif;
    }
    .saved-primary-btn:hover:not(:disabled) {
      background: #1d4ed8;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(37, 99, 235, 0.3);
    }
    .saved-primary-btn:disabled {
      background: #CBD5E1;
      color: #94a3b8;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .saved-primary-btn:not(.visible) {
      display: none;
    }
    .saved-secondary-btn {
      width: 100%;
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 500;
      color: #374151;
      background: transparent;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: Inter, sans-serif;
    }
    .saved-secondary-btn:hover {
      background: #F9FAFB;
      border-color: #CBD5E1;
    }
    .saved-search-wrapper {
      position: relative;
    }
    .saved-search-wrapper::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: -12px;
      height: 20px;
      background: linear-gradient(180deg, rgba(255,255,255,0), rgba(15,23,42,0.12));
      pointer-events: none;
      z-index: 2;
      border-bottom-left-radius: 12px;
      border-bottom-right-radius: 12px;
    }
    .saved-search-input {
      width: 100%;
      padding: 12px 16px 12px 44px;
      border: 2px solid #E5E7EB;
      border-radius: 12px;
      font-size: 14px;
      font-family: Inter, sans-serif;
      color: #0f172a;
      background: #fff;
      box-sizing: border-box;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.06);
    }
    .saved-search-wrapper::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: -8px;
      height: 12px;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(15,23,42,0.08), rgba(15,23,42,0));
      opacity: 0.8;
    }
    .saved-search-input:hover {
      border-color: #CBD5E1;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
    }
    .saved-search-input:focus {
      outline: none;
      border-color: #2563eb;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1), 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
      transform: translateY(-1px);
    }
    .saved-search-input::placeholder {
      color: #94a3b8;
    }
    .saved-search-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      color: #94a3b8;
      pointer-events: none;
      z-index: 1;
    }
    .saved-search-results {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      max-height: 300px;
      overflow-y: auto;
      padding-bottom: 12px;
      z-index: 10;
      display: none;
    }
    .saved-search-results.active {
      display: block;
    }
    .saved-search-result-item {
      padding: 12px;
      border-bottom: 1px solid #F3F4F6;
      cursor: pointer;
      transition: background 0.15s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .saved-search-result-item:hover {
      background: #F9FAFB;
    }
    .saved-search-result-item:last-child {
      border-bottom: none;
    }
    .saved-search-result-info {
      flex: 1;
      min-width: 0;
    }
    .saved-search-result-name {
      font-weight: 600;
      font-size: 13px;
      color: #0f172a;
      margin-bottom: 2px;
    }
    .saved-search-result-details {
      font-size: 12px;
      color: #64748b;
    }
    .saved-search-result-save-btn {
      flex-shrink: 0;
      margin-left: 12px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 9999px;
      border: 1px solid #E5E7EB;
      background: #f1f5f9;
      color: #64748b;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
      white-space: nowrap;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .saved-search-result-save-btn span {
      display: inline-block;
      width: 12px;
      text-align: center;
      line-height: 1;
    }
    .saved-search-result-save-btn:hover {
      background: #e2e8f0;
      color: #475569;
    }
    .saved-search-result-save-btn.saved {
      background: #dcfce7;
      border-color: #86efac;
      color: #15803d;
    }
    .saved-search-result-save-btn.saved:hover {
      background: #bbf7d0;
    }
    .saved-colleges-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .saved-college-item {
      padding: 12px;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      background: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: box-shadow 0.2s, opacity 0.25s ease, transform 0.25s ease, max-height 0.25s ease, margin 0.25s ease, padding 0.25s ease;
      max-height: 200px;
    }
    .saved-college-item:hover {
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    .saved-college-item.removing {
      opacity: 0;
      transform: translateX(12px);
      max-height: 0;
      margin-top: 0;
      margin-bottom: 0;
      padding-top: 0;
      padding-bottom: 0;
    }
    .saved-college-info {
      flex: 1;
      min-width: 0;
    }
    .saved-college-name {
      font-weight: 600;
      font-size: 14px;
      color: #0f172a;
      margin-bottom: 2px;
    }
    .saved-college-details {
      font-size: 12px;
      color: #64748b;
    }
    .saved-college-website-link {
      font-size: 12px;
      color: #2563eb;
      text-decoration: none;
      margin-left: 8px;
      transition: color 0.2s;
    }
    .saved-college-website-link:hover {
      color: #1d4ed8;
      text-decoration: underline;
    }
    /* Compare Mode Styles */
    .saved-compare-table-wrapper {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      width: 100%;
      max-width: 100%;
      overflow-y: visible;
    }
    .saved-compare-table-wrapper::-webkit-scrollbar {
      height: 8px;
    }
    .saved-compare-table-wrapper::-webkit-scrollbar-track {
      background: #F3F4F6;
      border-radius: 4px;
    }
    .saved-compare-table-wrapper::-webkit-scrollbar-thumb {
      background: #CBD5E1;
      border-radius: 4px;
    }
    .saved-compare-table-wrapper::-webkit-scrollbar-thumb:hover {
      background: #94A3B8;
    }
    .saved-compare-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      table-layout: fixed;
    }
    /* Expand table to full width in compare mode */
    .saved-compare-view .saved-compare-table-wrapper {
      margin-left: -20px;
      margin-right: -20px;
      padding-left: 20px;
      padding-right: 20px;
      width: calc(100% + 40px);
    }
    @media (max-width: 768px) {
      .saved-compare-view .saved-compare-table-wrapper {
        margin-left: -16px;
        margin-right: -16px;
        padding-left: 16px;
        padding-right: 16px;
        width: calc(100% + 32px);
      }
    }
    .saved-compare-table th {
      text-align: left;
      padding: 12px;
      border-bottom: 2px solid #E5E7EB;
      font-weight: 600;
      color: #0f172a;
      background: #F9FAFB;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .saved-compare-table th:first-child {
      min-width: 120px;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    .saved-compare-table th:not(:first-child),
    .saved-compare-table td:not(:first-child) {
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    .saved-compare-table td {
      padding: 12px;
      border-bottom: 1px solid #F3F4F6;
      color: #374151;
      vertical-align: top;
      white-space: nowrap;
    }
    .saved-compare-table tr:last-child td {
      border-bottom: none;
    }
    .saved-compare-table .saved-compare-label {
      font-weight: 500;
      color: #64748b;
    }
    /* Allow type of school to wrap to two lines */
    .saved-compare-table tbody tr:first-child td.saved-compare-value {
      white-space: normal;
      line-height: 1.4;
    }
    .saved-compare-table .saved-compare-value {
      color: #0f172a;
    }
    .saved-compare-table .saved-compare-website {
      color: #2563eb;
      text-decoration: none;
      word-break: break-all;
      word-wrap: break-word;
      max-width: 200px;
      display: inline-block;
    }
    .saved-compare-table .saved-compare-website:hover {
      text-decoration: underline;
    }
    .saved-compare-table .saved-compare-unsave {
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 500;
      border-radius: 4px;
      border: 1px solid #86efac;
      background: #dcfce7;
      color: #15803d;
      cursor: pointer;
      transition: all 0.2s;
    }
    .saved-compare-table .saved-compare-unsave:hover {
      background: #bbf7d0;
    }
    .saved-list-view:not(.visible) {
      display: none;
    }
    .saved-compare-view:not(.visible) {
      display: none;
    }
    .saved-compare-disclaimer {
      margin-top: 20px;
      padding: 16px;
      font-size: 12px;
      color: #64748b;
      line-height: 1.6;
      background: #F9FAFB;
      border-radius: 8px;
      border: 1px solid #E5E7EB;
    }
    @media (max-width: 768px) {
      .saved-colleges-modal {
        width: 95%;
        max-height: 85vh;
      }
      .saved-overlay-header {
        padding: 16px;
      }
      .saved-overlay-content {
        padding: 16px;
      }
    }
    .saved-college-unsave-btn {
      flex-shrink: 0;
      margin-left: 12px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 9999px;
      border: 1px solid #86efac;
      background: #dcfce7;
      color: #15803d;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
      white-space: nowrap;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .saved-college-unsave-btn:hover {
      background: #bbf7d0;
    }
    .saved-empty-state {
      padding: 40px 20px;
      text-align: center;
      color: #64748b;
    }
    .saved-empty-state-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 8px;
    }
    .saved-empty-state-text {
      font-size: 13px;
      line-height: 1.5;
    }
    .unsave-all-btn {
      padding: 6px 12px;
      font-size: 14px;
      font-weight: 500;
      color: #dc2626;
      background: transparent;
      border: 1px solid #E5E7EB;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .unsave-all-btn:hover {
      background: #FEF2F2;
      border-color: #FCA5A5;
    }
    .saved-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .saved-modal-overlay.active {
      display: flex;
    }
    .saved-modal {
      background: #fff;
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: calc(100% - 40px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }
    .saved-modal-title {
      font-size: 16px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 20px 0;
    }
    .saved-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    .saved-modal-btn {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid #E5E7EB;
    }
    .saved-modal-cancel {
      background: #fff;
      color: #374151;
    }
    .saved-modal-cancel:hover {
      background: #F9FAFB;
    }
    .saved-modal-confirm {
      background: #dc2626;
      color: #fff;
      border-color: #dc2626;
    }
    .saved-modal-confirm:hover {
      background: #b91c1c;
      border-color: #b91c1c;
    }
    /* Route Planner Modal */
    .route-planner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 8500;
      display: none;
      align-items: center;
      justify-content: center;
      font-family: Inter, sans-serif;
      touch-action: none;
    }
    .route-planner-overlay.active {
      display: flex;
      touch-action: auto;
    }
    .route-planner-modal {
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      touch-action: pan-y;
    }
    .route-planner-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px;
      border-bottom: 1px solid #E5E7EB;
      flex-shrink: 0;
      background: #ffffff;
    }
    .route-planner-title-section {
      flex: 1;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    .route-planner-icon-wrapper {
      flex-shrink: 0;
      width: 24px;
      height: 24px;
      margin-top: 2px;
    }
    .route-planner-icon {
      width: 24px;
      height: 24px;
      stroke: #1d4ed8;
      stroke-width: 2;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .route-planner-title {
      font-size: 20px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 4px 0;
    }
    .route-planner-subtitle {
      font-size: 13px;
      color: #64748b;
      margin: 0;
      line-height: 1.4;
    }
    .route-planner-subtitle {
      font-size: 13px;
      color: #64748b;
      margin: 0;
    }
    .route-planner-close {
      background: none;
      border: none;
      font-size: 28px;
      color: #94a3b8;
      cursor: pointer;
      line-height: 1;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
      flex-shrink: 0;
    }
    .route-planner-close:hover {
      color: #64748b;
    }
    .route-planner-content {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
    }
    .route-planner-section {
      margin-bottom: 24px;
    }
    .route-summary {
      background: #F9FAFB;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      padding: 8px 12px;
    }
    .route-summary-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }
    .route-summary-item:last-child {
      margin-bottom: 0;
    }
    .route-summary-label {
      font-size: 13px;
      font-weight: 600;
      color: #64748b;
      min-width: 45px;
    }
    .route-summary-value {
      font-size: 14px;
      color: #0f172a;
      flex: 1;
    }
    .route-summary-arrow {
      text-align: center;
      color: #94a3b8;
      font-size: 18px;
      padding: 6px 0;
    }
    .route-planner-section-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin: 0 0 4px 0;
    }
    .route-planner-count-number {
      color: #1d4ed8;
      font-weight: 600;
    }
    .route-planner-section-subtitle {
      font-size: 12px;
      color: #64748b;
      margin: 0 0 12px 0;
    }
    .route-planner-colleges-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .route-planner-college-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 10px;
      background: #fff;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      transition: all 0.2s;
    }
    .route-planner-college-item:hover {
      border-color: #CBD5E1;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    .route-planner-college-checkbox {
      margin-top: 2px;
      flex-shrink: 0;
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #2563eb;
    }
    .route-planner-college-info {
      flex: 1;
      min-width: 0;
    }
    .route-planner-college-name {
      font-size: 14px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 3px 0;
    }
    .route-planner-college-details {
      font-size: 12px;
      color: #64748b;
      margin: 0 0 1px 0;
    }
    .route-planner-college-distance {
      font-size: 12px;
      color: #2563eb;
      font-weight: 500;
      margin: 0;
    }
    .route-planner-empty-state {
      padding: 32px 20px;
      text-align: center;
      color: #64748b;
    }
    /* Share Overlay Styles */
    .share-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 8500;
      display: none;
      align-items: center;
      justify-content: center;
      font-family: Inter, sans-serif;
      touch-action: none;
    }
    .share-overlay.active {
      display: flex;
      touch-action: auto;
    }
    .share-modal {
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      touch-action: pan-y;
    }
    .share-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px;
      border-bottom: 1px solid #E5E7EB;
      flex-shrink: 0;
      background: #ffffff;
    }
    .share-title-section {
      flex: 1;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    .share-icon-wrapper {
      flex-shrink: 0;
      width: 24px;
      height: 24px;
      margin-top: 2px;
    }
    .share-icon {
      width: 24px;
      height: 24px;
      fill: #1d4ed8;
    }
    .share-title {
      font-size: 20px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 4px 0;
    }
    .share-subtitle {
      font-size: 13px;
      color: #64748b;
      margin: 0;
      line-height: 1.4;
    }
    .share-close {
      background: none;
      border: none;
      font-size: 28px;
      color: #94a3b8;
      cursor: pointer;
      line-height: 1;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
      flex-shrink: 0;
    }
    .share-close:hover {
      color: #64748b;
    }
    .share-content {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
    }
    .share-section {
      margin-bottom: 24px;
    }
    .share-section:last-child {
      margin-bottom: 0;
    }
    .share-summary {
      background: #F9FAFB;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 14px;
      color: #0f172a;
      line-height: 1.5;
    }
    .share-preview {
      background: #F9FAFB;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      padding: 12px 16px;
    }
    .share-preview-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .share-preview-item {
      font-size: 14px;
      color: #0f172a;
      padding: 4px 0;
      line-height: 1.5;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .share-preview-checkmark {
      color: #0f172a;
      font-size: 16px;
      flex-shrink: 0;
    }
    .share-preview-label {
      font-size: 12px;
      color: #64748b;
      font-style: italic;
      margin-left: 4px;
    }
    .share-summary-number {
      font-weight: 600;
      color: #2563eb;
    }
    .share-preview-more {
      font-size: 14px;
      color: #64748b;
      font-style: italic;
      margin-top: 4px;
      padding-left: 24px; /* Align with college name (checkmark width ~16px + gap 8px) */
    }
    .share-actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .share-primary-btn {
      background: #2563eb;
      color: #ffffff;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s;
      font-family: Inter, sans-serif;
    }
    .share-primary-btn:hover {
      background: #1d4ed8;
    }
    .share-primary-btn:active {
      background: #1e40af;
    }
    .share-primary-btn.copied {
      background: #16a34a;
    }
    .share-primary-btn.copied:hover {
      background: #15803d;
    }
    .share-explanation {
      font-size: 12px;
      color: #64748b;
      margin: 0;
      line-height: 1.4;
      text-align: center;
    }
    .share-secondary-btn {
      background: transparent;
      color: #64748b;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      font-family: Inter, sans-serif;
    }
    .share-secondary-btn:hover {
      background: #F9FAFB;
      border-color: #CBD5E1;
      color: #475569;
    }
    @media (max-width: 768px) {
      .share-modal {
        width: 95%;
        max-height: 85vh;
      }
      .share-header {
        padding: 16px;
      }
      .share-content {
        padding: 16px;
      }
      .share-section {
        margin-bottom: 20px;
      }
    }
    .route-planner-empty-state {
      padding: 32px 20px;
      text-align: center;
      color: #64748b;
    }
    .route-planner-empty-state-text {
      font-size: 13px;
      line-height: 1.5;
    }
    .route-planner-actions {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #E5E7EB;
    }
    .route-planner-error {
      font-size: 12px;
      color: #dc2626;
      margin-bottom: 10px;
      padding: 8px 12px;
      background: #FEF2F2;
      border: 1px solid #FCA5A5;
      border-radius: 6px;
    }
    .route-planner-primary-btn {
      width: 100%;
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: #2563eb;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 10px;
    }
    .route-planner-primary-btn:hover:not(:disabled) {
      background: #1d4ed8;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(37, 99, 235, 0.3);
    }
    .route-planner-primary-btn:disabled {
      background: #CBD5E1;
      color: #94a3b8;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .route-planner-cancel-btn {
      width: 100%;
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 500;
      color: #374151;
      background: transparent;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .route-planner-cancel-btn:hover {
      background: #F9FAFB;
      border-color: #CBD5E1;
    }
    @media (max-width: 700px) {
      .route-planner-overlay {
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        box-shadow: none;
      }
      .saved-colleges-overlay {
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      .saved-modal {
        margin: 20px;
      }
    }
    /* Onboarding Overlay Styles */
    .onboarding-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100vw;
      height: 100vh;
      background: #F8F8F8;
      z-index: 99999;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Inter, sans-serif;
      overflow: hidden;
      overflow-y: hidden;
      overflow-x: hidden;
      touch-action: none; /* Prevent all touch scrolling */
      -webkit-overflow-scrolling: none;
    }
    .onboarding-overlay.active {
      display: flex;
    }
    /* Decorative blue shapes - adjusted positioning */
    .onboarding-overlay::before {
      content: '';
      position: absolute;
      top: -50px; /* Moved up more to show less of the circle */
      left: 0;
      width: 120px;
      height: 120px;
      background: #2F80ED;
      border-radius: 0 0 120px 0;
      opacity: 1;
      z-index: 0;
    }
    .onboarding-overlay::after {
      content: '';
      position: absolute;
      bottom: -50px; /* Moved down more to show less of the circle */
      right: 0;
      width: 120px;
      height: 120px;
      background: #2F80ED;
      border-radius: 120px 0 0 0;
      opacity: 1;
      z-index: 0;
    }
    /* Tablet: Larger corner circles to reduce white space */
    @media (min-width: 769px) and (max-width: 1024px) {
      .onboarding-overlay::before {
        width: 180px; /* Increased from 120px (50% larger) */
        height: 180px; /* Increased from 120px */
        top: -60px; /* Adjusted to show similar proportion */
        border-radius: 0 0 180px 0;
      }
      .onboarding-overlay::after {
        width: 180px; /* Increased from 120px (50% larger) */
        height: 180px; /* Increased from 120px */
        bottom: -60px; /* Adjusted to show similar proportion */
        border-radius: 180px 0 0 0;
      }
    }
    .onboarding-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 1;
      overflow: hidden;
      overflow-y: hidden;
      overflow-x: hidden;
      -webkit-overflow-scrolling: none;
      touch-action: none;
    }
    /* Mobile: Full screen */
    @media (max-width: 768px) {
      .onboarding-container {
        padding: 16px;
      }
    }
    /* Tablet: Hide onboarding */
    @media (min-width: 769px) and (max-width: 1024px) {
      .onboarding-overlay {
        display: none !important;
      }
    }
    /* Desktop: Hide onboarding */
    @media (min-width: 1025px) {
      .onboarding-overlay {
        display: none !important;
      }
    }
    /* Back Button */
    .onboarding-back-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      background: transparent;
      border: none;
      color: #e2e8f0; /* Very light gray, close to white */
      cursor: pointer;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      transition: background 0.2s, color 0.2s;
      z-index: 100; /* Higher z-index to ensure it's clickable */
      pointer-events: auto; /* Ensure clicks work */
      outline: none; /* Remove default focus outline */
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
    }
    .onboarding-back-btn:hover {
      background: #F9FAFB;
      color: #cbd5e1; /* Slightly darker gray on hover */
    }
    .onboarding-back-btn:active {
      background: transparent !important; /* Keep transparent on click */
      color: #cbd5e1; /* Slightly darker on click */
    }
    .onboarding-back-btn:focus {
      outline: none; /* Remove focus outline */
      background: transparent; /* Keep transparent on focus */
    }
    .onboarding-back-btn:focus-visible {
      outline: none; /* Remove focus-visible outline */
    }
    .onboarding-back-btn svg {
      stroke: currentColor; /* Ensure SVG uses the color */
    }
    .onboarding-back-btn svg {
      width: 24px;
      height: 24px;
    }
    @media (max-width: 768px) {
      .onboarding-back-btn {
        top: 16px;
        left: 16px;
      }
    }
    /* Skip Button - Now positioned below Next button */
    .onboarding-skip-btn {
      background: transparent;
      border: none;
      color: #64748b;
      cursor: pointer;
      padding: 8px 12px;
      font-size: 14px;
      font-weight: 500;
      border-radius: 6px;
      transition: all 0.2s;
      z-index: 10;
      font-family: Inter, sans-serif;
      margin-top: 12px;
      display: inline-block;
      text-align: center;
    }
    /* First and last page skip button - percentage-based sizing */
    .onboarding-page[data-page="1"] .onboarding-skip-btn,
    .onboarding-page[data-page="7"] .onboarding-skip-btn {
      padding: 1.2vh 2vw; /* 1.2% viewport height × 2% viewport width */
      font-size: 1.8vw; /* Responsive to viewport width */
      margin-top: 1.8vh; /* ~1.8% of viewport height */
    }
    .onboarding-skip-btn:hover {
      color: #475569;
    }
    @media (max-width: 768px) {
      .onboarding-skip-btn {
        font-size: 3.2vw;
        margin-top: 1.2vh;
      }
      /* First and last page skip button - 1/3 from top of space between Next button and dots, Mont font */
      .onboarding-page[data-page="1"] .onboarding-skip-btn,
      .onboarding-page[data-page="7"] .onboarding-skip-btn {
        position: absolute;
        bottom: 18.15vh; /* 1/3 from top of space: Next (22.22vh) - (12.22vh/3) = 18.15vh from bottom */
        left: 50%;
        transform: translateX(-50%);
        font-size: 3.2vw;
        font-weight: 500; /* Slightly fatter */
        font-style: normal;
        letter-spacing: 0.02em; /* Slightly tighter for square-ish look */
        margin-top: 0;
        padding: 1vh 3vw;
        text-align: center;
        color: #94a3b8; /* Gray color */
        font-family: 'Montserrat', 'Mont', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif; /* Mont or Montserrat font */
      }
      .onboarding-page[data-page="1"] .onboarding-skip-btn:hover,
      .onboarding-page[data-page="7"] .onboarding-skip-btn:hover {
        color: #64748b; /* Slightly darker gray on hover */
      }
    }
    /* Tablet sizing for first/last page skip button */
    @media (min-width: 769px) and (max-width: 1024px) {
      .onboarding-page[data-page="1"] .onboarding-skip-btn,
      .onboarding-page[data-page="7"] .onboarding-skip-btn {
        font-size: 2vw; /* Slightly larger on tablet */
        margin-top: 2vh; /* ~2% of viewport height */
        padding: 1.3vh 2.2vw; /* 1.3% viewport height × 2.2% viewport width */
      }
    }
    /* Button container for proper stacking */
    .onboarding-page {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .onboarding-next-btn,
    .onboarding-get-started-btn,
    .onboarding-skip-btn {
      align-self: center;
    }
    /* Pages Container */
    .onboarding-pages {
      position: relative;
      width: 100%;
      max-width: 100%;
      flex: 1;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      overflow: hidden;
      padding-top: 20px;
    }
    /* Individual Page */
    .onboarding-page {
      position: absolute;
      width: 100%;
      max-width: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      text-align: center;
      opacity: 0;
      transform: translateX(100%);
      transition: opacity 0.3s ease, transform 0.3s ease;
      padding: 20px 0;
      min-height: 100vh; /* Ensure full height for absolute positioning */
    }
    /* Pages 2-6: Ensure same positioning context as page 1 */
    .onboarding-page[data-page="2"],
    .onboarding-page[data-page="3"],
    .onboarding-page[data-page="4"],
    .onboarding-page[data-page="5"],
    .onboarding-page[data-page="6"] {
      position: relative;
      min-height: 100vh;
    }
    /* Tablet: Ensure pages 2-6 have proper positioning context */
    @media (min-width: 769px) and (max-width: 1024px) {
      .onboarding-page[data-page="2"],
      .onboarding-page[data-page="3"],
      .onboarding-page[data-page="4"],
      .onboarding-page[data-page="5"],
      .onboarding-page[data-page="6"] {
        position: relative;
        min-height: 100vh;
      }
    }
    /* First and last pages - absolute positioning for precise placement */
    .onboarding-page[data-page="1"],
    .onboarding-page[data-page="7"] {
      position: relative;
      justify-content: flex-start;
      padding-top: 0;
      min-height: 100vh;
      gap: 0;
    }
    @media (max-width: 768px) {
      .onboarding-page[data-page="1"],
      .onboarding-page[data-page="7"] {
        padding-top: 0;
      }
    }
    /* Tablet padding for first/last pages - removed since using absolute positioning */
    @media (min-width: 769px) and (max-width: 1024px) {
      .onboarding-page[data-page="1"],
      .onboarding-page[data-page="7"] {
        padding-top: 0; /* No padding, using absolute positioning like mobile */
      }
    }
    .onboarding-page.active {
      display: flex;
      opacity: 1;
      transform: translateX(0);
      position: relative;
    }
    .onboarding-page.prev {
      transform: translateX(-100%);
    }
    .onboarding-page.next {
      transform: translateX(100%);
    }
    /* Icon animations */
    @keyframes riseUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @keyframes dropDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    /* Icon */
    .onboarding-icon {
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .onboarding-icon img {
      width: auto;
      height: auto;
      max-width: 120px;
      max-height: 120px;
      /* Make icons transparent - works for PNG with transparent background */
      background: transparent !important;
    }
    /* For SVG icons - ensure transparency */
    .onboarding-icon img[src$=".svg"] {
      background: transparent !important;
      opacity: 1;
    }
    /* For PNG icons - ensure transparency works */
    .onboarding-icon img[src$=".png"] {
      background: transparent !important;
    }
    /* Alternative: if SVG has white background, use blend mode (may affect colors) */
    .onboarding-icon img[src*="page-1-icon"],
    .onboarding-icon img[src*="page-7-icon"] {
      /* For icon-only pages, ensure transparency */
      background: transparent !important;
    }
    /* First and last page icons - percentage-based sizing and spacing */
    .onboarding-page[data-page="1"] .onboarding-icon,
    .onboarding-page[data-page="7"] .onboarding-icon {
      margin-bottom: 5vh; /* ~5% of viewport height */
    }
    .onboarding-page[data-page="1"] .onboarding-icon img,
    .onboarding-page[data-page="7"] .onboarding-icon img {
      width: 25vw; /* 25% of viewport width */
      height: auto;
      max-width: 25vw;
      max-height: 25vw; /* Keep square aspect ratio */
    }
    @media (max-width: 768px) {
      .onboarding-icon {
        margin-bottom: 2.5vh;
      }
      .onboarding-icon img {
        max-width: 100px;
        max-height: 100px;
      }
      /* First and last page icons - 1/6 screen width, top at 1/9 from top */
      .onboarding-page[data-page="1"] .onboarding-icon,
      .onboarding-page[data-page="7"] .onboarding-icon {
        position: absolute;
        top: 11.11vh; /* 1/9 from top */
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 0;
        opacity: 0;
      }
      /* Apply animations on mobile */
      .onboarding-page[data-page="1"] .onboarding-icon {
        animation: iconRise 0.6s ease-out forwards;
      }
      .onboarding-page[data-page="7"] .onboarding-icon {
        animation: iconDrop 0.6s ease-out forwards;
      }
      .onboarding-page[data-page="1"] .onboarding-icon img,
      .onboarding-page[data-page="7"] .onboarding-icon img {
        width: 30vw !important; /* 10% smaller than 33.34vw = 30vw for mobile */
        max-width: 30vw !important; /* Override any 100px limit */
        max-height: 30vw !important;
        height: auto;
        min-width: 30vw !important; /* Ensure minimum size */
      }
    }
    /* Tablet sizing for first/last page icons */
    @media (min-width: 769px) and (max-width: 1024px) {
      .onboarding-page[data-page="1"] .onboarding-icon,
      .onboarding-page[data-page="7"] .onboarding-icon {
        position: absolute;
        top: 11.11vh; /* 1/9 from top, same as mobile */
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 0;
        opacity: 0;
      }
      /* Apply animations on tablet */
      .onboarding-page[data-page="1"] .onboarding-icon {
        animation: iconRise 0.6s ease-out forwards;
      }
      .onboarding-page[data-page="7"] .onboarding-icon {
        animation: iconDrop 0.6s ease-out forwards;
      }
      .onboarding-page[data-page="1"] .onboarding-icon img,
      .onboarding-page[data-page="7"] .onboarding-icon img {
        width: 16.67vw !important; /* 1/6 of viewport width, same as mobile */
        max-width: 16.67vw !important;
        max-height: 16.67vw !important;
        min-width: 16.67vw !important;
        height: auto;
      }
    }
    /* Icon animations */
    @keyframes iconRise {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(25px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    @keyframes iconDrop {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-25px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    /* Apply rise animation to globe icon (page 1) */
    .onboarding-page[data-page="1"] .onboarding-icon {
      opacity: 0;
      animation: iconRise 0.6s ease-out forwards;
    }
    /* Apply drop animation to green location icon (page 7) */
    .onboarding-page[data-page="7"] .onboarding-icon {
      opacity: 0;
      animation: iconDrop 0.6s ease-out forwards;
    }
    /* Title */
    .onboarding-title {
      font-size: 28px;
      font-weight: 700;
      color: #0f172a;
      margin: 0 0 24px 0;
      line-height: 1.3;
    }
    /* First and last page titles - percentage-based sizing */
    .onboarding-page[data-page="1"] .onboarding-title,
    .onboarding-page[data-page="7"] .onboarding-title {
      font-size: 4.5vw; /* Responsive to viewport width */
      margin-bottom: 3.5vh; /* ~3.5% of viewport height */
      line-height: 1.2;
    }
    @media (max-width: 768px) {
      .onboarding-title {
        font-size: 24px;
        margin-bottom: 2.5vh;
      }
      /* Pages 2-6: Title positioned higher to avoid being blocked by screenshots */
      .onboarding-page[data-page="2"] .onboarding-title,
      .onboarding-page[data-page="3"] .onboarding-title,
      .onboarding-page[data-page="4"] .onboarding-title,
      .onboarding-page[data-page="5"] .onboarding-title,
      .onboarding-page[data-page="6"] .onboarding-title {
        position: absolute;
        top: 6vh !important; /* Raised from 9vh to 6vh to avoid screenshot overlap */
        left: 50%; /* Center horizontally */
        transform: translateX(-50%); /* Center horizontally */
        width: auto;
        padding: 0; /* Remove padding */
        margin: 0; /* Remove margin */
        text-align: center;
        box-sizing: border-box;
        font-size: 5.5vw !important; /* Adjusted to keep titles in one line on most devices */
        line-height: 1.2; /* Tighter line height to keep in one line */
        white-space: nowrap; /* Prevent title from wrapping to multiple lines */
        overflow: hidden; /* Hide overflow if text is too long */
        text-overflow: ellipsis; /* Show ellipsis if text overflows */
        z-index: 10; /* Ensure title is above screenshots */
      }
      /* First and last page titles - center of two lines at 1/3 from top, 3/4 page width, more spacing between lines */
      .onboarding-page[data-page="1"] .onboarding-title,
      .onboarding-page[data-page="7"] .onboarding-title {
        position: absolute;
        top: 33.33vh; /* 1/3 from top */
        left: 50%;
        transform: translate(-50%, -50%); /* Center vertically on the 1/3 line */
        width: 75%; /* 3/4 of page width */
        text-align: center;
        font-size: 7.5vw; /* Increased to make widest part 3/4 of page width */
        margin-bottom: 0;
        line-height: 1.5; /* Increased from 1.2 to 1.5 for more spacing between lines */
      }
      /* Add extra spacing between the two lines of the title */
      .onboarding-page[data-page="1"] .onboarding-title br,
      .onboarding-page[data-page="7"] .onboarding-title br {
        display: block;
        content: '';
        margin-top: 0.5vh; /* Add spacing after the line break */
      }
    }
    /* Tablet sizing for first/last page titles */
    @media (min-width: 769px) and (max-width: 1024px) {
      .onboarding-page[data-page="1"] .onboarding-title,
      .onboarding-page[data-page="7"] .onboarding-title {
        position: absolute;
        top: 33.33vh; /* 1/3 from top, same as mobile */
        left: 50%;
        transform: translate(-50%, -50%); /* Center vertically on the 1/3 line */
        width: 75%; /* 3/4 of container width, same as mobile */
        text-align: center;
        font-size: 4.5vw !important; /* Adjusted for tablet */
        margin-bottom: 0;
        line-height: 1.5; /* Same as mobile */
      }
      .onboarding-page[data-page="1"] .onboarding-title br,
      .onboarding-page[data-page="7"] .onboarding-title br {
        display: block;
        content: '';
        margin-top: 0.5vh; /* Same spacing as mobile */
      }
      /* Pages 2-6: Title positioned above screenshots, centered, no margin/padding */
      .onboarding-page[data-page="2"] .onboarding-title,
      .onboarding-page[data-page="3"] .onboarding-title,
      .onboarding-page[data-page="4"] .onboarding-title,
      .onboarding-page[data-page="5"] .onboarding-title,
      .onboarding-page[data-page="6"] .onboarding-title {
        position: absolute;
        top: 4vh !important; /* Moved higher to ensure it's above screenshots */
        left: 50%; /* Center horizontally */
        transform: translateX(-50%); /* Center horizontally */
        width: auto;
        padding: 0; /* Remove padding */
        margin: 0; /* Remove margin */
        text-align: center;
        box-sizing: border-box;
        font-size: 5vw !important; /* Increased font size for tablet */
        line-height: 1.2; /* Tighter line height */
        white-space: nowrap; /* Prevent title from wrapping */
        overflow: hidden;
        text-overflow: ellipsis;
        z-index: 10; /* Ensure title is above screenshot */
      }
    }
    /* Description */
    .onboarding-description {
      font-size: 16px;
      color: #64748b;
      line-height: 1.6;
      margin: 0 0 32px 0;
      max-width: 600px;
    }
    /* Add spacing between paragraphs on first and last page - percentage-based */
    .onboarding-page[data-page="1"] .onboarding-description,
    .onboarding-page[data-page="7"] .onboarding-description {
      display: flex;
      flex-direction: column;
      gap: 2.2vh; /* ~2.2% of viewport height between paragraphs */
      margin-bottom: 5vh; /* ~5% of viewport height */
      font-size: 2.2vw; /* Responsive to viewport width */
      line-height: 1.6;
      max-width: 85%; /* 85% of container width */
      width: 85%;
    }
    .onboarding-page[data-page="1"] .onboarding-description span,
    .onboarding-page[data-page="7"] .onboarding-description span {
      display: block;
    }
    .onboarding-page[data-page="1"] .onboarding-description span:first-child,
    .onboarding-page[data-page="7"] .onboarding-description span:first-child {
      margin-bottom: 2.2vh; /* Same gap as flex gap */
    }
    @media (max-width: 768px) {
      .onboarding-description {
        font-size: 14px;
        margin-bottom: 3.5vh;
        padding: 0 4vw; /* 4% of viewport width */
      }
      /* First and last page descriptions - pushed down a bit, same color as title, reduced gap */
      .onboarding-page[data-page="1"] .onboarding-description,
      .onboarding-page[data-page="7"] .onboarding-description {
        position: absolute;
        top: 55vh; /* Pushed down from 50vh to 55vh */
        left: 50%;
        transform: translate(-50%, -50%); /* Center vertically and horizontally */
        font-size: 3.8vw;
        gap: 1.5vh; /* Reduced from 2.2vh to 1.5vh */
        margin-bottom: 0;
        padding: 0 5vw;
        line-height: 1.5;
        max-width: 88%;
        width: 88%;
        text-align: center;
        color: #0f172a; /* Same color as title */
      }
      .onboarding-page[data-page="1"] .onboarding-description span:first-child,
      .onboarding-page[data-page="7"] .onboarding-description span:first-child {
        margin-bottom: 1.5vh; /* Reduced to match gap */
      }
    }
    /* Tablet sizing for first/last page descriptions */
    @media (min-width: 769px) and (max-width: 1024px) {
      .onboarding-page[data-page="1"] .onboarding-description,
      .onboarding-page[data-page="7"] .onboarding-description {
        position: absolute;
        top: 55vh; /* Same as mobile */
        left: 50%;
        transform: translate(-50%, -50%); /* Center vertically and horizontally */
        font-size: 2.8vw; /* Adjusted for tablet */
        gap: 1.5vh; /* Same as mobile */
        margin-bottom: 0;
        padding: 0 5vw;
        line-height: 1.5;
        max-width: 88%;
        width: 88%;
        text-align: center;
        color: #0f172a; /* Same color as title */
      }
      .onboarding-page[data-page="1"] .onboarding-description span:first-child,
      .onboarding-page[data-page="7"] .onboarding-description span:first-child {
        margin-bottom: 1.5vh; /* Same as mobile */
      }
    }
    /* Screenshot */
    .onboarding-screenshot {
      margin: 0 0 40px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 100%;
      padding: 0 20px;
      background: transparent; /* Ensure no background */
    }
    .onboarding-screenshot img {
      width: 100%;
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      background: transparent; /* Ensure image has no background */
    }
    @media (max-width: 768px) {
      .onboarding-screenshot {
        margin-bottom: 32px;
        padding: 0 16px;
      }
      /* Pages 2-6: Screenshot positioned in middle between title and body text, 1/12 margin, centered horizontally */
      .onboarding-page[data-page="2"] .onboarding-screenshot,
      .onboarding-page[data-page="3"] .onboarding-screenshot,
      .onboarding-page[data-page="4"] .onboarding-screenshot,
      .onboarding-page[data-page="5"] .onboarding-screenshot,
      .onboarding-page[data-page="6"] .onboarding-screenshot {
        position: absolute;
        top: 33.335vh; /* Perfect center: (9vh + 55.56vh) / 2 = 32.28vh, but keeping balanced spacing */
        left: 50%; /* Center horizontally */
        transform: translate(-50%, -50%); /* Center both horizontally and vertically */
        width: calc(100vw - 2 * (100vw / 12)); /* Exactly 10/12 = 83.333vw */
        max-width: calc(100vw - 2 * (100vw / 12)); /* Ensure it doesn't exceed */
        height: auto; /* Let height adjust to content */
        max-height: none; /* Remove height constraint to allow enlargement */
        margin-bottom: 0;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        background: transparent !important; /* Remove any gray background */
        border: none; /* Remove any border */
      }
      .onboarding-page[data-page="2"] .onboarding-screenshot img,
      .onboarding-page[data-page="3"] .onboarding-screenshot img,
      .onboarding-page[data-page="4"] .onboarding-screenshot img,
      .onboarding-page[data-page="5"] .onboarding-screenshot img,
      .onboarding-page[data-page="6"] .onboarding-screenshot img {
        width: 100%; /* Match container width exactly (83.34vw) */
        height: auto; /* Adjust height proportionally to maintain aspect ratio */
        max-width: 100%;
        max-height: none; /* Remove height constraint to allow enlargement */
        object-fit: contain; /* Maintain aspect ratio while fitting */
        background: transparent !important; /* Remove any gray background from image */
        border: none; /* Remove any border */
        border-radius: 0; /* Remove border radius */
        box-shadow: none; /* Remove shadow */
        display: block; /* Remove any inline spacing */
      }
      /* Short screens: Adjust screenshot size (slightly increase by 5%) and reduce icons */
      /* Breakpoint: aspect ratio < 0.58 (height/width) or viewport height < 650px */
      /* Examples: iPhone SE (375×667 = 0.562), iPhone 12 mini (375×812 = 0.462) */
      @media (max-width: 768px) and (max-height: 700px) {
        .onboarding-page[data-page="2"] .onboarding-screenshot,
        .onboarding-page[data-page="3"] .onboarding-screenshot,
        .onboarding-page[data-page="4"] .onboarding-screenshot,
        .onboarding-page[data-page="5"] .onboarding-screenshot,
        .onboarding-page[data-page="6"] .onboarding-screenshot {
          width: calc((100vw - 2 * (100vw / 12)) * 0.86625); /* Increase by another 10%: 78.75% * 1.10 = 86.625% */
          max-width: calc((100vw - 2 * (100vw / 12)) * 0.86625);
          max-height: 34.65vh; /* Increase by another 10%: 31.5vh * 1.10 = 34.65vh */
        }
        .onboarding-page[data-page="2"] .onboarding-screenshot img,
        .onboarding-page[data-page="3"] .onboarding-screenshot img,
        .onboarding-page[data-page="4"] .onboarding-screenshot img,
        .onboarding-page[data-page="5"] .onboarding-screenshot img,
        .onboarding-page[data-page="6"] .onboarding-screenshot img {
          max-height: 34.65vh; /* Increase by another 10%: 31.5vh * 1.10 = 34.65vh */
        }
        /* Reduce icons on first and last page by 10% */
        .onboarding-page[data-page="1"] .onboarding-icon img,
        .onboarding-page[data-page="7"] .onboarding-icon img {
          width: 27vw !important; /* Reduce by 10%: 30vw * 0.9 = 27vw */
          max-width: 27vw !important;
          max-height: 27vw !important;
          min-width: 27vw !important;
        }
      }
      /* Short screens: Reduce body text font size and width for better balance */
      @media (max-width: 768px) and (max-height: 700px) {
        .onboarding-page[data-page="2"] .onboarding-features,
        .onboarding-page[data-page="3"] .onboarding-features,
        .onboarding-page[data-page="4"] .onboarding-features,
        .onboarding-page[data-page="5"] .onboarding-features,
        .onboarding-page[data-page="6"] .onboarding-features {
          /* Reduce width to 85% of current: current is 8.33vw on each side, so 85% = 7.08vw on each side */
          /* Or: increase margins by 15%: 8.33vw * 1.15 = 9.58vw on each side */
          left: 9.58vw; /* Increase left margin by 15% to reduce width to 85% */
          right: 9.58vw; /* Increase right margin by 15% to reduce width to 85% */
        }
        .onboarding-page[data-page="2"] .onboarding-features li,
        .onboarding-page[data-page="3"] .onboarding-features li,
        .onboarding-page[data-page="4"] .onboarding-features li,
        .onboarding-page[data-page="5"] .onboarding-features li,
        .onboarding-page[data-page="6"] .onboarding-features li {
          font-size: 12px !important; /* Reduced from 14px (85% of 14px = 11.9px, rounded to 12px) */
          margin-bottom: 10px; /* Slightly reduced spacing */
        }
      }
      /* Very short screens: Further adjust screenshot size (increase by 5%) and reduce icons */
      @media (max-width: 768px) and (max-height: 600px) {
        .onboarding-page[data-page="2"] .onboarding-screenshot,
        .onboarding-page[data-page="3"] .onboarding-screenshot,
        .onboarding-page[data-page="4"] .onboarding-screenshot,
        .onboarding-page[data-page="5"] .onboarding-screenshot,
        .onboarding-page[data-page="6"] .onboarding-screenshot {
          width: calc((100vw - 2 * (100vw / 12)) * 0.75075); /* Increase by another 10%: 68.25% * 1.10 = 75.075% */
          max-width: calc((100vw - 2 * (100vw / 12)) * 0.75075);
          max-height: 28.875vh; /* Increase by another 10%: 26.25vh * 1.10 = 28.875vh */
        }
        .onboarding-page[data-page="2"] .onboarding-screenshot img,
        .onboarding-page[data-page="3"] .onboarding-screenshot img,
        .onboarding-page[data-page="4"] .onboarding-screenshot img,
        .onboarding-page[data-page="5"] .onboarding-screenshot img,
        .onboarding-page[data-page="6"] .onboarding-screenshot img {
          max-height: 28.875vh; /* Increase by another 10%: 26.25vh * 1.10 = 28.875vh */
        }
        /* Reduce icons on first and last page by 10% */
        .onboarding-page[data-page="1"] .onboarding-icon img,
        .onboarding-page[data-page="7"] .onboarding-icon img {
          width: 27vw !important; /* Reduce by 10%: 30vw * 0.9 = 27vw */
          max-width: 27vw !important;
          max-height: 27vw !important;
          min-width: 27vw !important;
        }
        .onboarding-page[data-page="2"] .onboarding-features,
        .onboarding-page[data-page="3"] .onboarding-features,
        .onboarding-page[data-page="4"] .onboarding-features,
        .onboarding-page[data-page="5"] .onboarding-features,
        .onboarding-page[data-page="6"] .onboarding-features {
          left: 9.58vw; /* Increase left margin by 15% to reduce width to 85% */
          right: 9.58vw; /* Increase right margin by 15% to reduce width to 85% */
        }
        .onboarding-page[data-page="2"] .onboarding-features li,
        .onboarding-page[data-page="3"] .onboarding-features li,
        .onboarding-page[data-page="4"] .onboarding-features li,
        .onboarding-page[data-page="5"] .onboarding-features li,
        .onboarding-page[data-page="6"] .onboarding-features li {
          font-size: 11px !important; /* Further reduced from 12px */
          margin-bottom: 8px; /* Further reduced spacing */
        }
      }
    }
    /* Tablet: Pages 2-6 screenshot and features positioning */
    @media (min-width: 769px) and (max-width: 1024px) {
      /* Pages 2-6: Screenshot positioned in middle between title and body text, doubled in size, centered horizontally */
      .onboarding-page[data-page="2"] .onboarding-screenshot,
      .onboarding-page[data-page="3"] .onboarding-screenshot,
      .onboarding-page[data-page="4"] .onboarding-screenshot,
      .onboarding-page[data-page="5"] .onboarding-screenshot,
      .onboarding-page[data-page="6"] .onboarding-screenshot {
        position: absolute;
        top: 33.335vh; /* Keep center position unchanged */
        left: 50%; /* Center horizontally */
        transform: translate(-50%, -50%); /* Center both horizontally and vertically */
        width: 95%; /* Increased width to allow larger screenshots (was 83.333%) */
        max-width: 95%; /* Constrain to container */
        height: auto;
        max-height: 40vh; /* Double the max-height: 2 * 20vh = 40vh */
        margin-bottom: 0;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        background: transparent !important;
        border: none;
      }
      .onboarding-page[data-page="2"] .onboarding-screenshot img,
      .onboarding-page[data-page="3"] .onboarding-screenshot img,
      .onboarding-page[data-page="4"] .onboarding-screenshot img,
      .onboarding-page[data-page="5"] .onboarding-screenshot img,
      .onboarding-page[data-page="6"] .onboarding-screenshot img {
        width: 100%;
        height: auto;
        max-width: 100%;
        max-height: 40vh; /* Double the max-height: 2 * 20vh = 40vh */
        object-fit: contain;
        background: transparent !important;
        border: none;
        border-radius: 0;
        box-shadow: none;
        display: block;
      }
      /* Pages 2-6: Features list - positioned below screenshot, middle between screenshot bottom and next button top */
      .onboarding-page[data-page="2"] .onboarding-features,
      .onboarding-page[data-page="3"] .onboarding-features,
      .onboarding-page[data-page="4"] .onboarding-features,
      .onboarding-page[data-page="5"] .onboarding-features,
      .onboarding-page[data-page="6"] .onboarding-features {
        position: absolute;
        /* Screenshot center is at 33.335vh with translateY(-50%), so screenshot extends from ~23vh to ~43vh */
        /* To be safe, ensure body text starts below screenshot: use 50vh as starting point */
        /* Next button bottom is at 22.22vh from bottom = 77.78vh from top, button top is around 74-75vh */
        /* Middle point between screenshot bottom (50vh) and button top (75vh): (50vh + 75vh) / 2 = 62.5vh */
        top: 62.5vh; /* Middle between screenshot bottom (50vh) and next button top (75vh) */
        left: calc(100% / 12); /* 1/12 of container width from left */
        right: calc(100% / 12); /* 1/12 of container width from right */
        width: auto;
        padding: 0;
        margin-bottom: 0;
        max-width: none;
        box-sizing: border-box;
        transform: translateY(-50%); /* Center vertically in the space */
        z-index: 10; /* Ensure body text is above screenshot */
      }
      .onboarding-page[data-page="2"] .onboarding-features li,
      .onboarding-page[data-page="3"] .onboarding-features li,
      .onboarding-page[data-page="4"] .onboarding-features li,
      .onboarding-page[data-page="5"] .onboarding-features li,
      .onboarding-page[data-page="6"] .onboarding-features li {
        font-size: 20px !important; /* Increased font size for tablet */
        margin-bottom: 18px; /* Increased spacing */
        line-height: 1.7; /* Slightly increased line height for better readability */
      }
    }
    /* Features List */
    .onboarding-features {
      list-style: none;
      padding: 0;
      margin: 0 0 40px 0;
      text-align: left;
      max-width: 500px;
      width: 100%;
    }
    .onboarding-features li {
      font-size: 16px;
      color: #0f172a;
      line-height: 1.6;
      margin-bottom: 16px;
      padding-left: 32px;
      position: relative;
    }
    .onboarding-features li::before {
      content: '✓';
      position: absolute;
      left: 0;
      color: #0f172a;
      font-weight: 600;
      font-size: 18px;
    }
    @media (max-width: 768px) {
      .onboarding-features {
        margin-bottom: 32px;
        padding: 0 16px;
      }
      .onboarding-features li {
        font-size: 14px;
        margin-bottom: 12px;
        padding-left: 28px;
      }
      /* Pages 2-6: Features list with 1/12 screen width padding on each side */
      .onboarding-page[data-page="2"] .onboarding-features,
      .onboarding-page[data-page="3"] .onboarding-features,
      .onboarding-page[data-page="4"] .onboarding-features,
      .onboarding-page[data-page="5"] .onboarding-features,
      .onboarding-page[data-page="6"] .onboarding-features {
        position: absolute;
        top: 55.56vh; /* Below screenshot (5/9 from top) */
        left: 8.33vw; /* 1/12 of screen width from left */
        right: 8.33vw; /* 1/12 of screen width from right */
        width: auto; /* Auto width to respect left/right */
        padding: 0;
        margin-bottom: 0;
        max-width: none;
        box-sizing: border-box;
      }
    }
    /* Buttons */
    .onboarding-next-btn,
    .onboarding-get-started-btn {
      background: #2563eb;
      color: #ffffff;
      border: none;
      padding: 14px 32px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-family: Inter, sans-serif;
      min-width: 120px;
      margin-top: 0;
    }
    /* First and last page buttons - percentage-based sizing */
    .onboarding-page[data-page="1"] .onboarding-next-btn,
    .onboarding-page[data-page="7"] .onboarding-get-started-btn {
      padding: 2vh 6vw; /* 2% viewport height × 6% viewport width */
      font-size: 2.2vw; /* Responsive to viewport width */
      min-width: 45%; /* 45% of container width */
      width: 45%;
      margin-top: 0;
      margin-bottom: 1.8vh; /* ~1.8% of viewport height */
      border-radius: 10px;
    }
    .onboarding-next-btn:hover,
    .onboarding-get-started-btn:hover {
      background: #1d4ed8;
    }
    .onboarding-next-btn:active,
    .onboarding-get-started-btn:active {
      transform: scale(0.98);
    }
    @media (max-width: 768px) {
      .onboarding-next-btn,
      .onboarding-get-started-btn {
        padding: 1.5vh 5vw;
        font-size: 3.8vw;
      }
      /* First and last page buttons - positioned 2/9 from bottom, 1/2 width, shorter height */
      .onboarding-page[data-page="1"] .onboarding-next-btn,
      .onboarding-page[data-page="7"] .onboarding-get-started-btn {
        position: absolute;
        bottom: 22.22vh; /* 2/9 from bottom = 100vh - (2/9 * 100vh) = 77.78vh from top, but using bottom: 22.22vh */
        left: 50%;
        transform: translateX(-50%);
        padding: 1.4vh 8vw; /* Reduced from 2vh to 1.4vh for shorter height */
        font-size: 4.2vw;
        min-width: 36%; /* 1/2 of 72% = 36% */
        width: 36%;
        margin-bottom: 0;
        z-index: 100; /* Ensure buttons are clickable */
        pointer-events: auto; /* Ensure clicks work */
      }
      /* Page 7 Get Started button - longer to fit text in one line */
      .onboarding-page[data-page="7"] .onboarding-get-started-btn {
        min-width: 50% !important; /* Longer width to fit "Get Started" text in one line */
        width: 50% !important; /* Override the 36% width */
      }
      /* Pages 2-6: Apply same button styling as pages 1 and 7 - force absolute positioning */
      .onboarding-page[data-page="2"] .onboarding-next-btn,
      .onboarding-page[data-page="3"] .onboarding-next-btn,
      .onboarding-page[data-page="4"] .onboarding-next-btn,
      .onboarding-page[data-page="5"] .onboarding-next-btn,
      .onboarding-page[data-page="6"] .onboarding-next-btn {
        position: absolute !important; /* Force absolute positioning to match pages 1 and 7 */
        bottom: 22.22vh !important; /* Same position as page 1 and 7 (2/9 from bottom) */
        left: 50% !important;
        transform: translateX(-50%) !important;
        padding: 1.4vh 8vw !important; /* Same padding as pages 1 and 7 */
        font-size: 4.2vw !important;
        min-width: 36% !important; /* Same width as pages 1 and 7 */
        width: 36% !important;
        margin-bottom: 0 !important;
        margin-top: 0 !important;
        z-index: 100 !important; /* Ensure buttons are clickable */
        pointer-events: auto !important; /* Ensure clicks work */
      }
      /* Pages 2-6: Skip button styling - same position as pages 1 and 7 */
      .onboarding-page[data-page="2"] .onboarding-skip-btn,
      .onboarding-page[data-page="3"] .onboarding-skip-btn,
      .onboarding-page[data-page="4"] .onboarding-skip-btn,
      .onboarding-page[data-page="5"] .onboarding-skip-btn,
      .onboarding-page[data-page="6"] .onboarding-skip-btn {
        position: absolute !important; /* Force absolute positioning to match pages 1 and 7 */
        bottom: 18.15vh !important; /* Same position as page 1 and 7 (1/3 between Next button and dots) */
        left: 50% !important;
        transform: translateX(-50%) !important;
        font-size: 3.2vw !important;
        font-weight: 500 !important;
        font-style: normal !important;
        letter-spacing: 0.02em !important;
        margin-top: 0 !important;
        padding: 1vh 3vw !important;
        text-align: center !important;
        color: #94a3b8 !important; /* Gray color - same as pages 1 and 7 */
        font-family: 'Montserrat', 'Mont', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif !important;
        z-index: 100 !important; /* Ensure it's clickable */
      }
      .onboarding-page[data-page="2"] .onboarding-skip-btn:hover,
      .onboarding-page[data-page="3"] .onboarding-skip-btn:hover,
      .onboarding-page[data-page="4"] .onboarding-skip-btn:hover,
      .onboarding-page[data-page="5"] .onboarding-skip-btn:hover,
      .onboarding-page[data-page="6"] .onboarding-skip-btn:hover {
        color: #64748b; /* Slightly darker gray on hover */
      }
    }
    /* Tablet sizing for buttons - same proportional logic as mobile */
    @media (min-width: 769px) and (max-width: 1024px) {
      /* First and last page buttons - positioned 2/9 from bottom */
      .onboarding-page[data-page="1"] .onboarding-next-btn,
      .onboarding-page[data-page="7"] .onboarding-get-started-btn {
        position: absolute;
        bottom: 22.22vh; /* 2/9 from bottom, same as mobile */
        left: 50%;
        transform: translateX(-50%);
        padding: 1.4vh 6vw; /* Adjusted for tablet */
        font-size: 2.8vw;
        min-width: 36%; /* Same proportion as mobile */
        width: 36%;
        margin-bottom: 0;
        z-index: 100;
        pointer-events: auto;
      }
      /* Page 7 Get Started button - longer to fit text */
      .onboarding-page[data-page="7"] .onboarding-get-started-btn {
        min-width: 50% !important;
        width: 50% !important;
      }
      /* Pages 2-6: Next button - same position as page 1 */
      .onboarding-page[data-page="2"] .onboarding-next-btn,
      .onboarding-page[data-page="3"] .onboarding-next-btn,
      .onboarding-page[data-page="4"] .onboarding-next-btn,
      .onboarding-page[data-page="5"] .onboarding-next-btn,
      .onboarding-page[data-page="6"] .onboarding-next-btn {
        position: absolute !important;
        bottom: 22.22vh !important; /* Same position as page 1 */
        left: 50% !important;
        transform: translateX(-50%) !important;
        padding: 1.4vh 6vw !important;
        font-size: 2.8vw !important;
        min-width: 36% !important;
        width: 36% !important;
        margin-bottom: 0 !important;
        margin-top: 0 !important;
        z-index: 100 !important;
        pointer-events: auto !important;
      }
      /* Pages 2-6: Skip button - 1/3 between Next and dots */
      .onboarding-page[data-page="2"] .onboarding-skip-btn,
      .onboarding-page[data-page="3"] .onboarding-skip-btn,
      .onboarding-page[data-page="4"] .onboarding-skip-btn,
      .onboarding-page[data-page="5"] .onboarding-skip-btn,
      .onboarding-page[data-page="6"] .onboarding-skip-btn {
        position: absolute !important;
        bottom: 18.15vh !important; /* 1/3 between Next (22.22vh) and dots (10vh) */
        left: 50% !important;
        transform: translateX(-50%) !important;
        font-size: 2.2vw !important;
        font-weight: 500 !important;
        letter-spacing: 0.02em !important;
        margin-top: 0 !important;
        padding: 0.8vh 2.5vw !important;
        text-align: center !important;
        color: #94a3b8 !important;
        font-family: 'Montserrat', 'Mont', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif !important;
      }
      /* First and last page skip button */
      .onboarding-page[data-page="1"] .onboarding-skip-btn,
      .onboarding-page[data-page="7"] .onboarding-skip-btn {
        position: absolute;
        bottom: 18.15vh; /* Same position as pages 2-6 */
        left: 50%;
        transform: translateX(-50%);
        font-size: 2.2vw;
        font-weight: 500;
        letter-spacing: 0.02em;
        color: #94a3b8;
        font-family: 'Montserrat', 'Mont', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      }
    }
    /* Pagination Dots */
    .onboarding-pagination {
      position: absolute;
      bottom: calc(6.05vh + env(safe-area-inset-bottom, 0px) + 3vh); /* 2/3 distance from Skip + safe area + extra space for Chrome bottom bar */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 0;
      padding: 0 20px;
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 1.5vh); /* Extra padding for browser UI */
      z-index: 10;
    }
    .onboarding-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #CBD5E1;
      cursor: pointer;
      transition: all 0.3s ease;
      flex-shrink: 0;
    }
    .onboarding-dot.active {
      width: 32px;
      height: 8px;
      border-radius: 4px;
      background: #2563eb;
    }
    @media (max-width: 768px) {
      .onboarding-pagination {
        bottom: calc(6.05vh + env(safe-area-inset-bottom, 0px) + 3vh) !important; /* 2/3 distance + safe area + extra space for Chrome bottom bar (3vh ~48px on most phones) */
        margin-top: 0; /* Remove margin-top to use bottom positioning */
        padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 1.5vh) !important; /* Extra padding for browser UI */
      }
      .onboarding-dot {
        width: 6px;
        height: 6px;
      }
      .onboarding-dot.active {
        width: 24px;
        height: 6px;
      }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>
<body>
<!-- Onboarding Overlay -->
<div id="onboarding-overlay" class="onboarding-overlay" style="display: none;">
  <div class="onboarding-container">
    <!-- Back Button (pages 2-6) -->
    <button class="onboarding-back-btn" id="onboarding-back-btn" aria-label="Go back" style="display: none;">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
    </button>
    
    <!-- Pages Container -->
    <div class="onboarding-pages" id="onboarding-pages">
      <!-- Page 1: Welcome -->
      <div class="onboarding-page active" data-page="1">
        <div class="onboarding-icon">
          <img src="onboarding-assets/onboarding-page-1-icon.png" alt="Welcome icon" />
        </div>
        <h2 class="onboarding-title">Welcome to<br>U.S. College Map</h2>
        <p class="onboarding-description">
          <span>A simpler way to explore U.S. colleges.</span>
          <span>Search, filter, save, plan routes, and share<br>— all on one clear, easy map.</span>
        </p>
        <button class="onboarding-next-btn" onclick="onboardingNext()">Next</button>
        <button class="onboarding-skip-btn" onclick="onboardingSkip()">Skip to Website</button>
      </div>
      
      <!-- Page 2: For Early Exploration -->
      <div class="onboarding-page" data-page="2">
        <h2 class="onboarding-title">For Early Exploration</h2>
        <div class="onboarding-screenshot">
          <img src="onboarding-assets/onboarding-page-2-screenshot.svg" alt="Map exploration" />
        </div>
        <ul class="onboarding-features">
          <li>See every U.S. college on one map.</li>
          <li>Filter by type, ranking, region, or state to find schools that fit.</li>
          <li>Tap any dot to see key details and the official website.</li>
        </ul>
        <button class="onboarding-next-btn" onclick="onboardingNext()">Next</button>
        <button class="onboarding-skip-btn" onclick="onboardingSkip()">Skip to Website</button>
      </div>
      
      <!-- Page 3: Save Your Picks -->
      <div class="onboarding-page" data-page="3">
        <h2 class="onboarding-title">Save Your Picks</h2>
        <div class="onboarding-screenshot">
          <img src="onboarding-assets/onboarding-page-3-screenshot.svg" alt="Save and compare colleges" />
        </div>
        <ul class="onboarding-features">
          <li>Build your personalized college list.</li>
          <li>See all your favorite schools on one clean map and revisit key details.</li>
          <li>Compare schools side-by-side when you're ready to narrow choices.</li>
        </ul>
        <button class="onboarding-next-btn" onclick="onboardingNext()">Next</button>
        <button class="onboarding-skip-btn" onclick="onboardingSkip()">Skip to Website</button>
      </div>
      
      <!-- Page 4: Find Colleges Nearby -->
      <div class="onboarding-page" data-page="4">
        <h2 class="onboarding-title">Find Nearby Colleges</h2>
        <div class="onboarding-screenshot">
          <img src="onboarding-assets/onboarding-page-4-screenshot.svg" alt="Nearby search" />
        </div>
        <ul class="onboarding-features">
          <li>Explore colleges close to home.</li>
          <li>Discover nearby schools, including community colleges for resources.</li>
          <li>Make the most of upcoming trips, vacations, or tournaments by checking schools near destination.</li>
        </ul>
        <button class="onboarding-next-btn" onclick="onboardingNext()">Next</button>
        <button class="onboarding-skip-btn" onclick="onboardingSkip()">Skip to Website</button>
      </div>
      
      <!-- Page 5: Plan Visit Route -->
      <div class="onboarding-page" data-page="5">
        <h2 class="onboarding-title">Plan Visit Route</h2>
        <div class="onboarding-screenshot">
          <img src="onboarding-assets/onboarding-page-5-screenshot.svg" alt="Route planning" />
        </div>
        <ul class="onboarding-features">
          <li>Enter a start and destination to find colleges along your drive.</li>
          <li>Save schools you plan to visit.</li>
          <li>Open the full trip in Google Maps for navigation, no more manual typing.</li>
        </ul>
        <button class="onboarding-next-btn" onclick="onboardingNext()">Next</button>
        <button class="onboarding-skip-btn" onclick="onboardingSkip()">Skip to Website</button>
      </div>
      
      <!-- Page 6: Share List or Route -->
      <div class="onboarding-page" data-page="6">
        <h2 class="onboarding-title">Share List or Route</h2>
        <div class="onboarding-screenshot">
          <img src="onboarding-assets/onboarding-page-6-screenshot.svg" alt="Sharing feature" />
        </div>
        <ul class="onboarding-features">
          <li>Share your saved colleges with family, counselors, or friends.</li>
          <li>Send your planned route — they'll see the same school visit route.</li>
          <li>Anyone with your link can open the full Google Maps route instantly.</li>
        </ul>
        <button class="onboarding-next-btn" onclick="onboardingNext()">Next</button>
        <button class="onboarding-skip-btn" onclick="onboardingSkip()">Skip to Website</button>
      </div>
      
      <!-- Page 7: You Are Ready -->
      <div class="onboarding-page" data-page="7">
        <div class="onboarding-icon">
          <img src="onboarding-assets/onboarding-page-7-icon.svg" alt="Ready to explore" />
        </div>
        <h2 class="onboarding-title">You Are Ready<br>to Explore!</h2>
        <p class="onboarding-description">
          <span>U.S. College Map (Beta) is built to make<br>college search clearer and easier—<br>for students, families, and educators.</span>
          <span>Try it out, explore at your own pace,<br>and tell us what features you'd love next.</span>
        </p>
        <button class="onboarding-get-started-btn" onclick="onboardingComplete()">Get Started</button>
      </div>
    </div>
    
    <!-- Pagination Dots -->
    <div class="onboarding-pagination">
      <span class="onboarding-dot active" data-page="1"></span>
      <span class="onboarding-dot" data-page="2"></span>
      <span class="onboarding-dot" data-page="3"></span>
      <span class="onboarding-dot" data-page="4"></span>
      <span class="onboarding-dot" data-page="5"></span>
      <span class="onboarding-dot" data-page="6"></span>
      <span class="onboarding-dot" data-page="7"></span>
    </div>
  </div>
</div>

<!-- Shared map banner -->
<div class="shared-map-banner" id="shared-map-banner">
  <div class="shared-map-banner-message">You're viewing a shared map of saved colleges. Your own saved list won't be changed.</div>
  <button class="shared-map-banner-close" id="shared-map-banner-close" aria-label="Close banner" type="button">×</button>
</div>
<div class="main-container">
<header class="app-header">
    <div class="header-logo-tagline">
  <!-- Logo optimization: Ideal source image size ≈ 280×70px (4:1 ratio) for header usage at 70px height on desktop, 56px on mobile -->
  <!-- Using width/height attributes for layout stability and to prevent layout shift during load -->
  <div style="display: flex; align-items: center; position: relative;">
    <img src="us-college-map-logo.png" alt="U.S. College Map interactive tool for exploring colleges by type, region, and location" class="site-logo" width="280" height="70" style="position: relative; z-index: 1;">
    <span class="beta-badge" style="position: relative; z-index: 10000;">BETA</span>
  </div>
      <h1 class="sr-only">U.S. College Map — Find Colleges Near You, Along Your Route, and Save Your List</h1>
      <p class="tagline">Planning campus visits? U.S. College Map helps you explore schools by type, region, or ranking,  and easily find colleges near any location or along any trip.</p>
    </div>
</header>

  <main>
  <nav class="container controls" aria-label="College search filters">
    <div class="row row-filters">
      <div class="pill"><label for="type">Type</label><select id="type"><option value="">All college types</option></select></div>
      <div class="pill"><label for="region">Region</label><select id="region"><option value="">All regions</option></select></div>
      <div class="pill"><label for="state">State</label><select id="state" autocomplete="one-time-code" data-prevent-autofill="true"><option value="">All states</option></select></div>
      <div class="pill pill-ranking"><label for="ranking">Ranking</label><select id="ranking"><option value="">School Ranking</option></select><div class="ranking-new-chat-bubble" id="ranking-new-chat-bubble">NEW!</div><button class="ranking-info-icon" id="ranking-info-btn" aria-label="Ranking information" type="button">i</button><div class="ranking-tooltip" id="ranking-tooltip" role="tooltip"><div class="ranking-tooltip-header"><div class="ranking-tooltip-body">School ranking is for reference only*. Some ranking tiers include extra schools to reflect variations across major lists.</div></div><button class="ranking-tooltip-close" id="ranking-tooltip-close" aria-label="Close" type="button">x</button></div></div>
      <!-- College name search temporarily hidden - functionality preserved for future use -->
      <div class="pill pill-search" style="display: none !important;"><label for="search">Search</label><input id="search" placeholder="Enter college name" /></div>
  </div>
    <div class="row row-search" style="display: none !important;">
      <div class="pill"><label for="search-mobile">Search</label><input id="search-mobile" placeholder="Enter college name" /></div>
  </div>
    <div class="row row-ranking">
      <!-- Ranking will be moved here on mobile via JavaScript -->
</div>

    <details class="filter-section">
      <summary>Find Colleges Nearby</summary>
      <div class="filter-section-content">
        <div class="row row-nearby">
          <div class="pill address-autocomplete"><label for="address">Address</label><input id="address" placeholder="Enter a location or home address" autocomplete="new-password" name="search-address" data-autofill-guard="true" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-autocomplete="list" aria-expanded="false" aria-controls="addressSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="addressSuggestions" role="listbox" aria-label="Address suggestions"></div></div>
    <div class="pill"><label for="radius">Radius</label><input id="radius" type="number" min="0" step="10" value="30" style="width:90px"><select id="units"><option value="mi" selected>mi</option><option value="km">km</option></select><button id="geocodeBtn">Locate</button><button id="clearRadius" style="background:transparent;color:#0f172a;border:1px solid #e2e8f0;">Clear</button></div>
</div>
</div>
    </details>
    
    <details class="filter-section">
      <summary>Find Colleges Along a Route</summary>
      <div class="filter-section-content">
        <div class="row row-route">
          <div class="pill address-autocomplete"><label for="routeStart">From</label><input id="routeStart" placeholder="Enter starting address" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-autocomplete="list" aria-expanded="false" aria-controls="routeStartSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="routeStartSuggestions" role="listbox" aria-label="From address suggestions"></div></div>
          <div class="pill address-autocomplete"><label for="routeEnd">To</label><input id="routeEnd" placeholder="Enter destination address" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-autocomplete="list" aria-expanded="false" aria-controls="routeEndSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="routeEndSuggestions" role="listbox" aria-label="To address suggestions"></div></div>
          <div class="pill"><label for="routeMaxDistance">Within</label><input id="routeMaxDistance" type="number" min="0" step="10" value="30" style="width:90px"><select id="routeUnits"><option value="mi" selected>mi</option><option value="km">km</option></select><button id="findRouteBtn">Explore</button><button id="clearRoute" style="background:transparent;color:#0f172a;border:1px solid #e2e8f0;">Clear</button></div>
        </div>
      </div>
    </details>
  </nav>
  <div class="route-hint-bubble" id="route-hint-bubble">
      <div class="route-hint-bubble-content">
        <span class="route-hint-bubble-text">Tap to explore</span>
      </div>
    </div>
  <section id="map" aria-label="Interactive college map">
    <!-- Smart map hint popups -->
    <div class="map-hint-bubble" id="hint-too-many-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">🎯</span>
        <div class="map-hint-bubble-title">Too many colleges shown?</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('tooMany')">×</button>
      </div>
      <div class="map-hint-bubble-body">Filter by Type above or save your favorite schools to your list to focus your map.</div>
    </div>
    <div class="map-hint-bubble" id="hint-no-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">🔍</span>
        <div class="map-hint-bubble-title">No colleges found?</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('noResults')">×</button>
      </div>
      <div class="map-hint-bubble-body">Your current filters may be too narrow, or none of your saved colleges fall within this location or route.</div>
    </div>
    <!-- No saved colleges notice - appears when Saved Only is toggled on with zero saved colleges -->
    <div class="map-hint-bubble" id="hint-no-saved-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">📌</span>
        <div class="map-hint-bubble-title">No saved colleges</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('noSavedColleges')">×</button>
      </div>
      <div class="map-hint-bubble-body">Go to "My Saved List" or tap a college on the map and press "Save" to add a school.</div>
    </div>
    <!-- Teaching moment hint for Map Saved Only toggle (one-time) -->
    <div class="map-hint-bubble" id="hint-saved-only-teaching" role="alert" style="display: none;">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">💡</span>
        <div class="map-hint-bubble-title">Map Saved Only</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissSavedOnlyTeachingHint()">×</button>
      </div>
      <div class="map-hint-bubble-body">Turn this ON to show only your saved colleges on the map.</div>
    </div>
    <!-- Helper tip bubble - appears once per session -->
    <div class="map-tip-bubble" id="map-tip-bubble" role="alert">
      <div class="map-tip-bubble-content">
        <span class="map-tip-bubble-icon">💡</span>
        <span class="map-tip-bubble-text">Tap a blue dot on the map to see college details or save to your list.</span>
        <button class="map-tip-bubble-close" aria-label="Dismiss tip" onclick="dismissMapTip()">×</button>
      </div>
    </div>
    <div class="legend" id="legend">Found <span id="count">0</span> schools</div>
    <!-- Saved controls overlay -->
    <div id="saved-controls" class="saved-controls">
      <div class="saved-list-section" onclick="openSavedListPanel()" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();openSavedListPanel();}" role="button" tabindex="0">
        <svg class="saved-icon" width="22" height="22" viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path fill="#64D85B" d="M128 0C74 0 32 42 32 96C32 166 128 256 128 256C128 256 224 166 224 96C224 42 182 0 128 0Z"/>
          <path fill="#FFFFFF" d="M128 32L147 86H200L159 118L175 170L128 139L81 170L97 118L56 86H109L128 32Z"/>
        </svg>
        <span class="saved-count-x" id="saved-pill-count-x"></span>
        <span class="saved-count" id="saved-pill-count"></span>
        <span class="saved-pill"><span class="saved-text">My Saved List</span></span>
      </div>
      <div class="saved-controls-divider"></div>
      <div class="saved-only-section" id="saved-only-section">
        <div class="saved-only-main" onclick="toggleSavedOnly()">
          <div class="saved-toggle" id="saved-toggle">
            <div class="saved-toggle-track">
              <div class="saved-toggle-thumb"></div>
            </div>
          </div>
          <span class="saved-text">Map Saved Only</span>
        </div>
        <div class="saved-only-divider"></div>
        <div class="saved-navigation-icon" id="saved-navigation-icon" onclick="planRouteWithSavedColleges()">
          <div class="saved-navigation-tooltip">Plan driving route</div>
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 6L9 4L15 6L21 4V18L15 20L9 18L3 20V6Z" fill="none" stroke="#1d4ed8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M9 4V18M15 6V20" fill="none" stroke="#1d4ed8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M3 6L9 4L15 6M3 20L9 18L15 20" fill="none" stroke="#1d4ed8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div class="saved-share-icon" id="saved-share-icon" onclick="handleSavedShareClick(event)">
          <div class="saved-share-tooltip">Share this saved map</div>
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
          </svg>
        </div>
      </div>
    </div>
    <!-- Filter chips -->
    <div id="filter-chips" class="filter-chips"></div>
    <!-- Saved Colleges Overlay -->
    <div id="saved-colleges-overlay" class="saved-colleges-overlay" onclick="handleSavedOverlayBackdropClick(event)">
      <div class="saved-colleges-modal" onclick="event.stopPropagation()">
        <div class="saved-overlay-header">
          <div class="saved-overlay-title-section">
            <h2 class="saved-overlay-title" id="saved-overlay-title">My Saved Colleges</h2>
          </div>
          <div class="saved-overlay-header-actions">
            <button id="saved-print-btn" class="saved-print-btn" onclick="printCompareTable()" style="display: none;">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="6 9 6 2 18 2 18 9"></polyline>
                <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path>
                <rect x="6" y="14" width="12" height="8"></rect>
              </svg>
            </button>
            <button id="saved-back-btn" class="saved-back-btn" onclick="closeCompareMode()" style="display: none;">↩</button>
            <button class="saved-overlay-close" id="saved-overlay-close-btn" onclick="closeSavedListPanel()" aria-label="Close saved colleges panel">×</button>
          </div>
        </div>
        <div class="saved-overlay-content">
          <!-- Saved List View -->
          <div id="saved-list-view" class="saved-list-view visible">
            <!-- Search & Add Section -->
            <div class="saved-overlay-section">
              <h3 class="saved-section-title">Add a college to my saved list</h3>
              <div class="saved-search-wrapper">
                <svg class="saved-search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                </svg>
                <input 
                  type="text" 
                  id="saved-search-input" 
                  class="saved-search-input" 
                  placeholder="Search by college name…"
                  autocomplete="off"
                />
                <div id="saved-search-results" class="saved-search-results"></div>
              </div>
            </div>
            <!-- Saved List Section -->
            <div class="saved-overlay-section">
              <div class="saved-section-header">
                <h3 class="saved-section-title" id="saved-overlay-count">0 Colleges Saved</h3>
                <button id="unsave-all-btn" class="unsave-all-btn" onclick="confirmUnsaveAll()" style="display: none;">Unsave all</button>
              </div>
              <div id="saved-colleges-list" class="saved-colleges-list">
                <!-- Will be populated by JavaScript -->
              </div>
            </div>
            <!-- Actions Section -->
            <div class="saved-overlay-section saved-actions">
              <button id="saved-compare-btn-section" class="saved-primary-btn" onclick="openCompareMode()">Compare Colleges</button>
              <button class="saved-secondary-btn" onclick="closeSavedListPanel()">Cancel</button>
            </div>
          </div>
          <!-- Compare View -->
          <div id="saved-compare-view" class="saved-compare-view">
            <div class="saved-compare-table-wrapper">
              <table class="saved-compare-table" id="saved-compare-table">
                <!-- Will be populated by JavaScript -->
              </table>
            </div>
            <div class="saved-compare-disclaimer">
              Disclaimer: School information provided on this site is for general reference and may be incomplete or out of date. Details such as tuition, enrollment, and acceptance rate can change at any time. Students and families should always verify the latest information directly on each college's official website when making decisions.
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Route Planner Modal -->
    <div id="route-planner-overlay" class="route-planner-overlay" onclick="handleRoutePlannerBackdropClick(event)">
      <div class="route-planner-modal" onclick="event.stopPropagation()">
        <div class="route-planner-header">
        <div class="route-planner-title-section">
          <div class="route-planner-icon-wrapper">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="route-planner-icon">
              <path d="M3 6L9 4L15 6L21 4V18L15 20L9 18L3 20V6Z" fill="none" stroke="#1d4ed8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M9 4V18M15 6V20" fill="none" stroke="#1d4ed8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M3 6L9 4L15 6M3 20L9 18L15 20" fill="none" stroke="#1d4ed8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <div>
            <h2 class="route-planner-title">Driving Route Planning</h2>
            <p class="route-planner-subtitle">Review the trip with your saved colleges below and your route is ready to open in Google Maps.</p>
          </div>
        </div>
        <button class="route-planner-close" onclick="closeRoutePlanner()" aria-label="Close route planner">×</button>
      </div>
        <div class="route-planner-content">
        <!-- Section A: Route Summary -->
        <div class="route-planner-section">
          <div class="route-summary">
            <div class="route-summary-item">
              <span class="route-summary-label">From:</span>
              <span class="route-summary-value" id="route-planner-from">-</span>
            </div>
            <div class="route-summary-item">
              <span class="route-summary-label">To:</span>
              <span class="route-summary-value" id="route-planner-to">-</span>
            </div>
          </div>
        </div>
        
        <!-- Section B: Saved Colleges on Route -->
        <div class="route-planner-section">
          <h3 class="route-planner-section-title" id="route-planner-colleges-title">College stops on this route</h3>
          <p class="route-planner-section-subtitle">Uncheck any colleges you don't want to include.</p>
          <div id="route-planner-colleges-list" class="route-planner-colleges-list">
            <!-- Will be populated by JavaScript -->
          </div>
        </div>
        
        <!-- Section C: Actions -->
        <div class="route-planner-section route-planner-actions">
          <div id="route-planner-error" class="route-planner-error" style="display: none;">Select at least one college stop to see a route.</div>
          <button id="route-planner-google-maps-btn" class="route-planner-primary-btn" onclick="openRouteInGoogleMaps()">
            See Route in Google Maps
          </button>
          <button class="route-planner-cancel-btn" onclick="closeRoutePlanner()">Cancel</button>
        </div>
      </div>
      </div>
    </div>
    <!-- Share Overlay Modal -->
    <div id="share-overlay" class="share-overlay" onclick="handleShareOverlayBackdropClick(event)">
      <div class="share-modal" onclick="event.stopPropagation()">
        <div class="share-header">
          <div class="share-title-section">
            <div class="share-icon-wrapper">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="share-icon">
                <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
              </svg>
            </div>
            <div>
              <h2 class="share-title">Share Your Saved Colleges</h2>
              <p class="share-subtitle">Create a link to share this map of your saved colleges.</p>
            </div>
          </div>
          <button class="share-close" onclick="closeShareOverlay()" aria-label="Close share overlay">×</button>
        </div>
        <div class="share-content">
          <!-- Summary Section -->
          <div class="share-section">
            <div class="share-summary" id="share-summary">
              <!-- Will be populated by JavaScript -->
            </div>
          </div>
          
          <!-- Preview Section -->
          <div class="share-section">
            <div class="share-preview" id="share-preview">
              <!-- Will be populated by JavaScript -->
            </div>
          </div>
          
          <!-- Actions Section -->
          <div class="share-section share-actions">
            <p class="share-explanation">Anyone with the link can view this map, but they can't edit your saved list.</p>
            <button id="share-copy-btn" class="share-primary-btn" onclick="handleShareCopyClick()">
              Copy Share Link
            </button>
            <button class="share-secondary-btn" onclick="closeShareOverlay()">Close</button>
          </div>
        </div>
      </div>
    </div>
    <!-- Unsave All Confirmation Modal -->
    <div id="unsave-all-modal" class="saved-modal-overlay">
      <div class="saved-modal">
        <h3 class="saved-modal-title">Remove all saved colleges?</h3>
        <div class="saved-modal-actions">
          <button class="saved-modal-btn saved-modal-cancel" onclick="closeUnsaveAllModal()">Cancel</button>
          <button class="saved-modal-btn saved-modal-confirm" onclick="unsaveAllColleges()">Unsave all</button>
        </div>
      </div>
    </div>
  </section>
<div aria-label="College map powered by OpenStreetMap data" class="sr-only"></div>
  <div class="loading" id="loading">Loading colleges data...</div>
  <div class="error" id="error"></div>
  
  <section class="about-map">
    <h2 class="about-map-title">About This Map</h2>
    <div class="about-map-video">
      <div class="about-map-video-wrapper">
        <iframe id="intro-video-iframe" src="https://www.youtube.com/embed/caAXVrA2Klw" title="U.S. College Map Introduction" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
      </div>
    </div>
    <div class="info-snippets" aria-label="College visit planning resources">
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Explore and find colleges by region</h2>
        <p>When you're just starting out, it helps to see the big picture. U.S. College Map lets you explore every college across the country — by state, region, or school type — so you can spot patterns, compare areas, and learn what kinds of campuses appeal to you. Tap any school to check out basic details and start building a sense of what's out there.</p>
      </div>
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Visit colleges near you or along your route</h2>
        <p>Heading out for a family trip, tournament, or vacation? Enter any address or route to see colleges nearby or along the way. You might discover schools you've never heard of but end up loving. This makes campus visits easy, low-stress, and part of the travel you're already doing — no extra planning required.</p>
      </div>
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Save colleges and plan focused visit trips</h2>
        <p>After exploring and visiting a few campuses, save your favorite schools to your list. Then switch to Saved-Only mode to see just those colleges on the map. It's perfect for planning intentional visit trips to groups of schools that are close together — whether you're flying out for a weekend or mapping out a bigger college-visit road trip.</p>
      </div>
    </div>
  </section>
  <p class="site-disclaimer"><strong>Disclaimer:</strong><br><br>* School ranking on U.S. College Map are for general reference only and are not official rankings. They reflect schools that commonly appear near the top of well-known national lists, but they are not based on any single ranking system. Some tiers include additional schools to account for natural year-to-year differences across sources.<br><br>** School information provided on this site is also for general reference and may be incomplete or out of date. Details such as tuition, enrollment, and selectivity can change at any time. Students and families should always verify the latest information directly on each college's official website when making decisions.</p>
  </main>
</div>
<footer class="site-footer">© 2025 U.S. College Map | <a href="mailto:contact@uscollegemap.org" id="contact-email-link">Contact Us</a></footer>

<script>
// ============================================================================
// ONBOARDING SYSTEM
// ============================================================================
const ONBOARDING_STORAGE_KEY = 'ucm_onboarding_completed_v1';

// Define debug functions immediately so they're always available
(function() {
  'use strict';
  
  // Debug function - define early
  window.debugOnboarding = function() {
    try {
      const width = window.innerWidth;
      const ua = navigator.userAgent || '';
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      const isIPad = /iPad/.test(ua) || (ua.includes('Mac') && navigator.maxTouchPoints > 1);
      const isMobileUA = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
      const deviceType = typeof detectDeviceTypeForOnboarding === 'function' ? detectDeviceTypeForOnboarding() : (isTouchDevice && !isIPad && (isMobileUA || width <= 900) ? 'mobile' : isTouchDevice && (width <= 1024 || isIPad) ? 'tablet' : 'desktop');
      const hasCompleted = localStorage.getItem(ONBOARDING_STORAGE_KEY) === '1';
      const overlay = document.getElementById('onboarding-overlay');
      
      console.log('=== ONBOARDING DEBUG INFO ===');
      console.log('Screen width:', width);
      console.log('User Agent:', ua);
      console.log('Is Touch Device:', isTouchDevice);
      console.log('Is iPad:', isIPad);
      console.log('Is Mobile UA:', isMobileUA);
      console.log('Detected Device Type:', deviceType);
      console.log('Has Completed:', hasCompleted);
      console.log('Overlay exists:', !!overlay);
      if (overlay) {
        console.log('Overlay display:', overlay.style.display);
        console.log('Overlay has active class:', overlay.classList.contains('active'));
      }
      const shouldShow = typeof shouldShowOnboarding === 'function' ? shouldShowOnboarding() : 'function not available';
      console.log('Should Show:', shouldShow);
      console.log('===========================');
      
      return {
        width,
        deviceType,
        hasCompleted,
        shouldShow: shouldShow,
        overlayExists: !!overlay
      };
    } catch (e) {
      console.error('Error in debugOnboarding:', e);
      return { error: e.message };
    }
  };
  
  console.log('[Onboarding] debugOnboarding() function is now available');
})();
let onboardingCurrentPage = 1;
let onboardingTouchStartX = 0;
let onboardingTouchEndX = 0;
let onboardingIsTransitioning = false;

// Simple device detection for onboarding (runs before detectDeviceType is defined)
function detectDeviceTypeForOnboarding() {
  const width = window.innerWidth;
  const ua = navigator.userAgent || '';
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  const isMobileUA = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
  
  // Improved iPad detection: Check for iPad explicitly, but exclude iPhone
  // iPhone user agents include "Mac OS X" but we should check for iPhone first
  const isIPhone = /iPhone/i.test(ua);
  const isIPad = /iPad/.test(ua) || (!isIPhone && ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  // Debug logging (remove in production if needed)
  console.log('[Onboarding Debug]', {
    width,
    isTouchDevice,
    isIPhone,
    isIPad,
    isMobileUA,
    userAgent: ua.substring(0, 50)
  });
  
  // More lenient mobile detection: touch device with mobile UA OR width <= 900
  // Also allow phones with width up to 900px (some modern phones)
  // iPhone should always be detected as mobile
  if (isIPhone || (isTouchDevice && !isIPad && (isMobileUA || width <= 900))) {
    return 'mobile';
  }
  if (isTouchDevice && (width <= 1024 || isIPad)) {
    return 'tablet';
  }
  // Desktop - don't show onboarding
  return 'desktop';
}

// Check if onboarding should be shown (runs immediately, before DOMContentLoaded)
function shouldShowOnboarding() {
  // Check if already completed
  const hasCompleted = localStorage.getItem(ONBOARDING_STORAGE_KEY) === '1';
  if (hasCompleted) {
    console.log('[Onboarding Debug] Already completed');
    return false;
  }
  
  // Check device type - only show on mobile (not tablet or desktop)
  const deviceType = detectDeviceTypeForOnboarding();
  const isMobileOnly = deviceType === 'mobile';
  console.log('[Onboarding Debug] Device type:', deviceType, 'isMobile:', isMobileOnly);
  if (!isMobileOnly) {
    console.log('[Onboarding Debug] Not mobile device, skipping onboarding');
    return false;
  }
  
  // Don't show in shared view
  const isSharedView = window.location.search.includes('view=savedshare');
  if (isSharedView) {
    console.log('[Onboarding Debug] Shared view, skipping onboarding');
    return false;
  }
  
  console.log('[Onboarding Debug] Should show onboarding: YES');
  return true;
}

// Initialize onboarding
function initOnboarding() {
  console.log('[Onboarding Debug] Initializing onboarding...');
  
  if (!shouldShowOnboarding()) {
    console.log('[Onboarding Debug] shouldShowOnboarding returned false, aborting');
    return;
  }
  
  const overlay = document.getElementById('onboarding-overlay');
  if (!overlay) {
    console.error('[Onboarding Debug] Overlay element not found!');
    return;
  }
  
  console.log('[Onboarding Debug] Showing overlay');
  
  // Store original scroll position before locking
  const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
  
  // Show overlay
  overlay.style.display = 'flex';
  overlay.classList.add('active');
  
  // Prevent body and html scroll - more aggressive for Chrome
  document.body.style.overflow = 'hidden';
  document.body.style.position = 'fixed';
  document.body.style.width = '100%';
  document.body.style.height = '100%';
  document.body.style.top = `-${scrollY}px`;
  document.documentElement.style.overflow = 'hidden';
  document.documentElement.style.position = 'fixed';
  document.documentElement.style.width = '100%';
  document.documentElement.style.height = '100%';
  
  // Store scroll position in overlay data attribute for restoration
  overlay.setAttribute('data-scroll-y', scrollY.toString());
  
  // Set initial page
  showOnboardingPage(1);
  
  // Setup event listeners
  setupOnboardingEvents();
  
  // Prevent scroll events on overlay
  overlay.addEventListener('touchmove', (e) => {
    e.preventDefault();
  }, { passive: false });
  
  overlay.addEventListener('wheel', (e) => {
    e.preventDefault();
  }, { passive: false });
  
  overlay.addEventListener('scroll', (e) => {
    e.preventDefault();
    overlay.scrollTop = 0;
  }, { passive: false });
  
  // Track GA event
  if (typeof gtag !== 'undefined') {
    gtag('event', 'onboarding_started', {
      'device_type': detectDeviceTypeForOnboarding()
    });
  }
  
  console.log('[Onboarding Debug] Onboarding initialized successfully');
}

// Show specific onboarding page
function showOnboardingPage(pageNum) {
  const pages = document.querySelectorAll('.onboarding-page');
  const dots = document.querySelectorAll('.onboarding-dot');
  const backBtn = document.getElementById('onboarding-back-btn');
  
  // Update current page
  onboardingCurrentPage = pageNum;
  
  // Update pages
  pages.forEach((page, index) => {
    const pageNumAttr = parseInt(page.getAttribute('data-page'));
    page.classList.remove('active', 'prev', 'next');
    
    if (pageNumAttr === pageNum) {
      page.classList.add('active');
    } else if (pageNumAttr < pageNum) {
      page.classList.add('prev');
    } else {
      page.classList.add('next');
    }
  });
  
  // Update dots
  dots.forEach((dot, index) => {
    const dotPage = parseInt(dot.getAttribute('data-page'));
    dot.classList.toggle('active', dotPage === pageNum);
  });
  
  // Show/hide back button (pages 2-7)
  if (backBtn) {
    backBtn.style.display = (pageNum >= 2 && pageNum <= 7) ? 'flex' : 'none';
  }
  
  // Track page view
  if (typeof gtag !== 'undefined') {
    gtag('event', 'onboarding_page_viewed', {
      'page_number': pageNum
    });
  }
}

// Next page - make globally accessible
function onboardingNext() {
  if (onboardingCurrentPage >= 7 || onboardingIsTransitioning) return;
  
  onboardingIsTransitioning = true;
  const nextPage = onboardingCurrentPage + 1;
  showOnboardingPage(nextPage);
  
  setTimeout(() => {
    onboardingIsTransitioning = false;
  }, 300);
}
window.onboardingNext = onboardingNext;

// Previous page - make globally accessible
function onboardingBack() {
  if (onboardingCurrentPage <= 1 || onboardingIsTransitioning) return;
  
  onboardingIsTransitioning = true;
  const prevPage = onboardingCurrentPage - 1;
  showOnboardingPage(prevPage);
  
  setTimeout(() => {
    onboardingIsTransitioning = false;
  }, 300);
}
window.onboardingBack = onboardingBack;

// Helper function to restore scroll
function restoreScroll() {
  const overlay = document.getElementById('onboarding-overlay');
  const scrollY = overlay ? parseInt(overlay.getAttribute('data-scroll-y') || '0') : 0;
  
  document.body.style.overflow = '';
  document.body.style.position = '';
  document.body.style.width = '';
  document.body.style.height = '';
  document.body.style.top = '';
  document.documentElement.style.overflow = '';
  document.documentElement.style.position = '';
  document.documentElement.style.width = '';
  document.documentElement.style.height = '';
  
  // Restore scroll position
  if (scrollY > 0) {
    window.scrollTo(0, scrollY);
  }
  
  // Clean up
  if (overlay) {
    overlay.removeAttribute('data-scroll-y');
  }
}

// Complete onboarding - make globally accessible
function onboardingComplete() {
  // Mark as completed
  localStorage.setItem(ONBOARDING_STORAGE_KEY, '1');
  
  // Hide overlay
  const overlay = document.getElementById('onboarding-overlay');
  if (overlay) {
    overlay.classList.remove('active');
    setTimeout(() => {
      overlay.style.display = 'none';
      restoreScroll();
    }, 300);
  }
  
  // Track GA event
  if (typeof gtag !== 'undefined') {
    const deviceType = typeof detectDeviceType === 'function' ? detectDeviceType() : detectDeviceTypeForOnboarding();
    gtag('event', 'onboarding_completed', {
      'final_page': onboardingCurrentPage,
      'device_type': deviceType
    });
  }
}
window.onboardingComplete = onboardingComplete;

// Skip onboarding - make globally accessible
function onboardingSkip() {
  // Mark as completed
  localStorage.setItem(ONBOARDING_STORAGE_KEY, '1');
  
  // Hide overlay
  const overlay = document.getElementById('onboarding-overlay');
  if (overlay) {
    overlay.classList.remove('active');
    setTimeout(() => {
      overlay.style.display = 'none';
      restoreScroll();
    }, 300);
  }
  
  // Track GA event
  if (typeof gtag !== 'undefined') {
    const deviceType = typeof detectDeviceType === 'function' ? detectDeviceType() : detectDeviceTypeForOnboarding();
    gtag('event', 'onboarding_skipped', {
      'skipped_at_page': onboardingCurrentPage,
      'device_type': deviceType
    });
  }
}
window.onboardingSkip = onboardingSkip;

// Setup event listeners
function setupOnboardingEvents() {
  // Back button - use event delegation
  document.addEventListener('click', (e) => {
    const backBtn = e.target.closest('#onboarding-back-btn') || e.target.closest('.onboarding-back-btn');
    if (backBtn) {
      e.preventDefault();
      e.stopPropagation();
      onboardingBack(); // Function already checks transition flag
    }
  });
  
  // Skip buttons (now on each page, use event delegation)
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('onboarding-skip-btn')) {
      e.preventDefault();
      e.stopPropagation();
      onboardingSkip();
    }
  });
  
  // Next buttons - use event delegation to ensure they work
  document.addEventListener('click', (e) => {
    const nextBtn = e.target.closest('.onboarding-next-btn');
    if (nextBtn) {
      e.preventDefault();
      e.stopPropagation();
      onboardingNext(); // Function already checks transition flag
    }
  });
  
  // Get Started button - use event delegation
  document.addEventListener('click', (e) => {
    if (e.target.classList.contains('onboarding-get-started-btn') || e.target.closest('.onboarding-get-started-btn')) {
      e.preventDefault();
      e.stopPropagation();
      onboardingComplete();
    }
  });
  
  // Pagination dots
  const dots = document.querySelectorAll('.onboarding-dot');
  dots.forEach(dot => {
    dot.addEventListener('click', () => {
      const pageNum = parseInt(dot.getAttribute('data-page'));
      if (pageNum !== onboardingCurrentPage) {
        showOnboardingPage(pageNum);
      }
    });
  });
  
  // Swipe gestures
  let swipeTouchStartX = 0;
  let swipeTouchEndX = 0;
  
  const pagesContainer = document.getElementById('onboarding-pages');
  if (pagesContainer) {
    pagesContainer.addEventListener('touchstart', (e) => {
      swipeTouchStartX = e.changedTouches[0].screenX;
    }, { passive: true });
    
    pagesContainer.addEventListener('touchend', (e) => {
      swipeTouchEndX = e.changedTouches[0].screenX;
      handleOnboardingSwipe();
    }, { passive: true });
  }
  
  function handleOnboardingSwipe() {
    if (onboardingIsTransitioning) return;
    
    const swipeThreshold = 50;
    const diff = swipeTouchStartX - swipeTouchEndX;
    
    if (Math.abs(diff) > swipeThreshold) {
      if (diff > 0) {
        // Swipe left - next page
        onboardingNext();
      } else {
        // Swipe right - previous page
        onboardingBack();
      }
    }
  }
  
  // Keyboard navigation
  document.addEventListener('keydown', (e) => {
    const overlay = document.getElementById('onboarding-overlay');
    if (!overlay || overlay.style.display === 'none') return;
    
    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
      e.preventDefault();
      onboardingNext();
    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
      e.preventDefault();
      onboardingBack();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      onboardingSkip();
    } else if (e.key === 'Enter' && onboardingCurrentPage === 7) {
      e.preventDefault();
      onboardingComplete();
    }
  });
}

// Initialize onboarding immediately (before DOMContentLoaded)
// This ensures onboarding shows before site content loads
function tryInitOnboarding() {
  console.log('[Onboarding Debug] Attempting to initialize, readyState:', document.readyState);
  
  if (document.readyState === 'loading') {
    // DOM not ready yet, wait for it
    console.log('[Onboarding Debug] DOM loading, waiting for DOMContentLoaded');
    document.addEventListener('DOMContentLoaded', () => {
      console.log('[Onboarding Debug] DOMContentLoaded fired');
      // Small delay to ensure all elements are ready
      setTimeout(initOnboarding, 100);
    });
  } else {
    // DOM already ready
    console.log('[Onboarding Debug] DOM already ready, initializing');
    setTimeout(initOnboarding, 100);
  }
}

// Try immediately
tryInitOnboarding();

// Also try on window load as fallback
window.addEventListener('load', () => {
  console.log('[Onboarding Debug] Window load event fired');
  const overlay = document.getElementById('onboarding-overlay');
  if (overlay && overlay.style.display === 'none' && shouldShowOnboarding()) {
    console.log('[Onboarding Debug] Fallback: showing onboarding on window load');
    initOnboarding();
  }
});

// Helper function for testing: Reset onboarding (call from console)
// Usage: resetOnboarding() then refresh the page
window.resetOnboarding = function() {
  localStorage.removeItem(ONBOARDING_STORAGE_KEY);
  console.log('Onboarding reset! Refresh the page to see it again.');
  return true;
};

// Helper function for testing: Force show onboarding (call from console)
// Usage: forceShowOnboarding() - will show onboarding regardless of device type
window.forceShowOnboarding = function() {
  console.log('[Onboarding Debug] Force showing onboarding...');
  const overlay = document.getElementById('onboarding-overlay');
  if (!overlay) {
    console.error('[Onboarding Debug] Overlay not found!');
    return false;
  }
  
  // Remove completion flag
  localStorage.removeItem(ONBOARDING_STORAGE_KEY);
  
  // Force show
  overlay.style.display = 'flex';
  overlay.classList.add('active');
  document.body.style.overflow = 'hidden';
  showOnboardingPage(1);
  setupOnboardingEvents();
  
  console.log('[Onboarding Debug] Onboarding force-shown');
  return true;
};

// Debug function is already defined above (early definition for immediate availability)
// Additional helper functions are defined below

// ============================================================================
// END ONBOARDING SYSTEM
// ============================================================================

const localMode = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
const DATA_URL = localMode ? 'colleges_usa_2024.csv' : 'https://uscollegemap.org/colleges_usa_2024.csv';
const COLLEGE_CACHE_KEY = 'ucm_colleges_csv_v1';
const ROUTE_HINT_KEY = 'ucm_routeExploreHint';

// Cache DOM references for performance
const elements = {
  state: document.getElementById('state'),
  region: document.getElementById('region'),
  type: document.getElementById('type'),
  ranking: document.getElementById('ranking'),
  search: document.getElementById('search'),
  address: document.getElementById('address'),
  radius: document.getElementById('radius'),
  units: document.getElementById('units'),
  count: document.getElementById('count'),
  loading: document.getElementById('loading'),
  error: document.getElementById('error'),
  geocodeBtn: document.getElementById('geocodeBtn'),
  clearRadius: document.getElementById('clearRadius'),
  addressSuggestions: document.getElementById('addressSuggestions'),
  routeStart: document.getElementById('routeStart'),
  routeEnd: document.getElementById('routeEnd'),
  routeMaxDistance: document.getElementById('routeMaxDistance'),
  routeUnits: document.getElementById('routeUnits'),
  clearRoute: document.getElementById('clearRoute'),
  routeStartSuggestions: document.getElementById('routeStartSuggestions'),
  routeEndSuggestions: document.getElementById('routeEndSuggestions'),
  findRouteBtn: document.getElementById('findRouteBtn')
};

function guardIOSAutofill(input) {
  if (!input || input.dataset.iosAutofillGuarded === 'true') {
    return;
  }
  input.dataset.iosAutofillGuarded = 'true';
  const originalInputMode = input.getAttribute('inputmode') || '';
  if (originalInputMode) {
    input.dataset.originalInputMode = originalInputMode;
  }
  // Don't set readonly - it prevents keyboard from appearing on iOS
  // Instead, use inputmode='none' initially, then change to 'search' on interaction
  input.setAttribute('inputmode', 'none');
  
  // Unified keyboard enable function - fires on EVERY interaction
  const enableKeyboard = (event) => {
    // Change inputmode to allow keyboard - set synchronously BEFORE browser processes
    const restoredMode = input.dataset.originalInputMode || 'search';
    // Set both attribute and property for maximum compatibility
    input.setAttribute('inputmode', restoredMode);
    if (input.inputMode !== undefined) {
      input.inputMode = restoredMode;
    }
    // Force immediate reflow to ensure inputmode change is processed
    void input.offsetHeight;
    
    // For touch/pointer events, ensure focus happens to trigger keyboard
    // Use requestAnimationFrame for better timing with iOS keyboard
    if (event && (event.type === 'touchstart' || event.type === 'pointerdown' || event.type === 'mousedown' || event.type === 'click')) {
      // Prevent default only if needed to avoid interfering with autocomplete
      if (event.type === 'touchstart' || event.type === 'pointerdown') {
        // Don't prevent default - let normal focus behavior happen
      }
      // Use requestAnimationFrame to ensure inputmode is set before focus
      requestAnimationFrame(() => {
        if (document.activeElement !== input) {
          input.focus({ preventScroll: true });
        }
      });
    }
  };
  
  // Attach listeners in capture phase to fire early - these stay active for EVERY tap
  // Use passive: false only where needed to allow preventDefault if necessary
  input.addEventListener('touchstart', enableKeyboard, { passive: true, capture: true });
  input.addEventListener('pointerdown', enableKeyboard, { passive: true, capture: true });
  input.addEventListener('mousedown', enableKeyboard, { passive: true, capture: true });
  input.addEventListener('focus', enableKeyboard, { capture: true });
  input.addEventListener('click', enableKeyboard, { passive: true, capture: true });
  
  // Set autofill prevention attributes (keep existing autocomplete if set)
  if (!input.getAttribute('autocomplete') || input.getAttribute('autocomplete') === 'off') {
    input.setAttribute('autocomplete', 'new-password');
  }
  input.setAttribute('data-lpignore', 'true'); // LastPass ignore
  input.setAttribute('data-form-type', 'other'); // Prevent form autofill
}

// Apply autofill guard immediately if elements exist, or wait for DOMContentLoaded
function applyAutofillGuards() {
  const ua = navigator.userAgent || '';
  const isIOS =
    /iPad|iPhone|iPod/.test(ua) ||
    (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  if (isIOS) {
    document.documentElement.classList.add('ios-device');
    // Apply guards to address inputs on iOS only to prevent autofill
    const inputsToGuard = [elements.address, elements.routeStart, elements.routeEnd].filter(Boolean);
    inputsToGuard.forEach(guardIOSAutofill);
  }
  // On non-iOS devices (Android, etc.), don't apply the guard to allow normal keyboard behavior
}

// Try to apply guards immediately if elements are available
if (elements.address || elements.routeStart || elements.routeEnd) {
  applyAutofillGuards();
}

document.addEventListener('DOMContentLoaded', () => {
  // Parse shared view URL if present
  parseSharedViewURL();
  
  // If CSV has already loaded (from cache) and we're in shared view, apply shared state now
  if (isSharedView && window.sharedViewState && colleges && colleges.length > 0) {
    console.log('[DOMContentLoaded] CSV already loaded, applying shared view state now');
    applySharedViewState();
  }
  
  // Initialize shared view banner
  initSharedViewBanner();
  
  // Initialize saved search
  initSavedSearch();
  
  // Initialize saved pill count
  updateSavedPillCount();
  
  // Initialize navigation icon visibility
  updateNavigationIconVisibility();
  
  // Check for teaching moment on page load (if user already has 2+ saved colleges)
  checkAndShowSavedOnlyTeachingMoment();
  
  // Apply autofill guards again in case elements weren't ready before
  applyAutofillGuards();
  
  // Add double-click/double-tap to select all text in address fields
  const addressFields = [elements.address, elements.routeStart, elements.routeEnd].filter(Boolean);
  
  addressFields.forEach(input => {
    if (!input) return;
    
    // Double-click handler (desktop and some mobile browsers)
    input.addEventListener('dblclick', (e) => {
      e.preventDefault();
      input.select();
    });
    
    // Double-tap handler for mobile devices
    let lastTapTime = 0;
    let tapTimeout = null;
    
    input.addEventListener('touchend', (e) => {
      const currentTime = Date.now();
      const timeDiff = currentTime - lastTapTime;
      
      if (timeDiff < 300 && timeDiff > 0) {
        // Double tap detected
        e.preventDefault();
        clearTimeout(tapTimeout);
        input.select();
        lastTapTime = 0;
      } else {
        // Single tap - wait to see if it becomes a double tap
        lastTapTime = currentTime;
        tapTimeout = setTimeout(() => {
          lastTapTime = 0;
        }, 300);
      }
    });
  });
  
  // Position ranking dropdown on DOM ready (will be called again after it's defined and after CSV loads)
  setTimeout(() => {
    if (typeof positionRankingDropdown === 'function') {
      positionRankingDropdown();
    }
  }, 50);
  
  // Update dropdown placeholders on DOM ready (will be called again after CSV loads)
  // Note: updateDropdownPlaceholders function is defined later, but will be called after CSV loads
  
  const ua = navigator.userAgent || '';
  const isIOS =
    /iPad|iPhone|iPod/.test(ua) ||
    (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  // Note: iOS-specific placeholder override removed - now handled by updateDropdownPlaceholders()
  // which is called after CSV loads and dropdowns are refreshed
  if (window.innerWidth <= 700) {
    addHeaderInteractionListeners();
  }
  setupRouteHint();
  
  // Track contact email link click
  const contactLink = document.getElementById('contact-email-link');
  if (contactLink) {
    contactLink.addEventListener('click', () => {
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_contact_clicked');
      }
    });
  }
  
  // Track YouTube video interaction
  const videoIframe = document.getElementById('intro-video-iframe');
  if (videoIframe) {
    // Track when user clicks on the video iframe (indicates intent to watch)
    videoIframe.addEventListener('click', () => {
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_intro_video_interacted');
      }
    });
    
    // Also track when iframe receives focus (user interacting with video)
    videoIframe.addEventListener('focus', () => {
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_intro_video_interacted');
      }
    }, { once: true }); // Only track once per page load
  }
  
  // Initial update of navigation icon visibility
  updateNavigationIconVisibility();
  
  // Ensure map interactions are enabled on initial load
  // Wait a bit for map to be fully ready
  setTimeout(() => {
    const savedOverlay = document.getElementById('saved-colleges-overlay');
    if (!savedOverlay || !savedOverlay.classList.contains('active')) {
      // If overlay is not open, ensure map is interactive
      if (map && mapInteractionLock.locked) {
        resumeMapInteractions();
      } else if (map) {
        // Explicitly enable all interactions to ensure map is interactive
        if (map.dragging) map.dragging.enable();
        if (map.scrollWheelZoom) map.scrollWheelZoom.enable();
        if (map.doubleClickZoom) map.doubleClickZoom.enable();
        if (map.boxZoom) map.boxZoom.enable();
        if (map.keyboard) map.keyboard.enable();
        if (map.touchZoom) map.touchZoom.enable();
        if (map.tap && typeof map.tap.enable === 'function') map.tap.enable();
      }
    }
  }, 300);
});

if (elements.addressSuggestions) elements.addressSuggestions.dataset.field = 'address';
if (elements.routeStartSuggestions) elements.routeStartSuggestions.dataset.field = 'routeStart';
if (elements.routeEndSuggestions) elements.routeEndSuggestions.dataset.field = 'routeEnd';

let addressAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

// Route autocomplete objects
let routeStartAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

let routeEndAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

let mobileHeaderCollapsed = false;
let headerListenersAttached = false;
const headerInteractionEvents = ['pointerdown','touchstart','keydown'];

function getHeaderElement() {
  return document.querySelector('.app-header');
}

function collapseMobileHeader() {
  const header = getHeaderElement();
  if (!header || window.innerWidth > 700 || mobileHeaderCollapsed) return;
  header.classList.add('collapsed');
  mobileHeaderCollapsed = true;
  removeHeaderInteractionListeners();
}

function handleHeaderFirstInteraction(event) {
  if (mobileHeaderCollapsed || window.innerWidth > 700) return;
  const header = getHeaderElement();
  if (!header) return;
  if (header.contains(event.target)) return;
  collapseMobileHeader();
}

function addHeaderInteractionListeners() {
  if (headerListenersAttached || window.innerWidth > 700 || mobileHeaderCollapsed) return;
  headerInteractionEvents.forEach(evt => document.addEventListener(evt, handleHeaderFirstInteraction, true));
  headerListenersAttached = true;
}

function removeHeaderInteractionListeners() {
  if (!headerListenersAttached) return;
  headerInteractionEvents.forEach(evt => document.removeEventListener(evt, handleHeaderFirstInteraction, true));
  headerListenersAttached = false;
}

function resetHeaderForDesktop() {
  const header = getHeaderElement();
  if (header) header.classList.remove('collapsed');
  mobileHeaderCollapsed = false;
  removeHeaderInteractionListeners();
  if (window.innerWidth <= 700) {
    addHeaderInteractionListeners();
  }
}

const americasBounds = L.latLngBounds([[-60,-180],[85,-30]]);
const US_MAINLAND_VIEW = L.latLngBounds([[18,-130],[55,-60]]);
const INITIAL_DESKTOP_VIEW = { center: { lat: 39.5, lng: -98.35 }, zoom: 4 };
const INITIAL_MOBILE_VIEW = { center: { lat: 39.5, lng: -98.35 }, zoom: 3.5 };
function getInitialNearbyView() {
  return window.innerWidth <= 700 ? INITIAL_MOBILE_VIEW : INITIAL_DESKTOP_VIEW;
}
const mapViewState = {
  nearby: { ...getInitialNearbyView() },
  route: null
};
const map = L.map('map',{maxBounds:americasBounds,maxBoundsViscosity:1}).setView(
  [mapViewState.nearby.center.lat, mapViewState.nearby.center.lng],
  mapViewState.nearby.zoom
);
map.whenReady(() => {
  setTimeout(() => {
    map.invalidateSize();
    if (!home && !lastNearbyFilters && mapViewState.nearby) {
      map.setView([mapViewState.nearby.center.lat, mapViewState.nearby.center.lng], mapViewState.nearby.zoom);
      captureMapView('nearby');
    }
    // Ensure map interactions are enabled on initial load
    // Check if saved overlay is not open (if it is, interactions should be frozen)
    const savedOverlay = document.getElementById('saved-colleges-overlay');
    if (!savedOverlay || !savedOverlay.classList.contains('active')) {
      // If overlay is not open, ensure map is interactive
      if (mapInteractionLock.locked) {
        resumeMapInteractions();
      } else {
        // Explicitly enable all interactions to ensure map is interactive
        if (map.dragging) map.dragging.enable();
        if (map.scrollWheelZoom) map.scrollWheelZoom.enable();
        if (map.doubleClickZoom) map.doubleClickZoom.enable();
        if (map.boxZoom) map.boxZoom.enable();
        if (map.keyboard) map.keyboard.enable();
        if (map.touchZoom) map.touchZoom.enable();
        if (map.tap && typeof map.tap.enable === 'function') map.tap.enable();
      }
    }
  }, 150);
});
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap contributors',attributionControl:true}).addTo(map);

const mapInteractionLock = {
  locked: false,
  state: {}
};

function freezeMapInteractions() {
  if (!map || mapInteractionLock.locked) return;
  const state = mapInteractionLock.state = {};
  if (map.dragging) {
    state.dragging = map.dragging.enabled();
    map.dragging.disable();
  }
  if (map.scrollWheelZoom) {
    state.scrollWheelZoom = map.scrollWheelZoom.enabled();
    map.scrollWheelZoom.disable();
  }
  if (map.doubleClickZoom) {
    state.doubleClickZoom = map.doubleClickZoom.enabled();
    map.doubleClickZoom.disable();
  }
  if (map.boxZoom) {
    state.boxZoom = map.boxZoom.enabled();
    map.boxZoom.disable();
  }
  if (map.keyboard) {
    state.keyboard = map.keyboard.enabled();
    map.keyboard.disable();
  }
  if (map.touchZoom) {
    state.touchZoom = map.touchZoom.enabled();
    map.touchZoom.disable();
  }
  if (map.tap && typeof map.tap.enabled === 'function') {
    state.tap = map.tap.enabled();
    map.tap.disable();
  }
  mapInteractionLock.locked = true;
}

function resumeMapInteractions() {
  if (!map || !mapInteractionLock.locked) return;
  const state = mapInteractionLock.state || {};
  if (state.dragging && map.dragging) map.dragging.enable();
  if (state.scrollWheelZoom && map.scrollWheelZoom) map.scrollWheelZoom.enable();
  if (state.doubleClickZoom && map.doubleClickZoom) map.doubleClickZoom.enable();
  if (state.boxZoom && map.boxZoom) map.boxZoom.enable();
  if (state.keyboard && map.keyboard) map.keyboard.enable();
  if (state.touchZoom && map.touchZoom) map.touchZoom.enable();
  if (state.tap && map.tap && typeof map.tap.enable === 'function') map.tap.enable();
  mapInteractionLock.locked = false;
  mapInteractionLock.state = {};
}

function clampBoundsToMainland(bounds) {
  if (!bounds || !bounds.isValid()) return US_MAINLAND_VIEW;
  const south = bounds.getSouth();
  const west = bounds.getWest();
  const north = bounds.getNorth();
  const east = bounds.getEast();
  const needsClamp =
    south < US_MAINLAND_VIEW.getSouth() ||
    west < US_MAINLAND_VIEW.getWest() ||
    north > US_MAINLAND_VIEW.getNorth() ||
    east > US_MAINLAND_VIEW.getEast();
  if (!needsClamp) {
    return bounds;
  }
  const clampedSouth = Math.max(south, US_MAINLAND_VIEW.getSouth());
  const clampedWest = Math.max(west, US_MAINLAND_VIEW.getWest());
  const clampedNorth = Math.min(north, US_MAINLAND_VIEW.getNorth());
  const clampedEast = Math.min(east, US_MAINLAND_VIEW.getEast());
  const clamped = L.latLngBounds(
    L.latLng(clampedSouth, clampedWest),
    L.latLng(clampedNorth, clampedEast)
  );
  return clamped.isValid() ? clamped : US_MAINLAND_VIEW;
}

const markersLayer = L.layerGroup().addTo(map);

const homeLayer = L.layerGroup().addTo(map);
const radiusLayer = L.layerGroup().addTo(map);
const routeLayer = L.layerGroup().addTo(map);

// Store references to route polylines for dynamic styling
let routeOutlinePolyline = null; // Navy outline
let routeMainPolyline = null; // Royal blue main line

// Device detection for dynamic marker sizing
function detectDeviceType() {
  const width = window.innerWidth;
  const ua = navigator.userAgent || '';
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  
  // iPad detection (including iPad Pro)
  const isIPad = /iPad/.test(ua) || (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  // Mobile phones (small screens with touch)
  if (isTouchDevice && width <= 768 && !isIPad) {
    return 'mobile';
  }
  
  // Tablets/iPad (medium screens with touch)
  if (isTouchDevice && (width <= 1024 || isIPad)) {
    return 'tablet';
  }
  
  // Desktop (everything else)
  return 'desktop';
}

// Calculate marker radius based on zoom level and device type
function calculateMarkerRadius(zoom, deviceType) {
  if (deviceType === 'desktop') {
    return 5; // Always radius 5 for desktop
  }
  
  if (deviceType === 'mobile') {
    // Mobile: Low zoom (0-5) → 4-5, Medium (6-9) → 6-8, High (10+) → 9-10, cap at 10
    if (zoom <= 5) {
      return 4 + (zoom / 5); // 4 to 5 (linear interpolation)
    } else if (zoom <= 9) {
      return 6 + ((zoom - 5) / 4) * 2; // 6 to 8 (linear interpolation)
    } else {
      // High zoom: 9 to 10 (capped), reaching 10 around zoom 11-12
      return Math.min(9 + (zoom - 9) * 0.5, 10); // 9 to 10 (capped at 10)
    }
  }
  
  if (deviceType === 'tablet') {
    // iPad: Same sizing as mobile for better visibility - Low zoom (0-5) → 4-5, Medium (6-9) → 6-8, High (10+) → 9-10, cap at 10
    if (zoom <= 5) {
      return 4 + (zoom / 5); // 4 to 5 (linear interpolation)
    } else if (zoom <= 9) {
      return 6 + ((zoom - 5) / 4) * 2; // 6 to 8 (linear interpolation)
    } else {
      // High zoom: 9 to 10 (capped), reaching 10 around zoom 11-12
      return Math.min(9 + (zoom - 9) * 0.5, 10); // 9 to 10 (capped at 10)
    }
  }
  
  return 5; // Fallback to desktop size
}

// Calculate route line weights and opacity based on zoom level
// Low zoom: thinner (2-3), Medium: default (4), High: slightly thicker (4-5)
// Opacity: lighter at low zoom, stronger at high zoom
function calculateRouteLineWeights(zoom) {
  let mainOpacity, outlineOpacity;
  
  // Opacity mapping: lighter at low zoom, stronger at high zoom
  if (zoom <= 5) {
    mainOpacity = 0.6;
    outlineOpacity = 0.7; // Slightly higher for ribbon effect
  } else if (zoom <= 7) {
    mainOpacity = 0.75;
    outlineOpacity = 0.85; // Slightly higher for ribbon effect
  } else if (zoom <= 10) {
    mainOpacity = 0.9;
    outlineOpacity = 0.95; // Slightly higher for ribbon effect
  } else {
    mainOpacity = 1.0;
    outlineOpacity = 1.0; // Full opacity at high zoom
  }
  
  // Weight mapping: thinner at low zoom, thicker at high zoom
  if (zoom <= 5) {
    // Low zoom (far out): thinner and lighter
    return {
      outlineWeight: 3,
      mainWeight: 2,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  } else if (zoom <= 9) {
    // Medium zoom (normal trip-planning view): default
    return {
      outlineWeight: 5,
      mainWeight: 4,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  } else {
    // High zoom (zoomed in close): slightly thicker but subtle
    return {
      outlineWeight: 6,
      mainWeight: 5,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  }
}

// Get current marker radius based on current zoom and device
function getCurrentMarkerRadius() {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  return calculateMarkerRadius(zoom, deviceType);
}

// Calculate saved icon size based on zoom level and device type
// Maintains desktop ratio (2.4×) to blue dot diameter, with specific caps for mobile/iPad
function calculateSavedIconSize(zoom, deviceType) {
  if (deviceType === 'desktop') {
    return { width: 24, height: 30 }; // Desktop: unchanged
  }
  
  // Get current blue dot radius to maintain proportional ratio
  const blueDotRadius = calculateMarkerRadius(zoom, deviceType);
  const blueDotDiameter = blueDotRadius * 2;
  
  // Calculate proportional size using desktop ratio (24px icon / 10px blue dot diameter = 2.4×)
  // This ensures saved icons are proportionally the same size relative to blue dots on all devices
  let targetWidth = blueDotDiameter * 2.4;
  
  if (deviceType === 'mobile') {
    // Mobile: scale from ~20px (low zoom) to max 28px (high zoom cap)
    const minWidth = 20;
    const maxWidth = 28;
    targetWidth = Math.max(minWidth, Math.min(targetWidth, maxWidth));
  } else if (deviceType === 'tablet') {
    // iPad: same sizing as mobile - scale from ~20px (low zoom) to max 28px (high zoom cap)
    const minWidth = 20;
    const maxWidth = 28;
    targetWidth = Math.max(minWidth, Math.min(targetWidth, maxWidth));
  }
  
  // Maintain aspect ratio (24:30 = 0.8)
  const height = targetWidth * (30 / 24);
  
  return { width: Math.round(targetWidth), height: Math.round(height) };
}

// Get current saved icon size based on current zoom and device
function getCurrentSavedIconSize() {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  return calculateSavedIconSize(zoom, deviceType);
}

// Create a green saved icon with dynamic sizing
function createGreenSavedIcon(size) {
  const { width, height } = size || getCurrentSavedIconSize();
  return L.icon({
    iconUrl: 'data:image/svg+xml;base64,' + btoa(greenSavedPinSvg),
    iconSize: [width, height],
    iconAnchor: [width / 2, height],
    popupAnchor: [0, -height]
  });
}
const ROUTE_START_PIN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><circle cx="9" cy="9" r="4" fill="#ffffff" stroke="#111827" stroke-width="2"/></svg>';
const ROUTE_END_PIN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
const ROUTE_START_PIN_ICON = 'data:image/svg+xml;base64,' + btoa(ROUTE_START_PIN_SVG);
const ROUTE_END_PIN_ICON = 'data:image/svg+xml;base64,' + btoa(ROUTE_END_PIN_SVG);
let colleges = [], home = null;
// Shared view state (temporary, in-memory only)
let sharedViewIds = null;
let isSharedView = false;
// Saved-only mode (declared early so it can be set before CSV loads)
let savedOnlyMode = false;

// Parse shared view URL immediately (before DOMContentLoaded) to set savedOnlyMode early
// This ensures savedOnlyMode is set before any rendering happens
if (typeof URLSearchParams !== 'undefined') {
  const params = new URLSearchParams(window.location.search);
  const view = params.get('view');
  if (view === 'savedshare') {
    const collegesParam = params.get('colleges');
    if (collegesParam) {
      // Normalize IDs to strings and trim whitespace
      sharedViewIds = new Set(collegesParam.split(',').map(id => id.trim()).filter(id => id));
      console.log('[Early init] Shared view IDs parsed:', sharedViewIds.size, 'Sample IDs:', Array.from(sharedViewIds).slice(0, 5));
    } else {
      sharedViewIds = new Set();
      console.log('[Early init] No shared college IDs in URL');
    }
    isSharedView = true;
    savedOnlyMode = true; // Set immediately to prevent initial render from showing all colleges
    
    // Also set window.sharedViewState early so handleDataLoad can use it
    const lat = parseFloat(params.get('lat'));
    const lng = parseFloat(params.get('lng'));
    const zoom = parseFloat(params.get('zoom'));
    
    window.sharedViewState = {
      center: (lat && lng) ? { lat, lng } : null,
      zoom: zoom || null,
      mode: params.get('mode') || 'explore',
      nearby: null,
      route: null
    };
    
    // Parse mode-specific data
    if (window.sharedViewState.mode === 'nearby') {
      const homeLat = parseFloat(params.get('homeLat'));
      const homeLng = parseFloat(params.get('homeLng'));
      const radius = params.get('radius');
      const units = params.get('units');
      
      if (homeLat && homeLng) {
        window.sharedViewState.nearby = {
          lat: homeLat,
          lon: homeLng,
          radius: radius || null,
          units: units || 'mi'
        };
      }
    } else if (window.sharedViewState.mode === 'route') {
      const startLat = parseFloat(params.get('startLat'));
      const startLng = parseFloat(params.get('startLng'));
      const endLat = parseFloat(params.get('endLat'));
      const endLng = parseFloat(params.get('endLng'));
      const routeRadius = params.get('routeRadius');
      const routeUnits = params.get('routeUnits');
      
      if (startLat && startLng && endLat && endLng) {
        window.sharedViewState.route = {
          start: { lat: startLat, lon: startLng },
          end: { lat: endLat, lon: endLng },
          maxDistance: routeRadius || null,
          units: routeUnits || 'mi'
        };
      }
    }
    
    console.log('[Early init] Shared view detected, savedOnlyMode set to true', { sharedViewIdsSize: sharedViewIds.size, sharedViewState: window.sharedViewState });
  }
}
function captureMapView(mode) {
  if (!mode) return;
  const center = map.getCenter();
  mapViewState[mode] = {
    center: { lat: center.lat, lng: center.lng },
    zoom: map.getZoom()
  };
}
function applySavedMapView(mode) {
  const view = mode ? mapViewState[mode] : null;
  if (view && view.center && typeof view.zoom === 'number') {
    map.setView([view.center.lat, view.center.lng], view.zoom, { animate: false });
    return true;
  }
  return false;
}
map.on('moveend', () => {
  if (activeMode === 'nearby' || activeMode === 'route') {
    captureMapView(activeMode);
  }
});

// Update marker sizes dynamically on zoom for touch devices (performance optimization)
map.on('zoomend', () => {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  
  // Update route line weights based on zoom (all devices)
  if (routeOutlinePolyline && routeMainPolyline) {
    const routeWeights = calculateRouteLineWeights(zoom);
    routeOutlinePolyline.setStyle({
      weight: routeWeights.outlineWeight,
      opacity: routeWeights.outlineOpacity
    });
    routeMainPolyline.setStyle({
      weight: routeWeights.mainWeight,
      opacity: routeWeights.mainOpacity
    });
  }
  
  // Only update marker sizes on touch devices (mobile/tablet), desktop always uses radius 5 and icon size 24x30
  if (deviceType === 'desktop') return;
  
  const newRadius = getCurrentMarkerRadius();
  const newIconSize = getCurrentSavedIconSize();
  const newSavedIcon = createGreenSavedIcon(newIconSize);
  
  // Update all marker instances without recreating them
  markersLayer.eachLayer((layer) => {
    // Update circleMarker types (blue dots)
    if (layer.setRadius && typeof layer.setRadius === 'function') {
      layer.setRadius(newRadius);
    }
    // Update saved icon markers (green pins)
    else if (layer.setIcon && typeof layer.setIcon === 'function' && layer.options && layer.options.icon) {
      // Check if this is a saved marker by checking if it has the green saved icon
      const currentIcon = layer.options.icon;
      if (currentIcon && currentIcon.options && currentIcon.options.iconUrl && 
          currentIcon.options.iconUrl.includes('data:image/svg+xml') &&
          currentIcon.options.iconUrl.includes('64D85B')) {
        // This is a saved icon marker (green pin), update its size
        layer.setIcon(newSavedIcon);
      }
    }
  });
});

window.addEventListener('resize', () => {
  if (window.innerWidth > 700) {
    resetHeaderForDesktop();
  } else if (!mobileHeaderCollapsed) {
    addHeaderInteractionListeners();
  }
});

// SavedStore: Manages saved college IDs in localStorage
const SAVED_STORAGE_KEY = 'uscm_saved_v1';
const SavedStore = (() => {
  const STORAGE_KEY = SAVED_STORAGE_KEY;
  let savedIds = new Set();
  
  // Load from localStorage on init
  function load() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed)) {
          savedIds = new Set(parsed);
        } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.saved)) {
          savedIds = new Set(parsed.saved);
        }
      }
    } catch (err) {
      console.warn('SavedStore: failed to load saved state', err);
      savedIds = new Set();
    }
  }
  
  // Save to localStorage
  function save() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(Array.from(savedIds)));
    } catch (err) {
      console.warn('SavedStore: failed to persist state', err);
    }
  }
  
  // Initialize on load
  load();
  
  return {
    isSaved(collegeId) {
      // In shared view, check sharedViewIds instead of local savedIds
      if (isSharedView && sharedViewIds) {
        // Normalize collegeId to string for consistent comparison
        const normalizedId = String(collegeId || '').trim();
        const isInShared = sharedViewIds.has(normalizedId);
        return isInShared;
      }
      return savedIds.has(collegeId);
    },
    toggle(collegeId) {
      if (!collegeId) return;
      if (savedIds.has(collegeId)) {
        savedIds.delete(collegeId);
      } else {
        savedIds.add(collegeId);
      }
      save();
      // Track save/unsave action
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_saved_used');
      }
    },
    getAll() {
      // In shared view, return shared IDs instead of local savedIds
      if (isSharedView && sharedViewIds) {
        return Array.from(sharedViewIds);
      }
      return Array.from(savedIds);
    }
  };
})();

// Parse URL for shared view
function parseSharedViewURL() {
  const params = new URLSearchParams(window.location.search);
  const view = params.get('view');
  
  if (view !== 'savedshare') {
    return false;
  }
  
  // Parse shared college IDs
  const collegesParam = params.get('colleges');
  if (collegesParam) {
    // Normalize IDs to strings and trim whitespace
    sharedViewIds = new Set(collegesParam.split(',').map(id => id.trim()).filter(id => id));
    console.log('Shared view IDs parsed:', sharedViewIds.size, 'Sample IDs:', Array.from(sharedViewIds).slice(0, 5));
  } else {
    sharedViewIds = new Set();
    console.log('No shared college IDs in URL');
  }
  
  isSharedView = true;
  console.log('Shared view enabled', { isSharedView, sharedViewIdsSize: sharedViewIds.size });
  
  // Google Analytics: Track shared map view
  if (typeof gtag !== 'undefined') {
    const mode = window.sharedViewState?.mode || 'explore';
    gtag('event', 'feature_shared_map_viewed', {
      'college_count': sharedViewIds ? sharedViewIds.size : 0,
      'mode': mode
    });
  }
  
  // Immediately set Map Saved Only to ON for shared views
  savedOnlyMode = true;
  const savedToggle = document.getElementById('saved-toggle');
  const savedControls = document.getElementById('saved-controls');
  const savedOnlySection = document.getElementById('saved-only-section');
  if (savedToggle) {
    savedToggle.classList.add('active');
  }
  if (savedControls) {
    savedControls.classList.add('saved-only-active');
  }
  if (savedOnlySection) {
    savedOnlySection.classList.add('saved-only-active');
  }
  console.log('Map Saved Only set to ON for shared view');
  
  // Show banner
  const banner = document.getElementById('shared-map-banner');
  if (banner) {
    banner.classList.add('active');
  }
  
  // Parse map center and zoom
  const lat = parseFloat(params.get('lat'));
  const lng = parseFloat(params.get('lng'));
  const zoom = parseFloat(params.get('zoom'));
  
  // Store shared view state for later use
  window.sharedViewState = {
    center: (lat && lng) ? { lat, lng } : null,
    zoom: zoom || null,
    mode: params.get('mode') || 'explore',
    nearby: null,
    route: null
  };
  
  // Parse mode-specific data
  if (window.sharedViewState.mode === 'nearby') {
    const homeLat = parseFloat(params.get('homeLat'));
    const homeLng = parseFloat(params.get('homeLng'));
    const radius = params.get('radius');
    const units = params.get('units');
    
    if (homeLat && homeLng) {
      window.sharedViewState.nearby = {
        lat: homeLat,
        lon: homeLng,
        radius: radius || null,
        units: units || 'mi'
      };
    }
  } else if (window.sharedViewState.mode === 'route') {
    const startLat = parseFloat(params.get('startLat'));
    const startLng = parseFloat(params.get('startLng'));
    const endLat = parseFloat(params.get('endLat'));
    const endLng = parseFloat(params.get('endLng'));
    const routeRadius = params.get('routeRadius');
    const routeUnits = params.get('routeUnits');
    
    if (startLat && startLng && endLat && endLng) {
      window.sharedViewState.route = {
        start: { lat: startLat, lon: startLng },
        end: { lat: endLat, lon: endLng },
        maxDistance: routeRadius || null,
        units: routeUnits || 'mi'
      };
    }
  }
  
  return true;
}

// Initialize shared view banner close handler
function initSharedViewBanner() {
  const banner = document.getElementById('shared-map-banner');
  const closeBtn = document.getElementById('shared-map-banner-close');
  
  if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      if (banner) {
        banner.classList.remove('active');
      }
    });
  }
}

// Apply shared view state to map and UI
function applySharedViewState() {
  console.log('[applySharedViewState] Called', { isSharedView, hasSharedViewState: !!window.sharedViewState, sharedViewIdsSize: sharedViewIds ? sharedViewIds.size : 'null' });
  
  if (!isSharedView || !window.sharedViewState) {
    console.log('[applySharedViewState] Returning early - shared view not active or state not available', { isSharedView, sharedViewState: window.sharedViewState });
    return;
  }
  
  const state = window.sharedViewState;
  console.log('[applySharedViewState] Applying shared view state', state);
  
  // Saved-only mode is already set in parseSharedViewURL(), but ensure UI is updated
  // (in case elements weren't ready when parseSharedViewURL() ran)
  savedOnlyMode = true;
  const savedToggle = document.getElementById('saved-toggle');
  const savedControls = document.getElementById('saved-controls');
  const savedOnlySection = document.getElementById('saved-only-section');
  if (savedToggle) {
    savedToggle.classList.add('active');
  }
  if (savedControls) {
    savedControls.classList.add('saved-only-active');
  }
  if (savedOnlySection) {
    savedOnlySection.classList.add('saved-only-active');
  }
  
  // Wait for map to be ready before applying state
  if (!map) {
    console.warn('[applySharedViewState] Map not ready, retrying...');
    setTimeout(applySharedViewState, 100);
    return;
  }
  
  console.log('[applySharedViewState] Map is ready, proceeding with state application');
  
  // Set map center and zoom
  if (state.center && state.zoom) {
    map.setView([state.center.lat, state.center.lng], state.zoom, { animate: false });
  }
  
  // Apply mode-specific state
  if (state.mode === 'nearby' && state.nearby) {
    activeMode = 'nearby';
    // Set home location for nearby mode
    home = { lat: state.nearby.lat, lon: state.nearby.lon };
    console.log('Set home location for shared view:', home);
    
    // Update nearby UI elements
    if (elements.address) {
      // Set address display (we'll need to reverse geocode or use a placeholder)
      elements.address.value = 'Shared location';
    }
    if (elements.radius && state.nearby.radius) {
      elements.radius.value = state.nearby.radius;
    }
    if (elements.units && state.nearby.units) {
      elements.units.value = state.nearby.units;
    }
    
    // Switch to nearby mode
    const nearbyDetails = document.querySelector('details[data-mode="nearby"]');
    const routeDetails = document.querySelector('details[data-mode="route"]');
    if (nearbyDetails) nearbyDetails.open = true;
    if (routeDetails) routeDetails.open = false;
    
    // Trigger nearby search after map is ready
    map.whenReady(() => {
      setTimeout(() => {
        if (home) {
          console.log('Applying nearby shared view', { home, state: state.nearby });
          // Use existing nearby search logic
          const radiusVal = parseFloat(elements.radius?.value || state.nearby.radius || '0') || 0;
          const unitsVal = elements.units?.value || state.nearby.units || 'mi';
          const radiusInMeters = unitsVal === 'mi' ? radiusVal * 1609.34 : radiusVal * 1000;
          
          // Clear and draw home location pin and radius circle
          if (homeLayer) {
            homeLayer.clearLayers();
            // Add "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([home.lat, home.lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
          }
          
          // Draw radius circle
          if (radiusLayer) {
            radiusLayer.clearLayers();
            // Draw circle even if radius is 0 (use 0.5)
            const effectiveRadius = radiusVal === 0 ? 0.5 : radiusVal;
            const effectiveRadiusInMeters = unitsVal === 'mi' ? effectiveRadius * 1609.34 : effectiveRadius * 1000;
            L.circle([home.lat, home.lon], {
              radius: effectiveRadiusInMeters,
              color: '#2563eb',
              fillColor: '#2563eb',
              fillOpacity: 0.1,
              weight: 2
            }).addTo(radiusLayer);
          }
          
          // Render colleges
          render();
        }
      }, 200);
    });
    
  } else if (state.mode === 'route' && state.route) {
    activeMode = 'route';
    route.start = state.route.start;
    route.end = state.route.end;
    
    // Update route UI elements
    if (elements.routeStart) {
      elements.routeStart.value = 'Shared start';
    }
    if (elements.routeEnd) {
      elements.routeEnd.value = 'Shared end';
    }
    if (elements.routeMaxDistance && state.route.maxDistance) {
      elements.routeMaxDistance.value = state.route.maxDistance;
    }
    if (elements.routeUnits && state.route.units) {
      elements.routeUnits.value = state.route.units;
    }
    
    // Switch to route mode
    const nearbyDetails = document.querySelector('details[data-mode="nearby"]');
    const routeDetails = document.querySelector('details[data-mode="route"]');
    if (nearbyDetails) nearbyDetails.open = false;
    if (routeDetails) routeDetails.open = true;
    
    // Store route search state so it can be re-rendered
    // Parse maxDistance - handle 0 correctly (don't use || operator as 0 is falsy)
    const maxDistanceInputStr = elements.routeMaxDistance?.value || state.route.maxDistance;
    let maxDistanceInput;
    if (maxDistanceInputStr === '' || maxDistanceInputStr === null || maxDistanceInputStr === undefined) {
      maxDistanceInput = 30;
    } else {
      maxDistanceInput = parseFloat(maxDistanceInputStr);
      if (isNaN(maxDistanceInput)) {
        maxDistanceInput = 30;
      }
    }
    // If maxDistance is 0, use 0.5 instead
    const maxDistance = maxDistanceInput === 0 ? 0.5 : maxDistanceInput;
    const units = elements.routeUnits?.value || state.route.units || 'mi';
    route.lastSearch = {
      start: route.start,
      end: route.end,
      maxDistance,
      units
    };
    
    // Trigger route search after map is ready
    map.whenReady(() => {
      setTimeout(() => {
        if (route.start && route.end) {
          console.log('Applying route shared view', { start: route.start, end: route.end });
          // Use existing route search logic
          findCollegesAlongRoute();
        }
      }, 200);
    });
  } else {
    // Explore mode - just render with saved-only filter
    console.log('[applySharedViewState] Explore mode - setting up render');
    if (!map) {
      console.warn('[applySharedViewState] Map not ready for explore mode, retrying...');
      setTimeout(applySharedViewState, 100);
      return;
    }
    
    map.whenReady(() => {
      setTimeout(() => {
        console.log('[applySharedViewState] Applying explore shared view - calling render()');
        console.log('[applySharedViewState] Before render - savedOnlyMode:', savedOnlyMode, 'sharedViewIds size:', sharedViewIds ? sharedViewIds.size : 'null');
        render();
        console.log('[applySharedViewState] After render - markers should be visible');
      }, 200);
    });
  }
}

// Active mode state: 'nearby' or 'route'
let activeMode = 'nearby';

// Track if user has actively used search controls (Locate or Find Route buttons)
let hasUsedSearchControls = false;

// Marker registry: maps college_id to Leaflet marker instance
const markersByCollegeId = {};

// Create green saved icon (pin with white star)
const greenSavedPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 256 256"><path d="M128 0C74 0 32 42 32 96C32 166 128 256 128 256C128 256 224 166 224 96C224 42 182 0 128 0Z" fill="#64D85B"/><path d="M128 32L147 86H200L159 118L175 170L128 139L81 170L97 118L56 86H109L128 32Z" fill="#FFFFFF"/></svg>';
// Default green saved icon (desktop size, used as fallback)
// Note: For dynamic sizing, use createGreenSavedIcon() instead
const greenSavedIcon = createGreenSavedIcon({ width: 24, height: 30 });

// Create blue circle icon for unsaved colleges
const blueCircleSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="4" fill="#2563eb" fill-opacity="0.7" stroke="#2563eb" stroke-width="2"/></svg>';
const blueDotIcon = L.divIcon({
  html: blueCircleSvg,
  className: 'blue-dot-marker',
  iconSize: [10, 10],
  iconAnchor: [5, 5]
});

// Helper function to create a marker with appropriate icon based on saved state
function createCollegeMarker(college, popupContent, collegeId) {
  const isSaved = collegeId && SavedStore.isSaved(collegeId);
  
  let marker;
  if (isSaved) {
    // Use green pin icon for saved colleges with dynamic sizing
    const iconSize = getCurrentSavedIconSize();
    marker = L.marker([college.lat, college.lon], {
      icon: createGreenSavedIcon(iconSize)
    });
  } else {
    // Use blue circle marker for unsaved colleges with dynamic sizing for touch devices
    const radius = getCurrentMarkerRadius();
    marker = L.circleMarker([college.lat, college.lon], {
      radius: radius,
      color: '#2563eb',
      weight: 2,
      fillOpacity: 0.7
    });
  }
  
  marker
    .bindTooltip(college.name, {permanent: false, direction: 'top'})
    .bindPopup(popupContent);
  marker.on('click', () => {
    if (marker.closeTooltip) {
      marker.closeTooltip();
    }
  });
  
  // Register marker in registry
  if (collegeId) {
    markersByCollegeId[collegeId] = marker;
  }
  
  return marker;
}

// Update popup save button visual state
// Cached references to avoid repeated DOM queries
const buttonCache = new WeakMap();

function updatePopupSaveButton(button, collegeId) {
  if (!button || !collegeId) return;
  
  // Cache DOM references to avoid repeated querySelector calls
  let cached = buttonCache.get(button);
  if (!cached) {
    cached = {
      icon: button.querySelector('.popup-save-icon'),
      label: button.querySelector('.popup-save-label')
    };
    buttonCache.set(button, cached);
  }
  
  const icon = cached.icon;
  const label = cached.label;
  const isSaved = SavedStore.isSaved(collegeId);
  
  // Detect transition from unsaved to saved for celebration animation
  const wasSaved = button.classList.contains('saved');
  const isTransitioningToSaved = !wasSaved && isSaved;
  
  // Update button class
  if (isSaved) {
    button.classList.add('saved');
  } else {
    button.classList.remove('saved');
    // Remove animation class if unsaving
    button.classList.remove('saved-pop');
  }
  
  // Update icon and label
  if (icon) {
    icon.textContent = isSaved ? '★' : '☆';
  }
  if (label) {
    label.textContent = isSaved ? 'Saved' : 'Save';
  }
  
  // Trigger celebration animation when transitioning to saved
  if (isTransitioningToSaved) {
    // Remove any existing animation class first
    button.classList.remove('saved-pop');
    // Force reflow to ensure class removal is processed
    void button.offsetWidth;
    // Add animation class
    button.classList.add('saved-pop');
    // Remove animation class after animation completes (200ms)
    setTimeout(() => {
      button.classList.remove('saved-pop');
    }, 200);
  }
}

// Track tooltip states to restore them when popup closes
const tooltipStates = new WeakMap();

// Handle popup open: disable all tooltips and update save button state
map.on('popupopen', (event) => {
  const popupEl = event.popup && event.popup.getElement ? event.popup.getElement() : null;
  if (!popupEl) return;
  const sourceMarker = event.popup && event.popup._source;
  if (sourceMarker && sourceMarker.closeTooltip) {
    sourceMarker.closeTooltip();
  }
  
  // Disable tooltips on visible markers only (performance optimization for mobile)
  // Defer this operation to not block popup opening
  requestAnimationFrame(() => {
    const bounds = map.getBounds();
    let processedCount = 0;
    const maxProcessPerFrame = 50; // Process in batches to avoid blocking
    
    markersLayer.eachLayer((layer) => {
      // Only process markers visible in current viewport
      if (bounds.contains(layer.getLatLng())) {
        if (layer.getTooltip && layer.getTooltip()) {
          const tooltip = layer.getTooltip();
          const tooltipContent = tooltip.getContent();
          // Store tooltip content to restore later
          tooltipStates.set(layer, tooltipContent);
          // Unbind tooltip to prevent it from showing on hover
          layer.unbindTooltip();
          processedCount++;
          
          // If we've processed many markers, defer the rest
          if (processedCount >= maxProcessPerFrame) {
            return false; // Stop iteration
          }
        }
      }
    });
    
    // If there are more markers to process, continue in next frame
    if (processedCount >= maxProcessPerFrame) {
      setTimeout(() => {
        const bounds = map.getBounds();
        markersLayer.eachLayer((layer) => {
          if (bounds.contains(layer.getLatLng()) && layer.getTooltip && layer.getTooltip()) {
            const tooltip = layer.getTooltip();
            const tooltipContent = tooltip.getContent();
            if (!tooltipStates.has(layer)) {
              tooltipStates.set(layer, tooltipContent);
              layer.unbindTooltip();
            }
          }
        });
      }, 0);
    }
  });
  
  const button = popupEl.querySelector('.popup-save-btn');
  if (!button) return;
  
  const collegeId = button.dataset.collegeId || '';
  if (!collegeId) {
    button.style.display = 'none';
    return;
  }
  
  // Defer button state update to allow popup to appear first (performance optimization)
  // This makes taps feel instant on mobile by not blocking popup appearance
  requestAnimationFrame(() => {
    // Update button state based on saved status
    updatePopupSaveButton(button, collegeId);
  });
  
  // Attach click handler if not already attached
  if (!button.dataset.listenerAttached) {
    button.addEventListener('click', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      
      // Get saved count before toggle to detect 1→2 transition
      const savedCountBefore = SavedStore.getAll().length;
      
      // Toggle saved state
      SavedStore.toggle(collegeId);
      
      // Rule 3: Check if SavedStore becomes empty while saved-only is ON
      const savedIdsAfter = SavedStore.getAll();
      if (savedIdsAfter.length === 0 && savedOnlyMode) {
        // Auto-turn OFF toggle
        savedOnlyMode = false;
        const savedControls = document.getElementById("saved-controls");
        const savedOnlySection = document.getElementById("saved-only-section");
        if (savedControls) {
          savedControls.classList.remove("saved-only-active");
        }
        if (savedOnlySection) {
          savedOnlySection.classList.remove("saved-only-active");
        }
        
        // Show hint
        const hint = document.getElementById('hint-no-saved-colleges');
        if (hint) {
          const hintBody = hint.querySelector('.map-hint-bubble-body');
          if (hintBody) {
            hintBody.textContent = "No saved colleges left on the map — Map Saved Only has been turned off.";
          }
        }
        showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
      } else if (savedIdsAfter.length > 0 && savedOnlyMode) {
        // Rule 4: Check if last visible saved college was removed (even if other saved colleges exist elsewhere)
        if (!hasQualifyingSavedColleges()) {
          // Auto-turn OFF toggle
          savedOnlyMode = false;
          const savedControls = document.getElementById("saved-controls");
          const savedOnlySection = document.getElementById("saved-only-section");
          if (savedControls) {
            savedControls.classList.remove("saved-only-active");
          }
          if (savedOnlySection) {
            savedOnlySection.classList.remove("saved-only-active");
          }
          
          // Show hint
          const hint = document.getElementById('hint-no-saved-colleges');
          if (hint) {
            const hintBody = hint.querySelector('.map-hint-bubble-body');
            if (hintBody) {
              hintBody.textContent = "No saved colleges visible on the map — Map Saved Only has been turned off.";
            }
          }
          showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
        }
      }
      
      // Immediately update button visual state (user action, so update synchronously)
      updatePopupSaveButton(button, collegeId);
      
      // Immediately update pill count
      updateSavedPillCount();
      
      // Check for teaching moment (1→2 transition)
      if (savedCountBefore === 1 && savedIdsAfter.length === 2) {
        checkAndShowSavedOnlyTeachingMoment();
      }
      
      // Update navigation icon visibility when college is saved/unsaved
      updateNavigationIconVisibility();
      
      // Update marker icon
      const marker = markersByCollegeId[collegeId];
      if (marker) {
        const isSaved = SavedStore.isSaved(collegeId);
        const latlng = marker.getLatLng();
        const popup = marker.getPopup();
        const tooltip = marker.getTooltip();
        const popupContent = popup ? popup.getContent() : '';
        const tooltipContent = tooltip ? tooltip.getContent() : '';
        const wasPopupOpen = popup && marker.isPopupOpen();
        
        // Check if transitioning from blue dot to green icon (saving)
        const wasBlueDot = marker instanceof L.CircleMarker;
        const isTransitioningToSaved = wasBlueDot && isSaved;
        
        // Remove old marker
        marker.remove();
        
        // Create new marker with appropriate icon
        let newMarker;
        if (isSaved) {
          // Use green pin icon for saved colleges with dynamic sizing
          const iconSize = getCurrentSavedIconSize();
          newMarker = L.marker(latlng, {
            icon: createGreenSavedIcon(iconSize)
          });
        } else {
          // Use blue circle marker for unsaved colleges with dynamic sizing
          const radius = getCurrentMarkerRadius();
          newMarker = L.circleMarker(latlng, {
            radius: radius,
            color: '#2563eb',
            weight: 2,
            fillOpacity: 0.7
          });
        }
        
        if (popupContent) newMarker.bindPopup(popupContent);
        if (tooltipContent) newMarker.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
        newMarker.addTo(markersLayer);
        markersByCollegeId[collegeId] = newMarker;
        
        // Add transition animation when changing from blue dot to green icon
        if (isTransitioningToSaved) {
          // Small delay to ensure marker is fully rendered in DOM
          setTimeout(() => {
            const markerElement = newMarker.getElement();
            if (markerElement) {
              // Add animation class to marker container
              markerElement.classList.add('marker-save-transition');
              
              // Also target the icon image directly
              const iconImage = markerElement.querySelector('img');
              if (iconImage) {
                iconImage.classList.add('marker-save-transition');
              }
              
              // Remove animation class after animation completes
              setTimeout(() => {
                if (markerElement) {
                  markerElement.classList.remove('marker-save-transition');
                  if (iconImage) {
                    iconImage.classList.remove('marker-save-transition');
                  }
                }
              }, 500);
            }
          }, 10);
        }
        
        // Reopen popup if it was open before
        if (wasPopupOpen) {
          newMarker.openPopup();
        }
      }
      
      // Re-render if saved-only mode is still ON (or if it was turned OFF, re-render without saved-only filter)
      if (savedOnlyMode) {
        if (activeMode === 'route' && route.lastSearch) {
          refilterCollegesAlongRoute();
        } else {
          render();
        }
      } else if (savedIdsAfter.length === 0 || (savedIdsAfter.length > 0 && !hasQualifyingSavedColleges())) {
        // Re-render if toggle was turned OFF (either by Rule 3 or Rule 4)
        if (activeMode === 'route' && route.lastSearch) {
          refilterCollegesAlongRoute();
        } else {
          render();
        }
      }
    });
    button.dataset.listenerAttached = '1';
  }
});

// Handle popup close: re-enable tooltips on visible markers
map.on('popupclose', () => {
  // Re-enable tooltips on visible markers only (performance optimization)
  // Defer to avoid blocking UI
  requestAnimationFrame(() => {
    const bounds = map.getBounds();
    let processedCount = 0;
    const maxProcessPerFrame = 50;
    
    markersLayer.eachLayer((layer) => {
      // Only process markers visible in current viewport
      if (bounds.contains(layer.getLatLng())) {
        const tooltipContent = tooltipStates.get(layer);
        if (tooltipContent) {
          // Rebind tooltip with stored content
          layer.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
          tooltipStates.delete(layer);
          processedCount++;
          
          if (processedCount >= maxProcessPerFrame) {
            return false; // Stop iteration
          }
        }
      }
    });
    
    // If there are more markers to process, continue in next frame
    if (processedCount >= maxProcessPerFrame) {
      setTimeout(() => {
        const bounds = map.getBounds();
        markersLayer.eachLayer((layer) => {
          if (bounds.contains(layer.getLatLng())) {
            const tooltipContent = tooltipStates.get(layer);
            if (tooltipContent) {
              layer.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
              tooltipStates.delete(layer);
            }
          }
        });
      }, 0);
    }
  });
});

// Route state
let route = {
  start: null, // { description, lat, lon }
  end: null,
  lastSearch: null, // { start, end, maxDistance, units }
  lastResult: null // Cached visualization data for restoring route view quickly
};

// Nearby state (for restoration)
let nearbyState = {
  address: null,
  home: null,
  radius: null,
  units: null
};
let lastNearbyFilters = null;

const TYPE_ORDER = ["Ivy League","Elite Private Universities","Public Flagship Universities","Private Liberal Arts Colleges","STEM / Technology Institutes","Business / Arts / Specialty Schools","Health & Medical Colleges","Faith-Based","Public Regional Universities","Community Colleges","Online / For-Profit"];

// Region mapping for better performance
const REGION_MAP = {
  'Northeast': ['ME','NH','VT','MA','RI','CT','NY','NJ','PA'],
  'Midwest': ['OH','MI','IN','IL','WI','MN','IA','MO','ND','SD','NE','KS'],
  'South': ['DE','MD','DC','VA','WV','NC','SC','GA','FL','KY','TN','AL','MS','AR','LA','TX','OK'],
  'West': ['MT','ID','WY','CO','NM','AZ','UT','NV','CA','OR','WA','HI','AK'],
  'Territories': ['PR','GU','VI','AS','MP']
};

// U.S. states and territories mapping
const US_STATES = [
  { code: "AL", name: "Alabama" },
  { code: "AK", name: "Alaska" },
  { code: "AZ", name: "Arizona" },
  { code: "AR", name: "Arkansas" },
  { code: "CA", name: "California" },
  { code: "CO", name: "Colorado" },
  { code: "CT", name: "Connecticut" },
  { code: "DE", name: "Delaware" },
  { code: "FL", name: "Florida" },
  { code: "GA", name: "Georgia" },
  { code: "HI", name: "Hawaii" },
  { code: "ID", name: "Idaho" },
  { code: "IL", name: "Illinois" },
  { code: "IN", name: "Indiana" },
  { code: "IA", name: "Iowa" },
  { code: "KS", name: "Kansas" },
  { code: "KY", name: "Kentucky" },
  { code: "LA", name: "Louisiana" },
  { code: "ME", name: "Maine" },
  { code: "MD", name: "Maryland" },
  { code: "MA", name: "Massachusetts" },
  { code: "MI", name: "Michigan" },
  { code: "MN", name: "Minnesota" },
  { code: "MS", name: "Mississippi" },
  { code: "MO", name: "Missouri" },
  { code: "MT", name: "Montana" },
  { code: "NE", name: "Nebraska" },
  { code: "NV", name: "Nevada" },
  { code: "NH", name: "New Hampshire" },
  { code: "NJ", name: "New Jersey" },
  { code: "NM", name: "New Mexico" },
  { code: "NY", name: "New York" },
  { code: "NC", name: "North Carolina" },
  { code: "ND", name: "North Dakota" },
  { code: "OH", name: "Ohio" },
  { code: "OK", name: "Oklahoma" },
  { code: "OR", name: "Oregon" },
  { code: "PA", name: "Pennsylvania" },
  { code: "RI", name: "Rhode Island" },
  { code: "SC", name: "South Carolina" },
  { code: "SD", name: "South Dakota" },
  { code: "TN", name: "Tennessee" },
  { code: "TX", name: "Texas" },
  { code: "UT", name: "Utah" },
  { code: "VT", name: "Vermont" },
  { code: "VA", name: "Virginia" },
  { code: "WA", name: "Washington" },
  { code: "WV", name: "West Virginia" },
  { code: "WI", name: "Wisconsin" },
  { code: "WY", name: "Wyoming" },
  { code: "DC", name: "District of Columbia" }
];

const US_TERRITORIES = [
  { code: "AS", name: "American Samoa" },
  { code: "GU", name: "Guam" },
  { code: "MP", name: "Northern Mariana Islands" },
  { code: "PR", name: "Puerto Rico" },
  { code: "VI", name: "U.S. Virgin Islands" },
  { code: "FM", name: "Federated States of Micronesia" },
  { code: "MH", name: "Marshall Islands" },
  { code: "PW", name: "Palau" }
];

// Territories to hide from the state dropdown (but still support in data/filtering)
const HIDDEN_TERRITORIES = ['GU', 'MP', 'FM', 'MH', 'PW'];

// Helper: Create a lookup map from code to name (for backward compatibility)
const STATE_NAME_MAP = {};
[...US_STATES, ...US_TERRITORIES].forEach(item => {
  STATE_NAME_MAP[item.code] = item.name;
});

// Calculate distance between two coordinates (Haversine formula)
function calculateDistance(lat1, lon1, lat2, lon2, unit = 'mi') {
  const R = unit === 'mi' ? 3959 : 6371; // Earth radius in miles or km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Debounce function for search input
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function showError(message) {
  if (elements.error) {
    elements.error.textContent = message;
    elements.error.classList.add('active');
    setTimeout(() => {
      if (elements.error) {
        elements.error.classList.remove('active');
      }
    }, 5000);
  }
}

const RECENT_STORAGE_KEYS = {
  nearby: 'ucm_recentAddresses',
  routeStart: 'ucm_routeRecentStart',
  routeEnd: 'ucm_routeRecentEnd'
};
const MAX_RECENT_ITEMS = 5;
const SHARED_RECENT_KEY = 'ucm_recentLocations';
const MAX_SHARED_RECENT_ITEMS = 10;

function escapeHtml(text = '') {
  return text.replace(/&/g, '&amp;')
             .replace(/</g, '&lt;')
             .replace(/>/g, '&gt;')
             .replace(/"/g, '&quot;')
             .replace(/'/g, '&#39;');
}

function loadRecents(storageKey) {
  try {
    const stored = localStorage.getItem(storageKey);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(item => typeof item === 'string' && item.trim().length);
  } catch (error) {
    console.warn('Unable to load recents for key', storageKey, error);
    return [];
  }
}

function loadSharedLocations() {
  try {
    const stored = localStorage.getItem(SHARED_RECENT_KEY);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(item => {
      return item && typeof item.description === 'string' &&
             typeof item.lat === 'number' && !isNaN(item.lat) &&
             typeof item.lon === 'number' && !isNaN(item.lon);
    });
  } catch (error) {
    console.warn('Unable to load shared locations', error);
    return [];
  }
}

function saveSharedLocation(description, lat, lon) {
  if (!description || typeof description !== 'string') return;
  const trimmed = description.trim();
  const latNum = typeof lat === 'number' ? lat : parseFloat(lat);
  const lonNum = typeof lon === 'number' ? lon : parseFloat(lon);
  if (!trimmed || isNaN(latNum) || isNaN(lonNum)) return;
  const normalizedKey = `${trimmed.toLowerCase()}|${latNum.toFixed(6)}|${lonNum.toFixed(6)}`;
  const existing = loadSharedLocations().filter(item => {
    const itemKey = `${(item.description || '').toLowerCase()}|${item.lat.toFixed(6)}|${item.lon.toFixed(6)}`;
    return itemKey !== normalizedKey;
  });
  existing.unshift({ description: trimmed, lat: latNum, lon: lonNum });
  try {
    localStorage.setItem(SHARED_RECENT_KEY, JSON.stringify(existing.slice(0, MAX_SHARED_RECENT_ITEMS)));
  } catch (error) {
    console.warn('Unable to persist shared locations', error);
  }
}

function saveRecent(storageKey, value) {
  if (!storageKey || typeof value !== 'string') return;
  const trimmed = value.trim();
  if (!trimmed.length) return;
  const existing = loadRecents(storageKey).filter(item => item.toLowerCase() !== trimmed.toLowerCase());
  existing.unshift(trimmed);
  try {
    localStorage.setItem(storageKey, JSON.stringify(existing.slice(0, MAX_RECENT_ITEMS)));
  } catch (error) {
    console.warn('Unable to persist recents for key', storageKey, error);
  }
}

function getFallbackRecentsForField(field) {
  if (!field) return [];
  if (field === 'address') return loadRecents(RECENT_STORAGE_KEYS.nearby);
  if (field === 'routeStart') return loadRecents(RECENT_STORAGE_KEYS.routeStart);
  if (field === 'routeEnd') return loadRecents(RECENT_STORAGE_KEYS.routeEnd);
  return [];
}

function clearRecentState(container) {
  if (!container) return;
  delete container.dataset.showingRecents;
  delete container.dataset.recentContext;
}

function shouldShowRecentsForInput(inputElement) {
  if (!inputElement) return false;
  if (document.activeElement !== inputElement) return false;
  return (inputElement.value || '').trim().length < 3;
}

function buildUnifiedRecentSection(fallbackRecents = [], options = {}) {
  const query = (options.query || '').trim().toLowerCase();
  const shouldFilterShared = options.filterShared && query.length > 0;
  const shouldFilterFallback = options.filterFallback && query.length > 0;
  const sharedLocations = loadSharedLocations();
  let sharedItems = sharedLocations;
  if (shouldFilterShared) {
    sharedItems = sharedLocations.filter(loc => (loc.description || '').toLowerCase().startsWith(query));
  }
  let sectionItems = '';
  if (sharedItems.length) {
    sectionItems = sharedItems.map(loc => {
      const encodedDescription = encodeURIComponent(loc.description || '');
      const safeDescription = escapeHtml(loc.description || '');
      const safeDetails = `${loc.lat.toFixed(3)}, ${loc.lon.toFixed(3)}`;
      return `
        <div class="autocomplete-item shared-location" role="option" tabindex="0"
             data-shared="true"
             data-description="${encodedDescription}"
             data-lat="${loc.lat}"
             data-lon="${loc.lon}">
          <div class="autocomplete-item-icon">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
            </svg>
          </div>
          <div class="autocomplete-item-content">
            <div class="address-name">${safeDescription}</div>
            <div class="address-details">${safeDetails}</div>
          </div>
        </div>`;
    }).join('');
  } else {
    let fallbackItems = fallbackRecents;
    if (shouldFilterFallback) {
      fallbackItems = fallbackRecents.filter(value => value.toLowerCase().startsWith(query));
    }
    if (fallbackItems.length) {
      sectionItems = fallbackItems.map(value => {
        const encodedValue = encodeURIComponent(value);
        const safeValue = escapeHtml(value);
        return `
          <div class="autocomplete-item recent-suggestion" role="option" tabindex="0" data-recent="true" data-value="${encodedValue}">
            <div class="autocomplete-item-icon">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2a10 10 0 1 0 10 10A10.011 10.011 0 0 0 12 2zm0 18a8 8 0 1 1 8-8a8.009 8.009 0 0 1-8 8zm.75-12h-1.5v5l4.25 2.55l.75-1.23l-3.5-2.07z"/>
              </svg>
            </div>
            <div class="autocomplete-item-content">
              <div class="address-name">${safeValue}</div>
            </div>
          </div>`;
      }).join('');
    }
  }
  if (!sectionItems) {
    return '';
  }
  return `
    <div class="autocomplete-section-title">Recent locations</div>
    ${sectionItems}
    <div class="autocomplete-divider" role="separator"></div>`;
}

function toggleAutocompleteLayer(inputElement, isActive) {
  const wrapper = inputElement ? inputElement.closest('.address-autocomplete') : null;
  if (!wrapper) return;
  if (isActive) {
    wrapper.classList.add('autocomplete-active');
  } else {
    wrapper.classList.remove('autocomplete-active');
  }
}

function showRecentSuggestions(container, recents, inputElement, context, options = {}) {
  if (!container || !inputElement) return false;
  const unifiedSection = buildUnifiedRecentSection(recents, options);
  if (!unifiedSection) {
    clearRecentState(container);
    return false;
  }
  container.innerHTML = unifiedSection;
  container.classList.add('active');
  container.dataset.showingRecents = 'true';
  container.dataset.recentContext = context || '';
  inputElement.setAttribute('aria-expanded', 'true');
  return true;
}

function showAddressRecentsIfEligible() {
  if (!elements.address || !elements.addressSuggestions) return false;
  const queryValue = (elements.address.value || '').trim();
  if (!shouldShowRecentsForInput(elements.address)) {
    return false;
  }
  const recents = loadRecents(RECENT_STORAGE_KEYS.nearby);
  const shown = showRecentSuggestions(
    elements.addressSuggestions,
    recents,
    elements.address,
    'address',
    {
      query: queryValue,
      filterShared: true,
      filterFallback: true
    }
  );
  if (shown) {
    addressAutocomplete.suggestions = [];
    addressAutocomplete.selectedIndex = -1;
  }
  return shown;
}

function showRouteRecentsIfEligible(inputElement, suggestionsContainer, autocompleteObj, storageKey, context) {
  if (!inputElement || !suggestionsContainer) return false;
  const queryValue = (inputElement.value || '').trim();
  if (!shouldShowRecentsForInput(inputElement)) {
    return false;
  }
  const recents = loadRecents(storageKey);
  const shown = showRecentSuggestions(
    suggestionsContainer,
    recents,
    inputElement,
    context,
    {
      query: queryValue,
      filterShared: true,
      filterFallback: true
    }
  );
  if (shown && autocompleteObj) {
    autocompleteObj.suggestions = [];
    autocompleteObj.selectedIndex = -1;
  }
  return shown;
}

function handleRecentAddressSelection(value) {
  if (!value) return;
  addressAutocomplete.suggestions = [{ description: value }];
  selectSuggestion(0);
}

function handleRecentRouteSelection(value, context) {
  if (!value) return;
  if (context === 'routeStart' && elements.routeStart && elements.routeStartSuggestions) {
    routeStartAutocomplete.suggestions = [{ description: value }];
    selectRouteSuggestion(0, routeStartAutocomplete, elements.routeStart, elements.routeStartSuggestions);
  } else if (context === 'routeEnd' && elements.routeEnd && elements.routeEndSuggestions) {
    routeEndAutocomplete.suggestions = [{ description: value }];
    selectRouteSuggestion(0, routeEndAutocomplete, elements.routeEnd, elements.routeEndSuggestions);
  }
}

function handleSharedLocationSelection(field, description) {
  if (!field || !description) return;
  if (field === 'address') {
    handleRecentAddressSelection(description);
  } else if (field === 'routeStart') {
    handleRecentRouteSelection(description, 'routeStart');
  } else if (field === 'routeEnd') {
    handleRecentRouteSelection(description, 'routeEnd');
  }
}

function getRouteFilterSignature() {
  const typeVal = elements.type ? elements.type.value.trim() : '';
  const regionVal = elements.region ? elements.region.value.trim() : '';
  const stateVal = elements.state ? elements.state.value.trim() : '';
  const rankingVal = elements.ranking ? elements.ranking.value.trim() : '';
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  // Parse maxDistance - handle 0 correctly (don't use || operator as 0 is falsy)
  const maxDistanceInputStr = elements.routeMaxDistance?.value;
  let maxDistanceInput;
  if (maxDistanceInputStr === '' || maxDistanceInputStr === null || maxDistanceInputStr === undefined) {
    maxDistanceInput = 30;
  } else {
    maxDistanceInput = parseFloat(maxDistanceInputStr);
    if (isNaN(maxDistanceInput)) {
      maxDistanceInput = 30;
    }
  }
  // If maxDistance is 0, use 0.5 instead
  const maxDistance = maxDistanceInput === 0 ? 0.5 : maxDistanceInput;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  return { typeVal, regionVal, stateVal, rankingVal, searchVal, maxDistance, units };
}

function addRouteCollegeMarker(college, distanceText, units) {
  try {
    if (isNaN(college.lat) || isNaN(college.lon) || college.lat === 0 || college.lon === 0) {
      console.warn(`Invalid coordinates for ${college.name}:`, college.lat, college.lon);
      return;
    }

    const tuition = college.tuition ? (college.tuition.toString().includes('$') ? college.tuition : `$${Number(college.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = college.acceptance ? (college.acceptance.toString().includes('%') ? college.acceptance : `${parseFloat(college.acceptance).toFixed(1)}%`) : 'N/A';

    const saveButtonHtml = college.college_id ? `
      <div class="popup-save-row">
        <button type="button" class="popup-save-btn" data-college-id="${college.college_id}">
          <span class="popup-save-icon" aria-hidden="true">☆</span>
          <span class="popup-save-label">Save</span>
        </button>
      </div>` : '';

    // Style distance text to be blue and bold (only for route popups)
    let styledDistanceText = distanceText || '';
    if (styledDistanceText) {
      // Match pattern like "Distance from route: 5.2 mi" or "Approx. distance from route: 5.2 mi"
      styledDistanceText = styledDistanceText.replace(/(\d+\.?\d*)\s*(mi|km)/g, '<span style="color: #2563eb; font-weight: bold;">$1 $2</span>');
    }
    
    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${college.name}</b><br>
        ${college.state} · ${(college.type||'Unknown')}${styledDistanceText}<br>
        ${college.control ? college.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${college.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${college.url ? `<div style="border-top: 1px solid #e2e8f0; margin: 8px 0; padding-top: 8px;">For official, up-to-date info:<br><a href="https://${college.url.replace(/^https?:\/\//,'')}" target="_blank">${college.url}</a></div>` : ''}
        ${saveButtonHtml}
      </div>`;

    const marker = createCollegeMarker(college, popupContent, college.college_id);
    marker.addTo(markersLayer);
  } catch (e) {
    console.error(`Error creating marker for ${college.name}:`, e);
  }
}

function areNearbySignaturesEqual(a, b) {
  if (!a || !b) return false;
  const keys = ['typeVal', 'regionVal', 'stateVal', 'rankingVal', 'searchVal', 'radiusVal', 'unitsVal', 'homeLat', 'homeLon'];
  return keys.every(key => (a[key] ?? '') === (b[key] ?? ''));
}

function isRouteCacheValid(cache, filters, currentStart, currentEnd) {
  if (!cache || !cache.filters || !filters) return false;
  const keys = ['typeVal', 'regionVal', 'stateVal', 'rankingVal', 'searchVal', 'maxDistance', 'units'];
  const filtersMatch = keys.every(key => (cache.filters[key] || '') === (filters[key] || ''));
  const sameStart = cache.start && currentStart &&
    cache.start.lat === currentStart.lat &&
    cache.start.lon === currentStart.lon &&
    (cache.start.description || '') === (currentStart.description || '');
  const sameEnd = cache.end && currentEnd &&
    cache.end.lat === currentEnd.lat &&
    cache.end.lon === currentEnd.lon &&
    (cache.end.description || '') === (currentEnd.description || '');
  return filtersMatch && sameStart && sameEnd && Array.isArray(cache.routeCoords) && cache.routeCoords.length > 0;
}

function restoreRouteFromCache(cache, options = {}) {
  if (!cache) return false;
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;

  // Draw route with ribbon effect
  const zoom = map ? map.getZoom() : 5;
  const routeWeights = calculateRouteLineWeights(zoom);
  
  // First draw the deep navy outline (thin line for ribbon effect)
  routeOutlinePolyline = L.polyline(cache.routeCoords, {
    color: '#0A2CA5',
    weight: routeWeights.outlineWeight,
    opacity: routeWeights.outlineOpacity
  }).addTo(routeLayer);
  // Then draw the vivid royal blue main route line on top
  routeMainPolyline = L.polyline(cache.routeCoords, {
    color: '#1A4CFF',
    weight: routeWeights.mainWeight,
    opacity: routeWeights.mainOpacity
  }).addTo(routeLayer);

  const startData = cache.start;
  if (startData) {
    L.marker([startData.lat, startData.lon], {
      icon: L.icon({
        iconUrl: ROUTE_START_PIN_ICON,
        iconSize: [18, 18],
        iconAnchor: [9, 9],
        popupAnchor: [0, -9]
      })
    }).addTo(routeLayer).bindPopup('From');
  }

  const endData = cache.end;
  if (endData) {
    L.marker([endData.lat, endData.lon], {
      icon: L.icon({
        iconUrl: ROUTE_END_PIN_ICON,
        iconSize: [24, 30],
        iconAnchor: [12, 30],
        popupAnchor: [0, -30]
      })
    }).addTo(routeLayer).bindPopup('To');
  }

  const units = cache.filters?.units || 'mi';
  let collegesToRender = cache.colleges || [];
  
  // Apply saved-only filter if enabled
  if (savedOnlyMode) {
    collegesToRender = collegesToRender.filter(item => SavedStore.isSaved(item.college.college_id));
  }
  
  collegesToRender.forEach(item => {
    addRouteCollegeMarker(item.college, item.distanceText || '', units);
  });

  if (elements.count) elements.count.textContent = collegesToRender.length;
  updateMapHints(
    collegesToRender.length,
    cache.filters?.typeVal || '',
    cache.filters?.regionVal || '',
    cache.filters?.stateVal || '',
    cache.filters?.searchVal || ''
  );

  if (!options.preserveView) {
    let boundsToUse = cache.bounds;
    
    // If saved-only mode is ON, recalculate bounds based on visible colleges
    if (savedOnlyMode && cache.colleges && cache.colleges.length > 0) {
      const visibleColleges = cache.colleges.filter(item => 
        SavedStore.isSaved(item.college.college_id)
      );
      if (visibleColleges.length > 0) {
        const visibleBounds = L.latLngBounds(cache.routeCoords);
        visibleColleges.forEach(item => {
          visibleBounds.extend([item.college.lat, item.college.lon]);
        });
        if (visibleBounds.isValid()) {
          boundsToUse = visibleBounds;
        }
      }
    }
    
    if (boundsToUse && boundsToUse.isValid()) {
      map.fitBounds(boundsToUse.pad(0.15));
    } else if (cache.routeCoords && cache.routeCoords.length) {
      map.fitBounds(L.latLngBounds(cache.routeCoords), { padding: [50, 50] });
    }
  }
  if (elements.loading) elements.loading.classList.remove('active');
  return true;
}

// Re-filter colleges along route without redrawing the route line
function refilterCollegesAlongRoute() {
  if (!route.lastResult || !route.lastResult.routeCoords) {
    // No cached route, need to fetch it
    findCollegesAlongRoute();
    return;
  }
  
  const cache = route.lastResult;
  const routeCoords = cache.routeCoords;
  
  // Skip if this is a fallback route (only 2 points = straight line)
  // We don't want to process fallback routes when toggling saved-only
  if (routeCoords.length <= 2) {
    console.log('Skipping refilter - route is a fallback straight line');
    return;
  }
  // Parse maxDistance - handle 0 correctly (don't use || operator as 0 is falsy)
  const maxDistanceInputStr = elements.routeMaxDistance?.value;
  let maxDistanceInput;
  if (maxDistanceInputStr === '' || maxDistanceInputStr === null || maxDistanceInputStr === undefined) {
    maxDistanceInput = 30;
  } else {
    maxDistanceInput = parseFloat(maxDistanceInputStr);
    if (isNaN(maxDistanceInput)) {
      maxDistanceInput = 30;
    }
  }
  // If maxDistance is 0, use 0.5 instead
  const maxDistance = maxDistanceInput === 0 ? 0.5 : maxDistanceInput;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  
  // Apply other filters first (cheaper checks before distance calculation)
  const typeVal = elements.type ? elements.type.value.trim() : '';
  const regionVal = elements.region ? elements.region.value.trim() : '';
  const stateVal = elements.state ? elements.state.value.trim() : '';
  const rankingVal = elements.ranking ? elements.ranking.value.trim() : '';
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  
  // Build current filter object for comparison (normalize values for accurate comparison)
  const currentFilters = {
    typeVal: typeVal || '',
    regionVal: regionVal || '',
    stateVal: stateVal || '',
    rankingVal: rankingVal || '',
    searchVal: searchVal || '',
    maxDistance: maxDistance,
    units: units || 'mi'
  };
  
  // Check if filters match cached filters (excluding savedOnlyMode which is not stored in cache)
  const cachedFilters = cache.filters || {};
  const filtersMatch = 
    (currentFilters.typeVal === (cachedFilters.typeVal || '')) &&
    (currentFilters.regionVal === (cachedFilters.regionVal || '')) &&
    (currentFilters.stateVal === (cachedFilters.stateVal || '')) &&
    (currentFilters.rankingVal === (cachedFilters.rankingVal || '')) &&
    (currentFilters.searchVal === (cachedFilters.searchVal || '')) &&
    (Math.abs(currentFilters.maxDistance - (cachedFilters.maxDistance || 30)) < 0.001) && // Use epsilon for float comparison
    (currentFilters.units === (cachedFilters.units || 'mi'));
  
  let routeEntries;
  
  // Optimization: If filters match, reuse cached colleges (skip expensive distance calculations)
  if (filtersMatch && cache.colleges && Array.isArray(cache.colleges) && cache.colleges.length > 0) {
    // Reuse cached route entries - only need to apply saved-only filter
    routeEntries = cache.colleges;
  } else {
    // Filters changed or no cache - recalculate distances
    // Sample route points for performance (check every 3rd point for long routes)
    const sampleRate = routeCoords.length > 100 ? 3 : 1;
    const sampledRoute = [];
    for (let i = 0; i < routeCoords.length; i += sampleRate) {
      sampledRoute.push(routeCoords[i]);
    }
    if (sampledRoute[sampledRoute.length - 1] !== routeCoords[routeCoords.length - 1]) {
      sampledRoute.push(routeCoords[routeCoords.length - 1]);
    }
    
    // Pre-filter by other criteria before expensive distance calculations
    const preFiltered = colleges.filter(c => {
      if (typeVal && (c.type || c.tier) !== typeVal) return false;
      if (regionVal) {
        const regionStates = REGION_MAP[regionVal] || [];
        if (!regionStates.includes(c.state)) return false;
      }
      if (stateVal && c.state !== stateVal) return false;
      if (rankingVal) {
        if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
        if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
        if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
        if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
      }
      if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
      return true;
    });
    
    // Filter by distance to route - always calculate true minimum across all segments for accurate display
    routeEntries = preFiltered.map(c => {
      let minRouteDist = Infinity;
      
      // Check all segments to find the true minimum distance (no early exit for accuracy)
      for (let i = 0; i < sampledRoute.length - 1; i++) {
        const segmentStart = sampledRoute[i];
        const segmentEnd = sampledRoute[i + 1];
        const dist = distanceToLineSegment(
          c.lat, c.lon,
          segmentStart[0], segmentStart[1],
          segmentEnd[0], segmentEnd[1],
          units
        );
        
        // Always track true minimum across all segments for accurate display
        minRouteDist = Math.min(minRouteDist, dist);
      }
      
      return { college: c, distance: minRouteDist };
    }).filter(item => item.distance <= maxDistance) // Filter by true minimum distance
      .map(item => {
        // Create distance text using the true minimum distance
        const distanceText = item.distance < Infinity 
          ? `<br>Distance from route: ${item.distance.toFixed(1)} ${units}`
          : '';
        return { college: item.college, distanceText };
      });
    
    // Update cache with new results
    route.lastResult.colleges = routeEntries;
    route.lastResult.filters = currentFilters;
  }
  
  const visibleRouteEntries = savedOnlyMode
    ? routeEntries.filter(item => SavedStore.isSaved(item.college.college_id))
    : routeEntries;
  
  if (visibleRouteEntries.length === 0 && savedOnlyMode) {
    const savedCount = SavedStore.getAll().length;
    if (savedCount === 0) {
      console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
    } else {
      console.log("No saved colleges match your current filters or route.");
    }
  }
  
  // Clear and render markers only (don't touch routeLayer)
  markersLayer.clearLayers();
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  
  // Calculate bounds for ALL colleges (for caching/restoration)
  const routeBounds = L.latLngBounds(routeCoords);
  routeEntries.forEach(item => {
    routeBounds.extend([item.college.lat, item.college.lon]);
  });
  
  // Calculate bounds for VISIBLE colleges (for map focus)
  const visibleRouteBounds = L.latLngBounds(routeCoords);
  visibleRouteEntries.forEach(item => {
    visibleRouteBounds.extend([item.college.lat, item.college.lon]);
    addRouteCollegeMarker(item.college, item.distanceText, units);
  });
  
  if (elements.count) elements.count.textContent = visibleRouteEntries.length;
  updateMapHints(visibleRouteEntries.length, typeVal, regionVal, stateVal, searchVal);
  
  // Note: Cache is already updated in the else block above when recalculating
  
  // Store ALL colleges bounds (for caching/restoration)
  if (routeBounds.isValid()) {
    route.lastResult.bounds = routeBounds;
  }
  
  // Map focus logic: use visible bounds for map focus
  if (visibleRouteBounds.isValid()) {
    if (visibleRouteEntries.length > 0) {
      map.fitBounds(visibleRouteBounds.pad(0.15));
    } else {
      // If no visible colleges, fit to route polyline only
      const polylineBounds = L.latLngBounds(routeCoords);
      if (polylineBounds.isValid()) {
        map.fitBounds(polylineBounds.pad(0.15));
      }
    }
  }
  
  // Update navigation icon visibility after refiltering
  updateNavigationIconVisibility();
  
  // Check if saved-only mode should be turned OFF after filter change
  checkAndHandleNoVisibleSavedColleges();
}

/**
 * Render colleges on the map based on current filters.
 * 
 * Performance: This function is NOT called during map pan/zoom interactions.
 * Markers are only re-rendered when:
 * - User changes filters (Type, Region, State, Search)
 * - User sets/changes address/radius
 * - User switches between Nearby/Route modes
 * - NOT during map dragging/zooming (Leaflet handles marker visibility automatically)
 */
function render(){
  // Only render in nearby mode - route mode uses findCollegesAlongRoute()
  if (activeMode === 'route') {
    // If route search has been performed, re-run it with updated filters
    if (route.lastSearch) {
      findCollegesAlongRoute();
    } else {
      // If in route mode but no route search, show colleges based on filters only
      // Clear route visualization
      routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      
      // Apply filters from dropdowns
      const stateVal = elements.state ? elements.state.value : '';
      const regionVal = elements.region ? elements.region.value : '';
      const typeVal = elements.type ? elements.type.value : '';
      const rankingVal = elements.ranking ? elements.ranking.value : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      
      let filtered = colleges.filter(c => {
        // Region filter
        const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
        if (!regionMatch) return false;
        
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        
        // Type filter
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        
        // Ranking filter
        if (rankingVal) {
          if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
          if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
          if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
          if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
        }
        
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        return true;
      });
      
      // Apply saved-only filter if enabled
      if (savedOnlyMode) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(c => SavedStore.isSaved(c.college_id));
        
        // Edge case: Show message if no saved colleges match filters
        if (filtered.length === 0) {
          const savedCount = SavedStore.getAll().length;
          if (savedCount === 0) {
            // No saved colleges at all
            console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
          } else {
            // Saved colleges exist but don't match current filters
            console.log("No saved colleges match your current filters or route.");
          }
        }
      }
      
      // Calculate bounds for map focus (same logic as nearby mode)
      const routeFilterBounds = filtered.length > 1 ? L.latLngBounds([]) : null;
      const isDefaultRouteState = !regionVal && !stateVal && !typeVal && !rankingVal && !searchVal;
      const isSearchOnlyFilter = !!searchVal && !regionVal && !stateVal && !typeVal && !rankingVal;
      
      // Render filtered colleges
      filtered.forEach(c => {
        try {
          if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
            return;
          }
          
    const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
          
          const saveButtonHtml = c.college_id ? `
            <div class="popup-save-row">
              <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
                <span class="popup-save-icon" aria-hidden="true">☆</span>
                <span class="popup-save-label">Save</span>
              </button>
            </div>` : '';

    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${c.name}</b><br>
        ${c.state} · ${(c.type||'Unknown')}<br>
        ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${c.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${c.url ? `<div style="border-top: 1px solid #e2e8f0; margin: 8px 0; padding-top: 8px;">For official, up-to-date info:<br><a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a></div>` : ''}
              ${saveButtonHtml}
      </div>`;

          const marker = createCollegeMarker(c, popupContent, c.college_id);
          marker.addTo(markersLayer);
          if (routeFilterBounds) {
            routeFilterBounds.extend(marker.getLatLng());
          }
        } catch (e) {
          console.error(`Error creating marker for ${c.name}:`, e);
        }
      });
      
      if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
      
      // Show tip bubble when blue dots first appear (first-time users only)
      // Check if we have any blue dots (unsaved markers) and haven't shown the tip yet
      if (filtered.length > 0 && sessionStorage.getItem('ucm_seenTapDotHint') !== '1') {
        // Check if there are any unsaved markers (blue dots)
        let hasBlueDots = false;
        markersLayer.eachLayer((layer) => {
          if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius !== undefined)) {
            hasBlueDots = true;
            return false; // Break the loop
          }
        });
        
        if (hasBlueDots) {
          // Wait a bit for map to finish rendering, then show tip
          setTimeout(() => {
            showMapTip();
          }, 300);
        }
      }
      
      // Update map hints for route mode (no route search yet)
      updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
      
      // Map focus logic (same as nearby mode when no route is set)
      // Special handling for Territories region - zoom out to show global view
      if (regionVal === 'Territories') {
        if (filtered.length === 0) {
          // No results, show global view that includes all US territories
          map.setView([10, -170], 2);
        } else if (filtered.length === 1) {
          // Single college, zoom to it
          map.setView([filtered[0].lat, filtered[0].lon], 8);
        } else if (routeFilterBounds && routeFilterBounds.isValid()) {
          // Multiple colleges - fit bounds with padding, no mainland constraint
          const paddedBounds = routeFilterBounds.pad(0.2);
          map.fitBounds(paddedBounds);
        } else {
          // Fallback: global view centered on Pacific
          map.setView([10, -170], 2);
        }
      } else if (isDefaultRouteState || isSearchOnlyFilter) {
        // When no filters are active, restore to default US view
        const defaultView = getInitialNearbyView();
        map.setView([defaultView.center.lat, defaultView.center.lng], defaultView.zoom);
        // Update mapViewState to reflect the default view
        mapViewState.nearby = { ...defaultView };
        captureMapView('nearby');
      } else if (filtered.length === 0) {
        // No results - restore default US view
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      } else if (filtered.length === 1) {
        // Single college - zoom to it
        map.setView([filtered[0].lat, filtered[0].lon], 8);
      } else if (routeFilterBounds && routeFilterBounds.isValid()) {
        // Multiple colleges - fit bounds with padding and mainland constraint
        const paddedBounds = routeFilterBounds.pad(0.15);
        let constrainedBounds = paddedBounds;
        if (stateVal) {
          // Check if all filtered colleges are in the same state, and if that state is outside mainland
          const allSameState = filtered.every(c => c.state === stateVal);
          if (allSameState) {
            // Check if this state's colleges are outside mainland bounds
            const boundsSouth = routeFilterBounds.getSouth();
            const boundsWest = routeFilterBounds.getWest();
            const boundsNorth = routeFilterBounds.getNorth();
            const boundsEast = routeFilterBounds.getEast();
            const isOutsideMainland = 
              boundsSouth < US_MAINLAND_VIEW.getSouth() ||
              boundsWest < US_MAINLAND_VIEW.getWest() ||
              boundsNorth > US_MAINLAND_VIEW.getNorth() ||
              boundsEast > US_MAINLAND_VIEW.getEast();
            // If explicitly selected state is outside mainland, don't clamp
            if (isOutsideMainland) {
              constrainedBounds = paddedBounds;
            } else {
              constrainedBounds = clampBoundsToMainland(paddedBounds);
            }
          } else {
            // Mixed states - apply clamping
            constrainedBounds = clampBoundsToMainland(paddedBounds);
          }
        } else {
          // No state filter - apply clamping to prevent showing empty ocean
          constrainedBounds = clampBoundsToMainland(paddedBounds);
        }
        map.fitBounds(constrainedBounds);
      } else {
        // Fallback: restore default US view
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    }
    return;
  }
  
  // Clear route visualization when in nearby mode
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  
  // Check if colleges data is loaded
  if (!colleges || colleges.length === 0) {
    console.log('No colleges data available yet');
    if (elements.count) elements.count.textContent = '0';
    return;
  }
  
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  radiusLayer.clearLayers();
  
  const stateVal = elements.state ? elements.state.value : '';
  const regionVal = elements.region ? elements.region.value : '';
  const typeVal = elements.type ? elements.type.value : '';
  const rankingVal = elements.ranking ? elements.ranking.value : '';
  // Get search value from either desktop or mobile search field (prefer the one with a value, or desktop first)
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  const radiusVal = parseFloat(elements.radius?.value || '0') || 0;
  const unitsVal = elements.units ? elements.units.value : 'mi';
  const nearbySignature = {
    typeVal,
    regionVal,
    stateVal,
    rankingVal,
    searchVal,
    radiusVal,
    unitsVal,
    homeLat: home ? Number(home.lat.toFixed(6)) : null,
    homeLon: home ? Number(home.lon.toFixed(6)) : null
  };
  const shouldAutoFrameNearby = !lastNearbyFilters || !mapViewState.nearby || !areNearbySignaturesEqual(lastNearbyFilters, nearbySignature);
  const isDefaultNearbyState = !home && !regionVal && !stateVal && !typeVal && !rankingVal && !searchVal;
  const isSearchOnlyFilter = !!searchVal && !home && !regionVal && !stateVal && !typeVal && !rankingVal;

  // Pre-filter by cheaper criteria first, then calculate distance only for matching colleges
  let filtered = colleges.filter(c => {
    // Region filter
    const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
    if (!regionMatch) return false;
    
    // State filter
    if (stateVal && c.state !== stateVal) return false;
    
    // Type filter
    if (typeVal && (c.type || c.tier) !== typeVal) return false;
    
    // Ranking filter
    if (rankingVal) {
      if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
      if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
      if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
      if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
    }
    
    // Search filter
    if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
    
    return true;
  });
  
  // Cache distance calculations for nearby mode
  const distanceCache = new Map();
  if (home) {
    const effectiveRadius = radiusVal === 0 ? 0.5 : radiusVal;
    filtered = filtered.filter(c => {
      // Calculate and cache distance
      const cacheKey = `${c.lat.toFixed(4)}_${c.lon.toFixed(4)}`;
      let distance = distanceCache.get(cacheKey);
      if (distance === undefined) {
        distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
        distanceCache.set(cacheKey, distance);
      }
      return distance <= effectiveRadius;
    });
  }
  
  // Apply saved-only filter if enabled
  if (savedOnlyMode) {
    filtered = filtered.filter(c => {
      const isSaved = SavedStore.isSaved(c.college_id);
      return isSaved;
    });
    
    // Edge case: Show message if no saved colleges match filters
    if (filtered.length === 0) {
      const savedCount = SavedStore.getAll().length;
      if (savedCount === 0) {
        // No saved colleges at all
        console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
      } else {
        // Saved colleges exist but don't match current filters
        console.log("No saved colleges match your current filters or route.");
      }
    }
  }

  // Draw radius circle if home is set (use 0.5 if radius is 0)
  if (home) {
    const effectiveRadius = radiusVal === 0 ? 0.5 : radiusVal;
    const radiusMeters = effectiveRadius * (unitsVal === 'mi' ? 1609.34 : 1000);
    L.circle([home.lat, home.lon], {
      radius: radiusMeters,
      color: '#2563eb',
      fillColor: '#2563eb',
      fillOpacity: 0.1,
      weight: 2,
      dashArray: '5, 5'
    }).addTo(radiusLayer);
  }

  const nearbyBounds = filtered.length > 1 ? L.latLngBounds([]) : null;
  filtered.forEach(c => {
    try {
      // Validate coordinates
      if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
        console.warn(`Invalid coordinates for ${c.name}:`, c.lat, c.lon);
        return;
      }
      
    const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
      
      // Calculate distance if home is set (use cached value if available)
      let distanceText = '';
      if (home) {
        const cacheKey = `${c.lat.toFixed(4)}_${c.lon.toFixed(4)}`;
        let distance = distanceCache.get(cacheKey);
        if (distance === undefined) {
          distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
          distanceCache.set(cacheKey, distance);
        }
        distanceText = `<br>Distance: ${distance.toFixed(1)} ${unitsVal}`;
      }
      
      // Style distance text to be blue and bold (for nearby popups)
      let styledDistanceText = distanceText || '';
      if (styledDistanceText) {
        // Match pattern like "Distance: 5.2 mi"
        styledDistanceText = styledDistanceText.replace(/(\d+\.?\d*)\s*(mi|km)/g, '<span style="color: #2563eb; font-weight: bold;">$1 $2</span>');
      }
      
    const saveButtonHtml = c.college_id ? `
      <div class="popup-save-row">
        <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
          <span class="popup-save-icon" aria-hidden="true">☆</span>
          <span class="popup-save-label">Save</span>
        </button>
      </div>` : '';

    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${c.name}</b><br>
          ${c.state} · ${(c.type||'Unknown')}${styledDistanceText}<br>
        ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${c.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${c.url ? `<div style="border-top: 1px solid #e2e8f0; margin: 8px 0; padding-top: 8px;">For official, up-to-date info:<br><a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a></div>` : ''}
        ${saveButtonHtml}
      </div>`;

    const marker = createCollegeMarker(c, popupContent, c.college_id);
    marker.addTo(markersLayer);
    if (nearbyBounds) {
      nearbyBounds.extend(marker.getLatLng());
    }
    } catch (e) {
      console.error(`Error creating marker for ${c.name}:`, e);
    }
  });

  if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
  
  // Show tip bubble when blue dots first appear (first-time users only)
  // Check if we have any blue dots (unsaved markers) and haven't shown the tip yet
  if (filtered.length > 0 && sessionStorage.getItem('ucm_seenTapDotHint') !== '1') {
    // Check if there are any unsaved markers (blue dots)
    let hasBlueDots = false;
    markersLayer.eachLayer((layer) => {
      if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius !== undefined)) {
        hasBlueDots = true;
        return false; // Break the loop
      }
    });
    
    if (hasBlueDots) {
      // Wait a bit for map to finish rendering, then show tip
      setTimeout(() => {
        showMapTip();
      }, 300);
    }
  }
  
  // Update map hints based on filtered results
  updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
  
  if (shouldAutoFrameNearby) {
    // Special handling for Territories region - zoom out to show global view
    if (regionVal === 'Territories') {
      if (filtered.length === 0) {
        // No results, show global view that includes all US territories
        // Territories span: PR/VI (Caribbean), GU/MP (Western Pacific), AS (South Pacific)
        // Use a wide view centered on Pacific to show all territories
        map.setView([10, -170], 2);
      } else if (filtered.length === 1) {
        // Single college, zoom to it
        map.setView([filtered[0].lat, filtered[0].lon], 8);
      } else if (nearbyBounds && nearbyBounds.isValid()) {
        // Multiple colleges - fit bounds with padding, no mainland constraint
        // Territories are spread globally, so don't clamp to mainland
        const paddedBounds = nearbyBounds.pad(0.2);
        map.fitBounds(paddedBounds);
      } else {
        // Fallback: global view centered on Pacific
        map.setView([10, -170], 2);
      }
    } else if (isDefaultNearbyState || isSearchOnlyFilter) {
      // When no filters are active, restore to default US view (not saved view which might be from a territory)
      const defaultView = getInitialNearbyView();
      map.setView([defaultView.center.lat, defaultView.center.lng], defaultView.zoom);
      // Update mapViewState to reflect the default view
      mapViewState.nearby = { ...defaultView };
      captureMapView('nearby');
    } else if (filtered.length === 0) {
      if (home) {
        map.setView([home.lat, home.lon], 8);
      } else {
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    } else if (filtered.length === 1) {
      map.setView([filtered[0].lat, filtered[0].lon], 8);
    } else if (nearbyBounds && nearbyBounds.isValid()) {
      const paddedBounds = nearbyBounds.pad(0.15);
      // Only clamp to mainland if no state filter is active, or if the state filter is for a mainland state
      // This allows territories like AS, HI, AK, PR to be shown when explicitly selected
      let constrainedBounds = paddedBounds;
      if (stateVal) {
        // Check if all filtered colleges are in the same state, and if that state is outside mainland
        // If user explicitly selected a non-mainland state, don't clamp
        const allSameState = filtered.every(c => c.state === stateVal);
        if (allSameState) {
          // Check if this state's colleges are outside mainland bounds
          const boundsSouth = nearbyBounds.getSouth();
          const boundsWest = nearbyBounds.getWest();
          const boundsNorth = nearbyBounds.getNorth();
          const boundsEast = nearbyBounds.getEast();
          const isOutsideMainland = 
            boundsSouth < US_MAINLAND_VIEW.getSouth() ||
            boundsWest < US_MAINLAND_VIEW.getWest() ||
            boundsNorth > US_MAINLAND_VIEW.getNorth() ||
            boundsEast > US_MAINLAND_VIEW.getEast();
          // If explicitly selected state is outside mainland, don't clamp
          if (isOutsideMainland) {
            constrainedBounds = paddedBounds;
          } else {
            constrainedBounds = clampBoundsToMainland(paddedBounds);
          }
        } else {
          // Mixed states - apply clamping
          constrainedBounds = clampBoundsToMainland(paddedBounds);
        }
      } else {
        // No state filter - apply clamping to prevent showing empty ocean
        constrainedBounds = clampBoundsToMainland(paddedBounds);
      }
      map.fitBounds(constrainedBounds);
    } else if (home) {
      map.setView([home.lat, home.lon], 8);
    } else {
      map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
    }
  } else {
    if (!applySavedMapView('nearby')) {
      if (home) {
        map.setView([home.lat, home.lon], 8);
      } else {
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    }
  }
  lastNearbyFilters = nearbySignature;
}

function refreshDropdown(id, values, placeholder) {
  const select = document.getElementById(id);
  // Special handling for state dropdown: use codes as values but full names as labels
  if (id === 'state') {
    // Create sets of available state and territory codes from the data
    const availableCodes = new Set(values);
    
    // Filter and sort states by name
    const availableStates = US_STATES
      .filter(state => availableCodes.has(state.code))
      .sort((a, b) => a.name.localeCompare(b.name));
    
    // Filter and sort territories by name (excluding hidden territories)
    const availableTerritories = US_TERRITORIES
      .filter(territory => availableCodes.has(territory.code) && !HIDDEN_TERRITORIES.includes(territory.code))
      .sort((a, b) => a.name.localeCompare(b.name));
    
    // Build HTML: placeholder, states, divider (if territories exist), territories
    let html = `<option value="">${placeholder}</option>`;
    
    // Add states
    availableStates.forEach(state => {
      html += `<option value="${state.code}">${state.name}</option>`;
    });
    
    // Add divider if there are territories
    if (availableTerritories.length > 0) {
      html += `<option value="" disabled class="state-divider">U.S. territories & associated states</option>`;
    }
    
    // Add territories
    availableTerritories.forEach(territory => {
      html += `<option value="${territory.code}">${territory.name}</option>`;
    });
    
    select.innerHTML = html;
  } else {
    select.innerHTML = `<option value="">${placeholder}</option>` + values.map(v => `<option>${v}</option>`).join('');
  }
  // Ensure font-size is consistent after dropdown refresh (especially for mobile/tablet)
  const width = window.innerWidth || document.documentElement.clientWidth;
  const isMobile = width <= 700;
  const isTablet = width >= 701 && width <= 1024;
  const ua = navigator.userAgent || '';
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  if (isMobile) {
    // Mobile (≤700px): 14px for all devices, 16px for iOS
    const fontSize = isIOS ? '16px' : '14px';
    select.style.fontSize = fontSize;
    select.style.setProperty('font-size', fontSize, 'important');
  } else if (isTablet) {
    // Tablet (701px-1024px): 16px for all devices
    select.style.fontSize = '16px';
    select.style.setProperty('font-size', '16px', 'important');
  } else {
    // Remove inline font-size on desktop to let CSS handle it
    select.style.fontSize = '';
  }
}

/**
 * Update map hint popups based on filtered results and filter state
 * Only shows hints when user has actively used search controls
 * Priority: No Results > Too Many Colleges (never show both)
 */
function updateMapHints(visibleCount, typeVal, regionVal, stateVal, searchVal) {
  const hintTooMany = document.getElementById('hint-too-many-colleges');
  const hintNoResults = document.getElementById('hint-no-colleges');
  
  if (!hintTooMany || !hintNoResults) {
    console.warn('Map hint elements not found');
    return;
  }
  
  // Don't show any hints if user hasn't actively used search controls
  if (!hasUsedSearchControls) {
    hintTooMany.classList.remove('active');
    hintNoResults.classList.remove('active');
    return;
  }
  
  // Only show hints when in nearby or route mode
  if (activeMode !== 'nearby' && activeMode !== 'route') {
    hintTooMany.classList.remove('active');
    hintNoResults.classList.remove('active');
    return;
  }
  
  const tooManyViews = getHintViewCount('tooMany');
  const noResultViews = getHintViewCount('noResults');

  const hasNonDefaultFilter = regionVal || stateVal || searchVal;
  const hasAnyFilter = typeVal || hasNonDefaultFilter;
  
  // Priority 1: No Results hint
  if (visibleCount === 0 && hasAnyFilter && noResultViews < 1) {
    if (hintNoResults.dataset.active !== 'true') {
      incrementHintViewCount('noResults');
    }
    hintNoResults.dataset.active = 'true';
    hintNoResults.classList.add('active');
    hintTooMany.classList.remove('active');
    hintTooMany.dataset.active = '';
    startHintAutoHide('noResults');
    return;
  } else {
    hintNoResults.classList.remove('active');
    hintNoResults.dataset.active = '';
    clearHintAutoHide('noResults');
  }
  
  // Priority 2: Too Many Colleges hint (only if No Results is not showing)
  if (visibleCount > 30 && !typeVal && tooManyViews < 1) {
    if (hintTooMany.dataset.active !== 'true') {
      incrementHintViewCount('tooMany');
    }
    hintTooMany.dataset.active = 'true';
    hintTooMany.classList.add('active');
    startHintAutoHide('tooMany');
  } else {
    hintTooMany.classList.remove('active');
    hintTooMany.dataset.active = '';
    clearHintAutoHide('tooMany');
  }
}

/**
 * Dismiss a map hint and store in sessionStorage
 */
function dismissMapHint(type) {
  if (type === 'tooMany') {
    const hint = document.getElementById('hint-too-many-colleges');
    if (hint) {
      hint.classList.remove('active');
      hint.dataset.active = '';
    }
    clearHintAutoHide('tooMany');
  } else if (type === 'noResults') {
    const hint = document.getElementById('hint-no-colleges');
    if (hint) {
      hint.classList.remove('active');
      hint.dataset.active = '';
    }
    clearHintAutoHide('noResults');
  } else if (type === 'noSavedColleges') {
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) {
      hint.classList.remove('active');
      // Clear timeout
      if (mapHintTimeouts.noSavedColleges) {
        clearTimeout(mapHintTimeouts.noSavedColleges);
        mapHintTimeouts.noSavedColleges = null;
      }
    }
    // Automatically turn off Saved Only toggle and restore previous state
    if (savedOnlyMode) {
      savedOnlyMode = false;
      const savedControls = document.getElementById("saved-controls");
      const savedOnlySection = document.getElementById("saved-only-section");
      if (savedControls) {
        savedControls.classList.remove("saved-only-active");
      }
      if (savedOnlySection) {
        savedOnlySection.classList.remove("saved-only-active");
      }
      // Re-render map without saved-only filter
      if (activeMode === 'route' && route.lastSearch) {
        refilterCollegesAlongRoute();
      } else {
        render();
      }
    }
  }
}

function getHintStorageKey(type) {
  return type === 'tooMany' ? 'ucm_hintTooManyCount' : 'ucm_hintNoResultsCount';
}

function getHintViewCount(type) {
  const key = getHintStorageKey(type);
  const val = parseInt(sessionStorage.getItem(key) || '0', 10);
  return Number.isNaN(val) ? 0 : val;
}

function incrementHintViewCount(type) {
  const key = getHintStorageKey(type);
  const current = getHintViewCount(type);
  const maxViews = type === 'tooMany' ? 1 : HINT_MAX_VIEWS;
  sessionStorage.setItem(key, String(Math.min(maxViews, current + 1)));
}

function startHintAutoHide(type) {
  clearHintAutoHide(type);
  mapHintTimeouts[type] = setTimeout(() => {
    dismissMapHint(type);
  }, 60000);
}

function clearHintAutoHide(type) {
  if (mapHintTimeouts[type]) {
    clearTimeout(mapHintTimeouts[type]);
    mapHintTimeouts[type] = null;
  }
}

// Teaching moment: Show hint when user reaches 2 saved colleges for the first time
function checkAndShowSavedOnlyTeachingMoment() {
  // Check if already shown
  const hasShown = localStorage.getItem('ucm_savedOnlyTeachingShown') === '1';
  if (hasShown) {
    return;
  }
  
  // Check if user has exactly 2 saved colleges
  const savedIds = SavedStore.getAll();
  if (savedIds.length === 2) {
    // Show hint with auto-dismiss (closes any other active hints)
    showHintWithAutoDismiss('hint-saved-only-teaching', 6500);
    // Mark as shown in localStorage
    localStorage.setItem('ucm_savedOnlyTeachingShown', '1');
  }
}

function dismissSavedOnlyTeachingHint() {
  const hint = document.getElementById('hint-saved-only-teaching');
  if (hint) {
    hint.classList.remove('active');
  }
  // Clear timeout
  if (mapHintTimeouts.savedOnlyTeaching) {
    clearTimeout(mapHintTimeouts.savedOnlyTeaching);
    mapHintTimeouts.savedOnlyTeaching = null;
  }
  // Mark as dismissed in localStorage
  localStorage.setItem('ucm_savedOnlyTeachingShown', '1');
}


// Store glow ring data for position updates
let glowRingData = null;
let glowRingUpdateHandler = null;
let blueDotClickHandlers = [];

/**
 * Update glow ring position when map moves or zooms
 */
function updateGlowRingPosition() {
  if (!glowRingData || !map) return;
  const { ring, markerLatLng, markerLayer } = glowRingData;
  if (!ring || !markerLatLng || !markerLayer) return;
  
  const markerPoint = map.latLngToContainerPoint(markerLatLng);
  const radius = (markerLayer.options && markerLayer.options.radius) || 5;
  ring.style.left = (markerPoint.x - (radius + 5)) + 'px';
  ring.style.top = (markerPoint.y - (radius + 5)) + 'px';
}

/**
 * Show the map tip bubble pointing to a blue dot near the center
 * Only shows for first-time users when blue dots first appear
 */
function showMapTip() {
  const tipBubble = document.getElementById('map-tip-bubble');
  if (!tipBubble || !map) return;
  
  // Check if already seen this session
  if (sessionStorage.getItem('ucm_seenTapDotHint') === '1') {
    return;
  }
  
  // Check if user has seen it before (first-time user check)
  if (localStorage.getItem('ucm_seenTapDotHint') === '1') {
    return;
  }
  
  // Find a blue dot (unsaved marker) near the center of the map that's not blocked
  const mapCenter = map.getCenter();
  const mapContainer = map.getContainer();
  if (!mapContainer) return; // Safety check
  
  let closestBlueDot = null;
  let closestBlueDotLayer = null;
  let closestDistance = Infinity;
  const candidateDots = [];
  
  // First pass: collect all blue dots near center
  markersLayer.eachLayer((layer) => {
    // Check if this is a blue dot (circleMarker, not a saved marker with icon)
    if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius !== undefined)) {
      const markerLatLng = layer.getLatLng();
      const distance = mapCenter.distanceTo(markerLatLng);
      candidateDots.push({ layer, latlng: markerLatLng, distance });
    }
  });
  
  // Sort by distance and find one that's not too close to others
  candidateDots.sort((a, b) => a.distance - b.distance);
  
  // Find a dot that's isolated (not too close to other dots)
  for (let i = 0; i < Math.min(10, candidateDots.length); i++) {
    const candidate = candidateDots[i];
    let isIsolated = true;
    const candidatePoint = map.latLngToContainerPoint(candidate.latlng);
    
    // Check if there are other dots very close to this one (within 30px)
    for (let j = 0; j < candidateDots.length; j++) {
      if (i !== j) {
        const otherPoint = map.latLngToContainerPoint(candidateDots[j].latlng);
        const pixelDistance = Math.sqrt(
          Math.pow(candidatePoint.x - otherPoint.x, 2) + 
          Math.pow(candidatePoint.y - otherPoint.y, 2)
        );
        if (pixelDistance < 30) {
          isIsolated = false;
          break;
        }
      }
    }
    
    if (isIsolated || i === 0) {
      closestBlueDot = candidate.latlng;
      closestBlueDotLayer = candidate.layer;
      closestDistance = candidate.distance;
      break;
    }
  }
  
  // If no blue dot found, don't show the tip
  if (!closestBlueDot || !closestBlueDotLayer) {
    return;
  }
  
  // Bring the marker to the front so it's not blocked
  closestBlueDotLayer.bringToFront();
  
  // Convert marker position to pixel coordinates
  const markerPoint = map.latLngToContainerPoint(closestBlueDot);
  const bubbleHeight = 60; // Approximate height of bubble
  const bubbleOffset = 10; // Space between bubble and marker
  
  // Position bubble above the marker
  tipBubble.style.top = `${markerPoint.y - bubbleHeight - bubbleOffset}px`;
  tipBubble.style.left = `${markerPoint.x}px`;
  tipBubble.style.transform = 'translateX(-50%)';
  tipBubble.style.right = 'auto';
  
  // Add glowing effect to the blue dot (no scaling, just glow)
  // For Leaflet CircleMarker, use _path (SVG path element) instead of getElement()
  const markerElement = closestBlueDotLayer._path || closestBlueDotLayer.getElement();
  if (markerElement) {
    markerElement.classList.add('blue-dot-glow');
    // Also add inline style for stronger effect with neon blue (#00FFFF)
    markerElement.style.filter = 'drop-shadow(0 0 25px rgba(0, 255, 255, 1)) drop-shadow(0 0 40px rgba(0, 255, 255, 0.9)) drop-shadow(0 0 60px rgba(0, 255, 255, 0.8)) drop-shadow(0 0 80px rgba(0, 255, 255, 0.6))';
    
    // Add pulsing ring around the dot
    const ring = document.createElement('div');
    ring.className = 'blue-dot-glow-ring';
    const radius = (closestBlueDotLayer.options && closestBlueDotLayer.options.radius) || 5; // Safety check with default
    ring.style.width = (radius * 2 + 10) + 'px';
    ring.style.height = (radius * 2 + 10) + 'px';
    ring.style.left = (markerPoint.x - (radius + 5)) + 'px';
    ring.style.top = (markerPoint.y - (radius + 5)) + 'px';
    ring.setAttribute('data-glow-ring', 'true');
    
    if (mapContainer) {
      mapContainer.appendChild(ring);
      
      // Store ring data for position updates
      glowRingData = {
        ring: ring,
        markerLatLng: closestBlueDot,
        markerLayer: closestBlueDotLayer
      };
      
      // Add event listeners to update ring position on map move/zoom
      glowRingUpdateHandler = updateGlowRingPosition;
      map.on('move', glowRingUpdateHandler);
      map.on('zoom', glowRingUpdateHandler);
    }
  }
  
  // Add click handlers to all blue dots to dismiss tip when clicked
  blueDotClickHandlers = [];
  markersLayer.eachLayer((layer) => {
    // Check if this is a blue dot (circleMarker, not a saved marker with icon)
    if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius !== undefined)) {
      const clickHandler = function() {
        dismissMapTip();
      };
      layer.on('click', clickHandler);
      blueDotClickHandlers.push({ layer, handler: clickHandler });
    }
  });
  
  // Show the tip bubble
  tipBubble.classList.add('active');
  
  // Auto-hide after 8 seconds
  setTimeout(() => {
    dismissMapTip();
  }, 8000);
}

/**
 * Dismiss the map tip bubble and store in sessionStorage and localStorage
 */
function dismissMapTip() {
  sessionStorage.setItem('ucm_seenTapDotHint', '1');
  localStorage.setItem('ucm_seenTapDotHint', '1');
  const tipBubble = document.getElementById('map-tip-bubble');
  if (tipBubble) tipBubble.classList.remove('active');
  
  // Remove glowing effect from blue dot
  const glowingDots = document.querySelectorAll('.blue-dot-glow');
  glowingDots.forEach(dot => {
    dot.classList.remove('blue-dot-glow');
    dot.style.filter = ''; // Remove inline filter style
    dot.style.transform = ''; // Remove transform
  });
  
  // Remove pulsing rings
  const rings = document.querySelectorAll('[data-glow-ring="true"]');
  rings.forEach(ring => ring.remove());
  
  // Remove map event listeners for ring position updates
  if (map && glowRingUpdateHandler) {
    map.off('move', glowRingUpdateHandler);
    map.off('zoom', glowRingUpdateHandler);
    glowRingUpdateHandler = null;
  }
  
  // Remove click handlers from blue dots
  blueDotClickHandlers.forEach(({ layer, handler }) => {
    if (layer && layer.off) {
      layer.off('click', handler);
    }
  });
  blueDotClickHandlers = [];
  
  // Clear glow ring data
  glowRingData = null;
}

// Saved controls functions
let savedSearchTimeout = null;
let savedSearchResults = [];
const mapHintTimeouts = {
  tooMany: null,
  noResults: null,
  noSavedColleges: null,
  savedOnlyTeaching: null
};

// Helper function to show a hint with auto-dismiss and close any other active hints
function showHintWithAutoDismiss(hintId, duration = 6500) {
  // Close all other active hints first
  const allHints = document.querySelectorAll('.map-hint-bubble.active');
  allHints.forEach(hint => {
    if (hint.id !== hintId) {
      hint.classList.remove('active');
      // Clear any existing timeout for this hint
      const hintType = hint.id.replace('hint-', '').replace(/-/g, '');
      if (mapHintTimeouts[hintType]) {
        clearTimeout(mapHintTimeouts[hintType]);
        mapHintTimeouts[hintType] = null;
      }
    }
  });
  
  // Show the new hint
  const hint = document.getElementById(hintId);
  if (hint) {
    hint.classList.add('active');
    
    // Clear any existing timeout for this hint
    const hintType = hintId.replace('hint-', '').replace(/-/g, '');
    if (mapHintTimeouts[hintType]) {
      clearTimeout(mapHintTimeouts[hintType]);
    }
    
    // Set auto-dismiss timeout
    mapHintTimeouts[hintType] = setTimeout(() => {
      hint.classList.remove('active');
      mapHintTimeouts[hintType] = null;
    }, duration);
  }
}
const HINT_MAX_VIEWS = 3;
let routeHintShown = sessionStorage.getItem(ROUTE_HINT_KEY) === '1';
let routeHintUserInteracted = false;
let routeHintDismissTimer = null;

function openSavedListPanel() {
  const overlay = document.getElementById('saved-colleges-overlay');
  if (overlay && !overlay.classList.contains('active')) {
    overlay.classList.add('active');
    // Lower z-index of saved-controls so pill appears behind overlay
    const savedControls = document.getElementById('saved-controls');
    if (savedControls) {
      savedControls.style.zIndex = '2500';
    }
    freezeMapInteractions();
    updateSavedOverlay();
    // Focus search input
    const searchInput = document.getElementById('saved-search-input');
    if (searchInput) {
      setTimeout(() => searchInput.focus(), 100);
    }
    // Track saved list opened
    if (typeof gtag !== 'undefined') {
      gtag('event', 'feature_saved_list_opened');
    }
  }
}

function closeSavedListPanel() {
  const overlay = document.getElementById('saved-colleges-overlay');
  if (overlay && overlay.classList.contains('active')) {
    overlay.classList.remove('active');
    // Restore z-index of saved-controls
    const savedControls = document.getElementById('saved-controls');
    if (savedControls) {
      savedControls.style.zIndex = '';
    }
    resumeMapInteractions();
    // Clear search
    const searchInput = document.getElementById('saved-search-input');
    const searchResults = document.getElementById('saved-search-results');
    if (searchInput) searchInput.value = '';
    if (searchResults) {
      searchResults.classList.remove('active');
      searchResults.innerHTML = '';
    }
    // Return to list view if in compare mode
    closeCompareMode();
  }
}

function handleSavedOverlayBackdropClick(event) {
  // Close overlay if clicking on the backdrop (not on the content)
  if (event.target.id === 'saved-colleges-overlay') {
    closeSavedListPanel();
  }
}

function updateSavedOverlay() {
  const savedIds = SavedStore.getAll();
  const countEl = document.getElementById('saved-overlay-count');
  const listEl = document.getElementById('saved-colleges-list');
  const unsaveAllBtn = document.getElementById('unsave-all-btn');
  const compareBtn = document.getElementById('saved-compare-btn');
  const compareBtnSection = document.getElementById('saved-compare-btn-section');
  
  if (countEl) {
    countEl.innerHTML = `<span class="saved-count-number">${savedIds.length}</span> Colleges Saved`;
  }
  
  if (unsaveAllBtn) {
    unsaveAllBtn.style.display = savedIds.length > 0 ? 'block' : 'none';
  }
  
  // Show compare button only when 2+ saved colleges (both header and section buttons)
  if (compareBtn) {
    if (savedIds.length >= 2) {
      compareBtn.classList.add('visible');
    } else {
      compareBtn.classList.remove('visible');
    }
  }
  if (compareBtnSection) {
    if (savedIds.length >= 2) {
      compareBtnSection.classList.add('visible');
    } else {
      compareBtnSection.classList.remove('visible');
    }
  }
  
  
  if (listEl) {
    if (savedIds.length === 0) {
      listEl.innerHTML = `
        <div class="saved-empty-state">
          <div class="saved-empty-state-title">You haven't saved any colleges yet.</div>
          <div class="saved-empty-state-text">Tap a college on the map or use search above to start a saved list.</div>
        </div>
      `;
    } else {
      listEl.innerHTML = savedIds.map(collegeId => {
        const college = collegesById[collegeId];
        if (!college) return '';
        const typeDisplay = college.type || 'Unknown';
        const websiteLink = college.url ? `<a href="${escapeHtml(college.url)}" target="_blank" rel="noopener noreferrer" class="saved-college-website-link">website</a>` : '';
        return `
          <div class="saved-college-item" data-college-id="${collegeId}">
            <div class="saved-college-info">
              <div class="saved-college-name">${escapeHtml(college.name)}</div>
              <div class="saved-college-details">${college.state} · ${escapeHtml(typeDisplay)}${websiteLink ? ' · ' + websiteLink : ''}</div>
            </div>
            <button class="saved-college-unsave-btn" onclick="unsaveCollegeFromOverlay('${collegeId}')">
              <span style="color: #16a34a;">★</span> Saved
            </button>
          </div>
        `;
      }).join('');
    }
  }
  
  // Update pill count indicator
  updateSavedPillCount();
  
  // Update compare table if in compare mode
  if (document.getElementById('saved-compare-view')?.classList.contains('visible')) {
    updateCompareTable();
  }
}

/**
 * Open compare mode - switch from list view to comparison table
 */
function openCompareMode() {
  const listView = document.getElementById('saved-list-view');
  const compareView = document.getElementById('saved-compare-view');
  const titleEl = document.getElementById('saved-overlay-title');
  const compareBtnSection = document.getElementById('saved-compare-btn-section');
  const backBtn = document.getElementById('saved-back-btn');
  const printBtn = document.getElementById('saved-print-btn');
  const closeBtn = document.getElementById('saved-overlay-close-btn');
  const modal = document.querySelector('.saved-colleges-modal');
  
  if (listView && compareView) {
    listView.classList.remove('visible');
    compareView.classList.add('visible');
    if (titleEl) titleEl.textContent = 'Compare Colleges';
    if (compareBtnSection) compareBtnSection.classList.remove('visible');
    if (backBtn) backBtn.style.display = 'flex';
    if (printBtn) printBtn.style.display = 'flex';
    if (closeBtn) closeBtn.style.display = 'none';
    if (modal) modal.classList.add('compare-mode');
    updateCompareTable();
  }
}

/**
 * Close compare mode - switch back to list view
 */
function closeCompareMode() {
  const listView = document.getElementById('saved-list-view');
  const compareView = document.getElementById('saved-compare-view');
  const titleEl = document.getElementById('saved-overlay-title');
  const compareBtn = document.getElementById('saved-compare-btn');
  const compareBtnSection = document.getElementById('saved-compare-btn-section');
  const backBtn = document.getElementById('saved-back-btn');
  const printBtn = document.getElementById('saved-print-btn');
  const closeBtn = document.getElementById('saved-overlay-close-btn');
  const modal = document.querySelector('.saved-colleges-modal');
  
  if (listView && compareView) {
    listView.classList.add('visible');
    compareView.classList.remove('visible');
    if (titleEl) titleEl.textContent = 'My Saved Colleges';
    if (backBtn) backBtn.style.display = 'none';
    if (printBtn) printBtn.style.display = 'none';
    if (closeBtn) closeBtn.style.display = 'flex';
    if (modal) modal.classList.remove('compare-mode');
    const savedIds = SavedStore.getAll();
    if (compareBtn && savedIds.length >= 2) {
      compareBtn.classList.add('visible');
    }
    if (compareBtnSection && savedIds.length >= 2) {
      compareBtnSection.classList.add('visible');
    }
  }
}

/**
 * Update the comparison table with saved colleges
 */
function updateCompareTable() {
  const savedIds = SavedStore.getAll();
  const tableEl = document.getElementById('saved-compare-table');
  
  if (!tableEl) return;
  
  if (savedIds.length < 2) {
    // If fewer than 2 colleges, exit compare mode
    closeCompareMode();
    return;
  }
  
  // Get college data
  const colleges = savedIds.map(id => collegesById[id]).filter(Boolean);
  
  if (colleges.length === 0) {
    tableEl.innerHTML = '<tr><td colspan="' + (savedIds.length + 1) + '">No colleges to compare.</td></tr>';
    return;
  }
  
  // Set minimum column widths - responsive for mobile and desktop
  // Mobile: show 2-2.5 schools, Desktop: smaller columns
  const isMobile = window.innerWidth <= 768;
  const attributeColWidth = isMobile ? '110px' : '120px';
  const collegeColMinWidth = isMobile ? 130 : 140;
  
  // Calculate table width based on number of colleges
  const tableWidth = (isMobile ? 110 : 120) + (colleges.length * collegeColMinWidth);
  
  // Build table header with college names
  let html = `<thead><tr><th style="width: ${attributeColWidth}; min-width: ${attributeColWidth};">Attribute</th>`;
  colleges.forEach(college => {
    html += `<th style="min-width: ${collegeColMinWidth}px; width: ${collegeColMinWidth}px;">${escapeHtml(college.name)}</th>`;
  });
  html += '</tr></thead><tbody>';
  
  // Build rows for each attribute
  const attributes = [
    { label: 'Type of school', key: 'type', fallback: 'Unknown' },
    { label: 'Acceptance rate', key: 'acceptance', fallback: 'N/A', format: (v) => {
        if (!v || v === 'N/A' || v === 'Unknown') return 'N/A';
        return v.includes('%') ? v : v + '%';
      } },
    { label: 'Enrollment', key: 'enrollment', fallback: 'N/A' },
    { label: 'Tuition', key: 'tuition', fallback: 'N/A', format: (v) => {
        if (!v || v === 'N/A' || v === 'Unknown') return 'N/A';
        // Remove any non-numeric characters except decimal point, then convert to integer
        const numStr = String(v).replace(/[^0-9.]/g, '');
        const num = parseFloat(numStr);
        if (isNaN(num)) return 'N/A';
        return '$' + Math.floor(num).toLocaleString();
      } },
    { label: 'Website', key: 'url', fallback: 'N/A', isLink: true },
    { label: 'Action', key: 'action', isAction: true }
  ];
  
  attributes.forEach(attr => {
    html += '<tr>';
    html += `<td class="saved-compare-label" style="width: ${attributeColWidth}; min-width: ${attributeColWidth};">${escapeHtml(attr.label)}</td>`;
    
    colleges.forEach(college => {
      html += `<td class="saved-compare-value" style="min-width: ${collegeColMinWidth}px; width: ${collegeColMinWidth}px;">`;
      
      if (attr.isAction) {
        // Unsave button
        html += `<button class="saved-compare-unsave" onclick="unsaveCollegeFromCompare('${college.college_id}')">Unsave</button>`;
      } else if (attr.isLink) {
        // Website link
        if (college.url) {
          html += `<a href="${escapeHtml(college.url)}" target="_blank" rel="noopener noreferrer" class="saved-compare-website">Site Link</a>`;
        } else {
          html += 'N/A';
        }
      } else {
        // Regular value
        let value = college[attr.key] || attr.fallback || 'N/A';
        if (attr.format) {
          value = attr.format(value);
        }
        html += escapeHtml(value);
      }
      
      html += '</td>';
    });
    
    html += '</tr>';
  });
  
  html += '</tbody>';
  tableEl.innerHTML = html;
  
  // Set table width to accommodate all columns with minimum widths
  tableEl.style.width = `${tableWidth}px`;
  tableEl.style.minWidth = `${tableWidth}px`;
}

/**
 * Print the comparison table
 */
function printCompareTable() {
  const savedIds = SavedStore.getAll();
  const colleges = savedIds.map(id => collegesById[id]).filter(Boolean);
  
  if (colleges.length < 2) return;
  
  // Split colleges into chunks of 10
  const chunkSize = 10;
  const collegeChunks = [];
  for (let i = 0; i < colleges.length; i += chunkSize) {
    collegeChunks.push(colleges.slice(i, i + chunkSize));
  }
  
  // Build rows for each attribute
  const attributes = [
    { label: 'Type of school', key: 'type', fallback: 'Unknown' },
    { label: 'Acceptance rate', key: 'acceptance', fallback: 'N/A', format: (v) => {
        if (!v || v === 'N/A' || v === 'Unknown') return 'N/A';
        return v.includes('%') ? v : v + '%';
      } },
    { label: 'Enrollment', key: 'enrollment', fallback: 'N/A' },
    { label: 'Tuition', key: 'tuition', fallback: 'N/A', format: (v) => {
        if (!v || v === 'N/A' || v === 'Unknown') return 'N/A';
        const numStr = String(v).replace(/[^0-9.]/g, '');
        const num = parseFloat(numStr);
        if (isNaN(num)) return 'N/A';
        return '$' + Math.floor(num).toLocaleString();
      } },
    { label: 'Website', key: 'url', fallback: 'N/A', isLink: true }
  ];
  
  // Function to build a table for a chunk of colleges
  function buildTable(chunk, tableNumber, totalTables) {
    const numCols = chunk.length + 1; // +1 for Attribute column
    const attributeColWidth = '15%';
    const collegeColWidth = `${85 / chunk.length}%`;
    
    let tableHTML = '';
    if (totalTables > 1) {
      tableHTML += `<h2 style="font-size: 18px; margin: 30px 0 15px 0; color: #0f172a;">Table ${tableNumber} of ${totalTables}</h2>`;
    }
    
    tableHTML += `
      <table style="table-layout: fixed; width: 100%; margin-bottom: ${totalTables > 1 ? '40px' : '20px'};">
        <thead>
          <tr>
            <th style="width: ${attributeColWidth};">Attribute</th>
    `;
    
    chunk.forEach(college => {
      tableHTML += `<th style="width: ${collegeColWidth};">${escapeHtml(college.name)}</th>`;
    });
    
    tableHTML += `
          </tr>
        </thead>
        <tbody>
    `;
    
    attributes.forEach(attr => {
      tableHTML += '<tr>';
      tableHTML += `<td class="label" style="width: ${attributeColWidth};">${escapeHtml(attr.label)}</td>`;
      
      chunk.forEach(college => {
        tableHTML += `<td style="width: ${collegeColWidth};">`;
        
        if (attr.isLink) {
          if (college.url) {
            tableHTML += `<a href="${escapeHtml(college.url)}">${escapeHtml(college.url)}</a>`;
          } else {
            tableHTML += 'N/A';
          }
        } else {
          let value = college[attr.key] || attr.fallback || 'N/A';
          if (attr.format) {
            value = attr.format(value);
          }
          tableHTML += escapeHtml(value);
        }
        
        tableHTML += '</td>';
      });
      
      tableHTML += '</tr>';
    });
    
    tableHTML += `
        </tbody>
      </table>
    `;
    
    return tableHTML;
  }
  
  // Build all tables
  let tablesHTML = '';
  collegeChunks.forEach((chunk, index) => {
    tablesHTML += buildTable(chunk, index + 1, collegeChunks.length);
  });
  
  // Create a print-friendly version of the table
  let printHTML = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Compare Colleges</title>
      <style>
        @page {
          margin: 1cm;
          size: landscape;
        }
        body {
          font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          margin: 0;
          padding: 20px;
          font-size: 12px;
        }
        h1 {
          font-size: 24px;
          margin: 0 0 20px 0;
          color: #0f172a;
        }
        h2 {
          page-break-after: avoid;
        }
        table {
          width: 100%;
          border-collapse: collapse;
          font-size: 11px;
          table-layout: fixed;
          page-break-inside: auto;
        }
        tr {
          page-break-inside: avoid;
          page-break-after: auto;
        }
        th {
          text-align: left;
          padding: 10px 8px;
          border-bottom: 2px solid #E5E7EB;
          font-weight: 600;
          color: #0f172a;
          background: #F9FAFB;
          word-wrap: break-word;
          overflow-wrap: break-word;
        }
        td {
          padding: 10px 8px;
          border-bottom: 1px solid #F3F4F6;
          color: #374151;
          vertical-align: top;
          word-wrap: break-word;
          overflow-wrap: break-word;
        }
        tr:last-child td {
          border-bottom: none;
        }
        .label {
          font-weight: 500;
          color: #64748b;
        }
        a {
          color: #2563eb;
          text-decoration: none;
          word-break: break-all;
        }
        @media print {
          body { margin: 0; padding: 10px; }
          .no-print { display: none; }
          table { page-break-inside: avoid; }
        }
      </style>
    </head>
    <body>
      <h1>Compare Colleges</h1>
      ${tablesHTML}
      <div style="margin-top: 20px; padding: 16px; font-size: 10px; color: #64748b; line-height: 1.6;">
        Disclaimer: School information provided on this site is for general reference and may be incomplete or out of date. Details such as tuition, enrollment, and acceptance rate can change at any time. Students and families should always verify the latest information directly on each college's official website when making decisions.
      </div>
    </body>
    </html>
  `;
  
  // Open print window
  const printWindow = window.open('', '_blank');
  if (!printWindow) return;
  
  printWindow.document.write(printHTML);
  printWindow.document.close();
  
  // Wait for content to load, then print
  printWindow.onload = function() {
    setTimeout(() => {
      printWindow.print();
    }, 250);
  };
}

/**
 * Unsave a college from compare mode
 */
function unsaveCollegeFromCompare(collegeId) {
  unsaveCollegeFromOverlay(collegeId);
  // updateCompareTable will be called by updateSavedOverlay
}

/**
 * Update the saved count indicator in the "My Saved List" pill
 */
function updateSavedPillCount() {
  const savedIds = SavedStore.getAll();
  const pillCountXEl = document.getElementById('saved-pill-count-x');
  const pillCountEl = document.getElementById('saved-pill-count');
  
  if (pillCountXEl && pillCountEl) {
    if (savedIds.length > 0) {
      pillCountXEl.textContent = 'x';
      pillCountEl.textContent = savedIds.length;
    } else {
      pillCountXEl.textContent = '';
      pillCountEl.textContent = '';
    }
  }
}

function setupRouteHint() {
  const routeHint = document.getElementById('route-hint-bubble');
  const startInput = elements.routeStart;
  const endInput = elements.routeEnd;
  if (!routeHint || !startInput || !endInput || routeHintShown) return;

  const handleEvent = (event) => {
    if (routeHintShown) return;
    if (event && (event.type === 'input' || event.type === 'change')) {
      routeHintUserInteracted = true;
    }
    const force = event ? event.type === 'blur' : false;
    maybeShowRouteHint(force);
  };

  ['input', 'change', 'blur'].forEach(evtName => {
    startInput.addEventListener(evtName, handleEvent);
    endInput.addEventListener(evtName, handleEvent);
  });
}

function maybeShowRouteHint(force = false) {
  if (routeHintShown) return;
  const startFilled = !!(elements.routeStart && elements.routeStart.value.trim());
  const endFilled = !!(elements.routeEnd && elements.routeEnd.value.trim());
  if (!startFilled || !endFilled) return;
  if (!routeHintUserInteracted && !force) return;
  showRouteHintBubble();
}

function notifyRouteInputsUpdated(forceUserInteraction = false) {
  if (forceUserInteraction) {
    routeHintUserInteracted = true;
  }
  maybeShowRouteHint(forceUserInteraction);
}

function showRouteHintBubble() {
  const routeHint = document.getElementById('route-hint-bubble');
  const exploreBtn = elements.findRouteBtn;
  if (!routeHint || !exploreBtn || routeHintShown) return;

  routeHint.style.display = 'block';
  routeHint.style.visibility = 'hidden';
  routeHint.classList.remove('visible');
  routeHint.classList.remove('below');

  const buttonRect = exploreBtn.getBoundingClientRect();
  const headerRect = document.querySelector('.app-header')?.getBoundingClientRect();
  const bubbleRect = routeHint.getBoundingClientRect();
  const minTop = headerRect ? headerRect.bottom + 8 : 12;
  let placeBelow = false;
  let top = buttonRect.top - bubbleRect.height - 8;
  if (top < minTop) {
    top = Math.max(buttonRect.bottom + 8, minTop);
    placeBelow = true;
  }
  if (placeBelow) {
    routeHint.classList.add('below');
  }
  let left = buttonRect.left + (buttonRect.width / 2) - (bubbleRect.width / 2);
  const maxLeft = window.innerWidth - bubbleRect.width - 12;
  left = Math.min(Math.max(12, left), maxLeft);

  routeHint.style.top = `${top}px`;
  routeHint.style.left = `${left}px`;
  routeHint.style.visibility = 'visible';

  requestAnimationFrame(() => {
    routeHint.classList.add('visible');
  });

  if (routeHintDismissTimer) {
    clearTimeout(routeHintDismissTimer);
    routeHintDismissTimer = null;
  }
  routeHint.onclick = () => dismissRouteHint();
  routeHintDismissTimer = setTimeout(() => dismissRouteHint(), 5000);
  routeHintShown = true;
  sessionStorage.setItem(ROUTE_HINT_KEY, '1');
}

function dismissRouteHint() {
  const routeHint = document.getElementById('route-hint-bubble');
  if (!routeHint) return;
  routeHint.onclick = null;
  routeHint.classList.remove('visible');
  if (routeHintDismissTimer) {
    clearTimeout(routeHintDismissTimer);
    routeHintDismissTimer = null;
  }
  setTimeout(() => {
    routeHint.style.display = 'none';
    routeHint.style.visibility = '';
  }, 200);
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Search functionality
function initSavedSearch() {
  const searchInput = document.getElementById('saved-search-input');
  if (!searchInput) return;
  
  searchInput.addEventListener('input', (e) => {
    const query = (e.target.value || '').trim().toLowerCase();
    const resultsEl = document.getElementById('saved-search-results');
    
    if (!resultsEl) return;
    
    // Clear previous timeout
    if (savedSearchTimeout) {
      clearTimeout(savedSearchTimeout);
    }
    
    if (query.length < 2) {
      resultsEl.classList.remove('active');
      resultsEl.innerHTML = '';
      return;
    }
    
    // Debounce search
    savedSearchTimeout = setTimeout(() => {
      const queryLower = query.toLowerCase();
      const queryWords = queryLower.split(/\s+/).filter(w => w.length > 0);
      
      // Score and filter colleges
      const scored = colleges.map(college => {
        if (!college.name) return null;
        const nameLower = college.name.toLowerCase();
        
        // Perfect match (exact)
        if (nameLower === queryLower) {
          return { college, score: 1000, matchType: 'exact' };
        }
        
        // Starts with query
        if (nameLower.startsWith(queryLower)) {
          return { college, score: 500, matchType: 'starts' };
        }
        
        // Contains query as substring
        if (nameLower.includes(queryLower)) {
          return { college, score: 300, matchType: 'contains' };
        }
        
        // Word-based matching
        const nameWords = nameLower.split(/\s+/);
        let wordMatches = 0;
        let allWordsMatch = true;
        
        for (const queryWord of queryWords) {
          let wordMatched = false;
          for (const nameWord of nameWords) {
            if (nameWord.startsWith(queryWord)) {
              wordMatches += 2; // Word starts with query word
              wordMatched = true;
              break;
            } else if (nameWord.includes(queryWord)) {
              wordMatches += 1; // Word contains query word
              wordMatched = true;
              break;
            }
          }
          if (!wordMatched) {
            allWordsMatch = false;
          }
        }
        
        if (wordMatches > 0) {
          const score = allWordsMatch ? 200 + wordMatches : 100 + wordMatches;
          return { college, score, matchType: 'words' };
        }
        
        return null;
      }).filter(item => item !== null);
      
      // Sort by score (highest first), then alphabetically
      scored.sort((a, b) => {
        if (b.score !== a.score) {
          return b.score - a.score;
        }
        return a.college.name.localeCompare(b.college.name);
      });
      
      const matches = scored.slice(0, 10).map(item => item.college);
      
      if (matches.length === 0) {
        resultsEl.classList.remove('active');
        resultsEl.innerHTML = '';
        return;
      }
      
      resultsEl.innerHTML = matches.map(college => {
        const isSaved = SavedStore.isSaved(college.college_id);
        const typeDisplay = college.type || 'Unknown';
        const collegeIdEscaped = escapeHtml(college.college_id);
        return `
          <div class="saved-search-result-item" data-college-id="${collegeIdEscaped}">
            <div class="saved-search-result-info">
              <div class="saved-search-result-name">${escapeHtml(college.name)}</div>
              <div class="saved-search-result-details">${college.state} · ${escapeHtml(typeDisplay)}</div>
            </div>
            <button class="saved-search-result-save-btn ${isSaved ? 'saved' : ''}" 
                    data-college-id="${collegeIdEscaped}"
                    onclick="event.stopPropagation(); saveCollegeFromSearch('${collegeIdEscaped.replace(/'/g, "\\'")}');">
              <span style="color: ${isSaved ? '#16a34a' : '#64748b'}; display: inline-block; width: 12px; text-align: center; line-height: 1;">${isSaved ? '★' : '☆'}</span>
              ${isSaved ? 'Saved' : 'Save'}
            </button>
          </div>
        `;
      }).join('');
      
      resultsEl.classList.add('active');
      resultsEl.scrollTop = 0; // Reset scroll to top
      savedSearchResults = matches;
    }, 200);
  });
  
  // Close results when clicking outside
  document.addEventListener('click', (e) => {
    const searchInput = document.getElementById('saved-search-input');
    if (!searchInput) return;
    const resultsEl = document.getElementById('saved-search-results');
    if (!resultsEl) return;
    
    const searchWrapper = searchInput.closest('.saved-search-wrapper');
    // Close if clicking outside the search wrapper
    if (searchWrapper && !searchWrapper.contains(e.target)) {
      resultsEl.classList.remove('active');
      resultsEl.innerHTML = '';
    }
  });
  
  // Also close on blur (when input loses focus)
  searchInput.addEventListener('blur', (e) => {
    // Use setTimeout to allow click events on dropdown items to fire first
    setTimeout(() => {
      const resultsEl = document.getElementById('saved-search-results');
      if (resultsEl) {
        const searchWrapper = searchInput.closest('.saved-search-wrapper');
        // Only close if focus didn't move to a dropdown item
        if (!searchWrapper || !searchWrapper.contains(document.activeElement)) {
          resultsEl.classList.remove('active');
          resultsEl.innerHTML = '';
        }
      }
    }, 200);
  });
}

function saveCollegeFromSearch(collegeId) {
  if (!collegeId) return;
  
  SavedStore.toggle(collegeId);
  updateMarkerIcon(collegeId);
  updateSavedOverlay();
  
  // Update search result button using data attribute
  const resultsEl = document.getElementById('saved-search-results');
  if (resultsEl) {
    const btn = resultsEl.querySelector(`button[data-college-id="${collegeId}"]`);
    if (btn) {
      const isSaved = SavedStore.isSaved(collegeId);
      if (isSaved) {
        btn.classList.add('saved');
      } else {
        btn.classList.remove('saved');
      }
      btn.innerHTML = `
        <span style="color: ${isSaved ? '#16a34a' : '#64748b'}; display: inline-block; width: 12px; text-align: center; line-height: 1;">${isSaved ? '★' : '☆'}</span>
        ${isSaved ? 'Saved' : 'Save'}
      `;
    }
  }
  
  // Close dropdown after saving (standard UX: keep search term in input)
  if (resultsEl) {
    resultsEl.classList.remove('active');
    resultsEl.innerHTML = '';
  }
  
  // Keep search input value (standard practice - allows user to refine search or save more colleges)
  // This follows the pattern used by Google, GitHub, Amazon, Slack, and other major platforms
  
  // Re-render if saved-only mode is on
  if (savedOnlyMode) {
    if (activeMode === 'route' && route.lastSearch) {
      refilterCollegesAlongRoute();
    } else {
      render();
    }
  }
}

function getSavedOverlayItem(collegeId) {
  if (!collegeId) return null;
  const selector = '.saved-college-item[data-college-id="%s"]';
  if (window.CSS && CSS.escape) {
    return document.querySelector(selector.replace('%s', CSS.escape(collegeId)));
  }
  return document.querySelector(selector.replace('%s', collegeId.replace(/"/g, '\\"')));
}

function unsaveCollegeFromOverlay(collegeId) {
  if (!collegeId) return;
  
  const listItem = getSavedOverlayItem(collegeId);
  if (listItem) {
    listItem.classList.add('removing');
  }
  
  const finalize = () => {
    // Get saved count before toggle to detect 1→2 transition
    const savedCountBefore = SavedStore.getAll().length;
    
    SavedStore.toggle(collegeId);
    updateMarkerIcon(collegeId);
    
    // Rule 3: Check if SavedStore becomes empty while saved-only is ON
    const savedIdsAfter = SavedStore.getAll();
    
    // Check if we need to exit compare mode (fewer than 2 colleges)
    if (savedIdsAfter.length < 2 && document.getElementById('saved-compare-view')?.classList.contains('visible')) {
      closeCompareMode();
    }
    
    updateSavedOverlay();
    if (savedIdsAfter.length === 0 && savedOnlyMode) {
      // Auto-turn OFF toggle
      savedOnlyMode = false;
      const savedControls = document.getElementById("saved-controls");
      const savedOnlySection = document.getElementById("saved-only-section");
      if (savedControls) {
        savedControls.classList.remove("saved-only-active");
      }
      if (savedOnlySection) {
        savedOnlySection.classList.remove("saved-only-active");
      }
      
      // Show hint
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) {
        const hintBody = hint.querySelector('.map-hint-bubble-body');
        if (hintBody) {
          hintBody.textContent = "No saved colleges left on the map — Map Saved Only has been turned off.";
        }
      }
      showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
    } else if (savedIdsAfter.length > 0 && savedOnlyMode) {
      // Rule 4: Check if last visible saved college was removed (even if other saved colleges exist elsewhere)
      if (!hasQualifyingSavedColleges()) {
        // Auto-turn OFF toggle
        savedOnlyMode = false;
        const savedControls = document.getElementById("saved-controls");
        const savedOnlySection = document.getElementById("saved-only-section");
        if (savedControls) {
          savedControls.classList.remove("saved-only-active");
        }
        if (savedOnlySection) {
          savedOnlySection.classList.remove("saved-only-active");
        }
        
        // Show hint
        const hint = document.getElementById('hint-no-saved-colleges');
        if (hint) {
          const hintBody = hint.querySelector('.map-hint-bubble-body');
          if (hintBody) {
            hintBody.textContent = "No saved colleges visible on the map — Map Saved Only has been turned off.";
          }
        }
        showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
      }
    }
    
    // Check for teaching moment (1→2 transition)
    if (savedCountBefore === 1 && savedIdsAfter.length === 2) {
      checkAndShowSavedOnlyTeachingMoment();
    }
    
    // Re-render if saved-only mode is still ON (or if it was turned OFF, re-render without saved-only filter)
    if (savedOnlyMode) {
      if (activeMode === 'route' && route.lastSearch) {
        refilterCollegesAlongRoute();
      } else {
        render();
      }
    } else if (savedIdsAfter.length === 0 || (savedIdsAfter.length > 0 && !hasQualifyingSavedColleges())) {
      // Re-render if toggle was turned OFF (either by Rule 3 or Rule 4)
      if (activeMode === 'route' && route.lastSearch) {
        refilterCollegesAlongRoute();
      } else {
        render();
      }
    }
  };
  
  if (listItem) {
    setTimeout(finalize, 260);
  } else {
    finalize();
  }
}

function updateMarkerIcon(collegeId) {
  const marker = markersByCollegeId[collegeId];
  if (!marker) return;
  
  const isSaved = SavedStore.isSaved(collegeId);
  const latlng = marker.getLatLng();
  const popup = marker.getPopup();
  const tooltip = marker.getTooltip();
  const popupContent = popup ? popup.getContent() : '';
  const tooltipContent = tooltip ? tooltip.getContent() : '';
  const wasPopupOpen = popup && marker.isPopupOpen();
  
  marker.remove();
  
  let newMarker;
  if (isSaved) {
    // Use green pin icon for saved colleges with dynamic sizing
    const iconSize = getCurrentSavedIconSize();
    newMarker = L.marker(latlng, { icon: createGreenSavedIcon(iconSize) });
  } else {
    // Use dynamic radius for touch devices
    const radius = getCurrentMarkerRadius();
    newMarker = L.circleMarker(latlng, { radius: radius, color: '#2563eb', weight: 2, fillOpacity: 0.7 });
  }
  
  if (popupContent) newMarker.bindPopup(popupContent);
  if (tooltipContent) newMarker.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
  newMarker.addTo(markersLayer);
  markersByCollegeId[collegeId] = newMarker;
  
  if (wasPopupOpen) {
    newMarker.openPopup();
  }
}

function confirmUnsaveAll() {
  const modal = document.getElementById('unsave-all-modal');
  if (modal) {
    modal.classList.add('active');
  }
}

function closeUnsaveAllModal() {
  const modal = document.getElementById('unsave-all-modal');
  if (modal) {
    modal.classList.remove('active');
  }
}

function unsaveAllColleges() {
  const savedIds = SavedStore.getAll();
  
  savedIds.forEach(collegeId => {
    SavedStore.toggle(collegeId);
    updateMarkerIcon(collegeId);
  });
  
  closeUnsaveAllModal();
  
  // Exit compare mode if active (will have 0 colleges after unsave all)
  if (document.getElementById('saved-compare-view')?.classList.contains('visible')) {
    closeCompareMode();
  }
  
  updateSavedOverlay();

  // Rule 3: If Saved Only was on and SavedStore is now empty, turn it off and show hint
  if (savedOnlyMode && SavedStore.getAll().length === 0) {
    savedOnlyMode = false;
    const savedControls = document.getElementById("saved-controls");
    const savedOnlySection = document.getElementById("saved-only-section");
    if (savedControls) {
      savedControls.classList.remove("saved-only-active");
    }
    if (savedOnlySection) {
      savedOnlySection.classList.remove("saved-only-active");
    }
    
    // Show hint
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) {
      const hintBody = hint.querySelector('.map-hint-bubble-body');
      if (hintBody) {
        hintBody.textContent = "No saved colleges left on the map — Map Saved Only has been turned off.";
      }
    }
    showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
  }
  
  // Re-render to reflect unsaved state with saved-only off
  if (activeMode === 'route' && route.lastSearch) {
    refilterCollegesAlongRoute();
  } else {
    render();
  }
}

// savedOnlyMode is declared earlier in the file (near line 2262) for early initialization
// let savedOnlyMode = false;
// Helper function to check and handle when no visible saved colleges remain after filter changes
// NOTE: This hint shows every time (no view count limit) when filters exclude all saved colleges
function checkAndHandleNoVisibleSavedColleges() {
  // Only check if saved-only mode is ON
  if (!savedOnlyMode) {
    return;
  }
  
  // Check if any saved colleges match current filters
  if (!hasQualifyingSavedColleges()) {
    // Auto-turn OFF toggle
    savedOnlyMode = false;
    const savedControls = document.getElementById("saved-controls");
    const savedOnlySection = document.getElementById("saved-only-section");
    if (savedControls) {
      savedControls.classList.remove("saved-only-active");
    }
    if (savedOnlySection) {
      savedOnlySection.classList.remove("saved-only-active");
    }
    
    // Prepare hint message
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) {
      const hintBody = hint.querySelector('.map-hint-bubble-body');
      if (hintBody) {
        hintBody.textContent = "No saved colleges match your current filters — Map Saved Only has been turned off.";
      }
    }
    
    // Re-render map without saved-only filter first
    if (activeMode === 'route' && route.lastSearch) {
      refilterCollegesAlongRoute();
    } else {
      render();
    }
    
    // Show hint AFTER render completes to ensure it's visible
    // Use requestAnimationFrame to ensure DOM updates are complete
    requestAnimationFrame(() => {
      setTimeout(() => {
        if (hint) {
          // Clear any existing timeout to ensure hint shows
          const hintType = 'noSavedColleges';
          if (mapHintTimeouts[hintType]) {
            clearTimeout(mapHintTimeouts[hintType]);
            mapHintTimeouts[hintType] = null;
          }
          
          // Show the hint (no view count limit - shows every time)
          showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
        }
      }, 100);
    });
  }
}

// Helper function to check if any saved colleges are qualifying (visible given current filters/context)
function hasQualifyingSavedColleges() {
  const savedIds = SavedStore.getAll();
  if (savedIds.length === 0) {
    return false;
  }
  
  // Check based on active mode
  if (activeMode === 'nearby' && home) {
    // Get current filter values
    const desktopSearch = document.getElementById('search');
    const mobileSearch = document.getElementById('search-mobile');
    const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
    const typeVal = document.getElementById('type')?.value || '';
    const regionVal = document.getElementById('region')?.value || '';
    const stateVal = document.getElementById('state')?.value || '';
    const rankingVal = document.getElementById('ranking')?.value || '';
    const radiusVal = parseFloat(document.getElementById('radius-slider')?.value || '30');
    const unitsVal = document.getElementById('units-toggle')?.dataset.units || 'mi';
    
    // Pre-filter by cheaper criteria first (same logic as render function)
    let filtered = colleges.filter(c => {
      // Region filter
      const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
      if (!regionMatch) return false;
      
      // State filter
      if (stateVal && c.state !== stateVal) return false;
      
      // Type filter
      if (typeVal && (c.type || c.tier) !== typeVal) return false;
      
      // Ranking filter
      if (rankingVal) {
        if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
        if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
        if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
        if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
      }
      
      // Search filter
      if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
      
      return true;
    });
    
    // Filter by distance to home
    const effectiveRadius = radiusVal === 0 ? 0.5 : radiusVal;
    filtered = filtered.filter(c => {
      const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
      return distance <= effectiveRadius;
    });
    
    // Check if any filtered colleges are saved
    return filtered.some(c => SavedStore.isSaved(c.college_id));
  } else if (activeMode === 'route' && route.lastResult && route.lastResult.colleges) {
    // Check if any colleges in route result are saved
    return route.lastResult.colleges.some(item => SavedStore.isSaved(item.college.college_id));
  } else {
    // Explore mode or other cases - check filters but no distance/route restrictions
    // Get current filter values
    const desktopSearch = document.getElementById('search');
    const mobileSearch = document.getElementById('search-mobile');
    const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
    const typeVal = document.getElementById('type')?.value || '';
    const regionVal = document.getElementById('region')?.value || '';
    const stateVal = document.getElementById('state')?.value || '';
    const rankingVal = document.getElementById('ranking')?.value || '';
    
    // Pre-filter by cheaper criteria first (same logic as render function)
    let filtered = colleges.filter(c => {
      // Region filter
      const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
      if (!regionMatch) return false;
      
      // State filter
      if (stateVal && c.state !== stateVal) return false;
      
      // Type filter
      if (typeVal && (c.type || c.tier) !== typeVal) return false;
      
      // Ranking filter
      if (rankingVal) {
        if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
        if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
        if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
        if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
      }
      
      // Search filter
      if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
      
      return true;
    });
    
    // Check if any filtered colleges are saved
    return filtered.some(c => SavedStore.isSaved(c.college_id));
  }
}

function toggleSavedOnly() {
  // Rule 2: Check BEFORE turning toggle ON if there are qualifying saved colleges
  const willBeOn = !savedOnlyMode;
  if (willBeOn) {
    const savedIds = SavedStore.getAll();
    
    // Rule 1: No saved colleges at all
    if (savedIds.length === 0) {
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) {
        const hintBody = hint.querySelector('.map-hint-bubble-body');
        if (hintBody) {
          hintBody.textContent = "You haven't saved any colleges yet. Tap a college to save it, then turn this on to see only your saved schools.";
        }
      }
      showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
      return; // Don't turn toggle ON
    }
    
    // Rule 2: Check if any saved colleges are qualifying (visible given current filters/context)
    if (!hasQualifyingSavedColleges()) {
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) {
        const hintBody = hint.querySelector('.map-hint-bubble-body');
        if (hintBody) {
          if (activeMode === 'nearby') {
            hintBody.textContent = "None of your saved colleges are within this distance.";
          } else if (activeMode === 'route') {
            hintBody.textContent = "None of your saved colleges are close to this route.";
          } else {
            hintBody.textContent = "None of your saved colleges match your current filters.";
          }
        }
      }
      showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
      return; // Don't turn toggle ON
    }
  }
  
  savedOnlyMode = !savedOnlyMode;
  const savedControls = document.getElementById("saved-controls");
  const savedOnlySection = document.getElementById("saved-only-section");
  if (savedControls) {
    savedControls.classList.toggle("saved-only-active", savedOnlyMode);
  }
  if (savedOnlySection) {
    savedOnlySection.classList.toggle("saved-only-active", savedOnlyMode);
  }
  console.log("Saved Only:", savedOnlyMode);
  // Track saved only toggle
  if (typeof gtag !== 'undefined') {
    gtag('event', 'feature_saved_only_toggled');
  }
  
  // Check if Saved Only is turned ON and there are no saved colleges (legacy check, should not trigger now)
  if (savedOnlyMode) {
    const savedIds = SavedStore.getAll();
    if (savedIds.length === 0) {
      // Update hint message for Scenario 1
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) {
        const hintBody = hint.querySelector('.map-hint-bubble-body');
        if (hintBody) {
          hintBody.textContent = "You haven't saved any colleges yet. Tap a college to save it, then turn this on to see only your saved schools.";
        }
      }
      
      // Show hint with auto-dismiss (closes any other active hints)
      showHintWithAutoDismiss('hint-no-saved-colleges', 6500);
      
      // Immediately turn off toggle (no delay)
      savedOnlyMode = false;
      const savedControls = document.getElementById("saved-controls");
      const savedOnlySection = document.getElementById("saved-only-section");
      if (savedControls) {
        savedControls.classList.remove("saved-only-active");
      }
      if (savedOnlySection) {
        savedOnlySection.classList.remove("saved-only-active");
      }
      // Re-render map without saved-only filter
      if (activeMode === 'route' && route.lastSearch) {
        refilterCollegesAlongRoute();
      } else {
        render();
      }
    } else {
      // Hide the notice if it was showing
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) {
        hint.classList.remove('active');
        // Clear timeout
        if (mapHintTimeouts.noSavedColleges) {
          clearTimeout(mapHintTimeouts.noSavedColleges);
          mapHintTimeouts.noSavedColleges = null;
        }
      }
    }
  } else {
    // Hide the notice when Saved Only is turned OFF
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) hint.classList.remove('active');
    // Remove active class from saved-only-section when turning OFF
    const savedOnlySection = document.getElementById("saved-only-section");
    if (savedOnlySection) {
      savedOnlySection.classList.remove("saved-only-active");
    }
  }
  
  // Defer heavy rendering work to allow toggle UI feedback to appear first
  requestAnimationFrame(() => {
    // Re-render map with saved-only filter
    if (activeMode === 'route' && route.lastSearch) {
      // Use cached route data to avoid redrawing the route line
      refilterCollegesAlongRoute();
    } else {
      render();
    }
    // Update navigation icon visibility after toggle
    updateNavigationIconVisibility();
    
    // Check if saved-only mode should be turned OFF after filter change
    checkAndHandleNoVisibleSavedColleges();
  });
}

// Placeholder function for share icon click
// Toast notification system
const toast = (() => {
  let toastElement = null;
  let hideTimer = null;
  
  const init = () => {
    if (!toastElement) {
      const mapContainer = document.getElementById('map');
      if (mapContainer) {
        toastElement = document.createElement('div');
        toastElement.className = 'toast';
        toastElement.id = 'share-toast';
        toastElement.innerHTML = '<div class="toast-message"></div>';
        mapContainer.appendChild(toastElement);
      }
    }
    return toastElement;
  };
  
  const show = (message, duration = 3000) => {
    const toast = init();
    const messageEl = toast.querySelector('.toast-message');
    if (messageEl) {
      messageEl.textContent = message;
    }
    toast.classList.add('active');
    
    if (hideTimer) {
      clearTimeout(hideTimer);
    }
    hideTimer = setTimeout(() => {
      hide();
    }, duration);
  };
  
  const hide = () => {
    if (toastElement) {
      toastElement.classList.remove('active');
    }
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }
  };
  
  return { show, hide };
})();

// Generate share URL
function generateShareURL() {
  const baseUrl = window.location.origin + window.location.pathname;
  const params = new URLSearchParams();
  
  // Flag for shared saved map
  params.set('view', 'savedshare');
  
  // Get saved college IDs and normalize to strings
  const savedIds = SavedStore.getAll();
  if (savedIds.length > 0) {
    // Ensure all IDs are strings for consistent URL encoding
    const normalizedIds = savedIds.map(id => String(id).trim()).filter(id => id);
    params.set('colleges', normalizedIds.join(','));
    console.log('[generateShareURL] Sharing', normalizedIds.length, 'college IDs:', normalizedIds.slice(0, 5));
  }
  
  // Get current map center and zoom
  const center = map.getCenter();
  const zoom = map.getZoom();
  params.set('lat', center.lat.toFixed(6));
  params.set('lng', center.lng.toFixed(6));
  params.set('zoom', zoom.toString());
  
  // Add mode-specific data
  if (activeMode === 'nearby' && home) {
    params.set('mode', 'nearby');
    params.set('homeLat', home.lat.toFixed(6));
    params.set('homeLng', home.lon.toFixed(6));
    if (elements.radius && elements.radius.value) {
      params.set('radius', elements.radius.value);
    }
    if (elements.units && elements.units.value) {
      params.set('units', elements.units.value);
    }
  } else if (activeMode === 'route' && route.start && route.end) {
    params.set('mode', 'route');
    params.set('startLat', route.start.lat.toFixed(6));
    params.set('startLng', route.start.lon.toFixed(6));
    params.set('endLat', route.end.lat.toFixed(6));
    params.set('endLng', route.end.lon.toFixed(6));
    if (elements.routeMaxDistance && elements.routeMaxDistance.value) {
      params.set('routeRadius', elements.routeMaxDistance.value);
    }
    if (elements.routeUnits && elements.routeUnits.value) {
      params.set('routeUnits', elements.routeUnits.value);
    }
  } else {
    params.set('mode', 'explore');
  }
  
  return `${baseUrl}?${params.toString()}`;
}

// Copy to clipboard
async function copyToClipboard(text) {
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      const success = document.execCommand('copy');
      document.body.removeChild(textArea);
      return success;
    }
  } catch (err) {
    console.error('Failed to copy to clipboard:', err);
    return false;
  }
}

// Share icon click handler
// Placeholder function for navigation icon click - to be implemented later
// Route Planner Overlay Functions
function planRouteWithSavedColleges() {
  const overlay = document.getElementById('route-planner-overlay');
  if (!overlay) {
    console.error('Route planner overlay not found');
    return;
  }
  
  // Check if we have route data
  if (!route.start || !route.end || !route.lastResult || !route.lastResult.colleges) {
    console.error('Route data not available');
    showError('Please search for a route first before planning with saved colleges.');
    return;
  }
  
  // Get saved colleges on the route
  const savedCollegesOnRoute = route.lastResult.colleges.filter(item => {
    const collegeId = item.college ? item.college.college_id : item.college_id;
    return collegeId && SavedStore.isSaved(collegeId);
  });
  
  if (savedCollegesOnRoute.length === 0) {
    console.log('No saved colleges on this route');
    showError('No saved colleges found on this route. Save some colleges first.');
    return;
  }
  
  // Populate overlay
  populateRoutePlannerOverlay(savedCollegesOnRoute);
  
  // Show overlay
  overlay.classList.add('active');
  
  // Freeze map interactions to prevent map from scrolling/zooming when overlay is open
  freezeMapInteractions();
  
  // Prevent body scroll when overlay is open
  document.body.style.overflow = 'hidden';
  
  // Close saved list if open
  const savedOverlay = document.getElementById('saved-colleges-overlay');
  if (savedOverlay && savedOverlay.classList.contains('active')) {
    closeSavedListPanel();
  }
}

function closeRoutePlanner() {
  const overlay = document.getElementById('route-planner-overlay');
  if (overlay) {
    overlay.classList.remove('active');
  }
  document.body.style.overflow = '';
  resumeMapInteractions();
}

function handleRoutePlannerBackdropClick(event) {
  // Close overlay if clicking on the backdrop (not on the content)
  if (event.target.id === 'route-planner-overlay') {
    closeRoutePlanner();
  }
}

function populateRoutePlannerOverlay(savedCollegesOnRoute) {
  // Update route summary
  const fromEl = document.getElementById('route-planner-from');
  const toEl = document.getElementById('route-planner-to');
  
  if (fromEl && route.start) {
    fromEl.textContent = route.start.description || `${route.start.lat}, ${route.start.lon}`;
  }
  if (toEl && route.end) {
    toEl.textContent = route.end.description || `${route.end.lat}, ${route.end.lon}`;
  }
  
  // Populate colleges list
  const listEl = document.getElementById('route-planner-colleges-list');
  if (!listEl) return;
  
  if (savedCollegesOnRoute.length === 0) {
    listEl.innerHTML = `
      <div class="route-planner-empty-state">
        <p class="route-planner-empty-state-text">
          No saved colleges on this route yet. Tap a blue dot to save schools, then open this planner again.
        </p>
      </div>
    `;
    // Update count to show 0
    updateRoutePlannerCount();
    return;
  }
  
  // Sort colleges by distance from starting address (closest to furthest)
  // This helps Google Maps plan an efficient route starting from the origin
  const units = route.lastResult?.filters?.units || 'mi';
  const startLat = route.start.lat;
  const startLon = route.start.lon;
  
  const sortedColleges = savedCollegesOnRoute.map(item => {
    const college = item.college || item;
    const distanceFromStart = calculateDistance(startLat, startLon, college.lat, college.lon, units);
    return { ...item, distanceFromStart };
  }).sort((a, b) => a.distanceFromStart - b.distanceFromStart);
  
  listEl.innerHTML = sortedColleges.map((item, index) => {
    const college = item.college || item;
    const collegeId = college.college_id;
    const distanceText = item.distanceText || '';
    
    // Extract distance number from distanceText (e.g., "Distance from route: 5.2 mi" -> "5.2 mi")
    let distanceDisplay = '';
    if (distanceText) {
      const match = distanceText.match(/(\d+\.?\d*)\s*(mi|km)/i);
      if (match) {
        distanceDisplay = `${match[1]} ${match[2]} off route`;
      }
    }
    
    const typeDisplay = college.type || 'Unknown';
    
    return `
      <div class="route-planner-college-item">
        <input 
          type="checkbox" 
          class="route-planner-college-checkbox" 
          id="route-college-${collegeId}"
          data-college-id="${collegeId}"
          checked
          onchange="updateRoutePlannerButtonState()"
        >
        <div class="route-planner-college-info">
          <div class="route-planner-college-name">${escapeHtml(college.name || 'Unknown')}</div>
          <div class="route-planner-college-details">${escapeHtml(college.state || '')} · ${escapeHtml(typeDisplay)}</div>
          ${distanceDisplay ? `<div class="route-planner-college-distance">${distanceDisplay}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  // Update button state and count
  updateRoutePlannerButtonState();
}

function updateRoutePlannerCount() {
  const checkboxes = document.querySelectorAll('.route-planner-college-checkbox:checked');
  const titleEl = document.getElementById('route-planner-colleges-title');
  const count = checkboxes.length;
  
  if (titleEl) {
    let text;
    if (count === 0) {
      text = '0 college stops on this route';
    } else if (count === 1) {
      text = '<span class="route-planner-count-number">1</span> college stop on this route';
    } else {
      text = `<span class="route-planner-count-number">${count}</span> college stops on this route`;
    }
    titleEl.innerHTML = text;
  }
}

function updateRoutePlannerButtonState() {
  const checkboxes = document.querySelectorAll('.route-planner-college-checkbox:checked');
  const button = document.getElementById('route-planner-google-maps-btn');
  const errorEl = document.getElementById('route-planner-error');
  
  const hasChecked = checkboxes.length > 0;
  
  if (button) {
    button.disabled = !hasChecked;
  }
  
  if (errorEl) {
    errorEl.style.display = hasChecked ? 'none' : 'block';
  }
  
  // Update the count in the header
  updateRoutePlannerCount();
}

function openRouteInGoogleMaps() {
  const checkboxes = document.querySelectorAll('.route-planner-college-checkbox:checked');
  
  if (checkboxes.length === 0) {
    return;
  }
  
  if (!route.start || !route.end) {
    showError('Route start or end is missing.');
    return;
  }
  
  // Get checked colleges in order (checkboxes are already in sorted order from DOM)
  const checkedColleges = Array.from(checkboxes).map(cb => {
    const collegeId = cb.getAttribute('data-college-id');
    // Find the college from route.lastResult.colleges
    const routeItem = route.lastResult.colleges.find(item => {
      const id = item.college ? item.college.college_id : item.college_id;
      return id === collegeId;
    });
    return routeItem ? (routeItem.college || routeItem) : null;
  }).filter(Boolean);
  
  if (checkedColleges.length === 0) {
    return;
  }
  
  // Sort by distance from start to ensure efficient route planning
  // (Checkboxes are already in sorted order, but this ensures correctness)
  const units = route.lastResult?.filters?.units || 'mi';
  const startLat = route.start.lat;
  const startLon = route.start.lon;
  const sortedCheckedColleges = checkedColleges.map(c => ({
    college: c,
    distanceFromStart: calculateDistance(startLat, startLon, c.lat, c.lon, units)
  })).sort((a, b) => a.distanceFromStart - b.distanceFromStart)
    .map(item => item.college);
  
  // Build Google Maps URL
  // Format: https://www.google.com/maps/dir/?api=1&origin=...&destination=...&waypoints=...|...
  // Use addresses/place names for waypoints to show proper addresses on mobile (not dropped pins)
  const origin = route.start.description || `${route.start.lat},${route.start.lon}`;
  const destination = route.end.description || `${route.end.lat},${route.end.lon}`;
  
  // Use college name + state for waypoints (Google Maps will geocode and show addresses)
  // Format: "College Name, State" - this makes Google Maps show proper addresses on mobile
  const waypoints = sortedCheckedColleges.map(c => {
    const collegeName = (c.name || 'College').trim();
    const state = (c.state || '').trim();
    // Use "College Name, State" format for better geocoding and address display
    return state ? `${collegeName}, ${state}` : collegeName;
  }).join('|');
  
  const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&waypoints=${encodeURIComponent(waypoints)}`;
  
  // Open in new tab
  window.open(googleMapsUrl, '_blank');
  
  // Track GA event
  if (typeof gtag !== 'undefined') {
    gtag('event', 'route_planner_google_maps_opened', {
      'event_category': 'Route Planner',
      'event_label': `${checkedColleges.length} stops`
    });
  }
}

// Helper function to escape HTML
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Update navigation icon visibility based on route mode and saved colleges
function updateNavigationIconVisibility() {
  const navIcon = document.getElementById('saved-navigation-icon');
  const divider = document.querySelector('.saved-only-divider');
  if (!navIcon) {
    console.log('[updateNavigationIconVisibility] Icon element not found');
    return;
  }
  
  // Show icon only when:
  // 1. In route mode (route section is open)
  // 2. Route has active start and end addresses
  // 3. Route has been searched and has results
  // 4. Saved-only mode is active
  // 5. Route has saved colleges along it
  const isRouteMode = activeMode === 'route';
  const hasActiveRoute = route.start && route.end && route.lastResult && route.lastResult.colleges && route.lastResult.colleges.length > 0;
  let hasSavedCollegesOnRoute = false;
  
  if (hasActiveRoute) {
    // Check if any colleges in the route result are saved
    hasSavedCollegesOnRoute = route.lastResult.colleges.some(item => {
      const collegeId = item.college ? item.college.college_id : item.college_id;
      return collegeId && SavedStore.isSaved(collegeId);
    });
  }
  
  const shouldShow = isRouteMode && hasActiveRoute && savedOnlyMode && hasSavedCollegesOnRoute;
  
  console.log('[updateNavigationIconVisibility]', {
    isRouteMode,
    hasActiveRoute,
    savedOnlyMode,
    hasSavedCollegesOnRoute,
    shouldShow,
    routeCollegesCount: route.lastResult?.colleges?.length || 0
  });
  
  if (shouldShow) {
    navIcon.classList.add('visible');
    // Position divider to the left of navigation icon
    if (divider) {
      // Desktop: 59px, Tablet: 57px, Mobile: 55px
      const isMobile = window.innerWidth <= 700;
      const isTablet = window.innerWidth <= 1024 && window.innerWidth > 700;
      if (isMobile) {
        divider.style.setProperty('right', '55px', 'important');
      } else if (isTablet) {
        divider.style.setProperty('right', '57px', 'important');
      } else {
        divider.style.setProperty('right', '59px', 'important');
      }
    }
  } else {
    navIcon.classList.remove('visible');
    // Position divider between "Map Saved Only" and share icon
    if (divider) {
      // Desktop: 30px, Tablet: 28px, Mobile: 26px
      const isMobile = window.innerWidth <= 700;
      const isTablet = window.innerWidth <= 1024 && window.innerWidth > 700;
      if (isMobile) {
        divider.style.setProperty('right', '26px', 'important');
      } else if (isTablet) {
        divider.style.setProperty('right', '28px', 'important');
      } else {
        divider.style.setProperty('right', '30px', 'important');
      }
    }
  }
}

async function handleSavedShareClick(event) {
  event.stopPropagation();
  
  // Hide tooltip on click (desktop) - it will reappear when mouse leaves and re-enters
  const shareIcon = document.getElementById('saved-share-icon');
  const tooltip = shareIcon?.querySelector('.saved-share-tooltip');
  if (tooltip) {
    tooltip.classList.add('tooltip-hidden');
    // Remove hidden class when mouse leaves the icon so tooltip can show again on next hover
    const handleMouseLeave = () => {
      tooltip.classList.remove('tooltip-hidden');
      shareIcon.removeEventListener('mouseleave', handleMouseLeave);
    };
    shareIcon.addEventListener('mouseleave', handleMouseLeave);
  }
  
  // Check if user has saved colleges
  const savedIds = SavedStore.getAll();
  if (savedIds.length === 0) {
    // Should not reach here due to UI safeguards, but handle gracefully
    return;
  }
  
  // Open share overlay
  openShareOverlay();
}

// Share Overlay Functions
function openShareOverlay() {
  const overlay = document.getElementById('share-overlay');
  if (!overlay) {
    console.error('Share overlay not found');
    return;
  }
  
  // Check if user has saved colleges
  const savedIds = SavedStore.getAll();
  if (savedIds.length === 0) {
    return; // Should not reach here, but handle gracefully
  }
  
  // Populate overlay with current data
  populateShareOverlay();
  
  // Show overlay
  overlay.classList.add('active');
  
  // Freeze map interactions to prevent map from scrolling/zooming when overlay is open
  freezeMapInteractions();
  
  // Prevent body scroll when overlay is open
  document.body.style.overflow = 'hidden';
  
  // Close saved list if open
  const savedOverlay = document.getElementById('saved-colleges-overlay');
  if (savedOverlay && savedOverlay.classList.contains('active')) {
    closeSavedListPanel();
  }
  
  // Add keyboard listener for Esc key
  document.addEventListener('keydown', handleShareOverlayKeydown);
}

function closeShareOverlay() {
  const overlay = document.getElementById('share-overlay');
  if (overlay) {
    overlay.classList.remove('active');
  }
  document.body.style.overflow = '';
  resumeMapInteractions();
  
  // Remove keyboard listener
  document.removeEventListener('keydown', handleShareOverlayKeydown);
  
  // Reset copy button state
  const copyBtn = document.getElementById('share-copy-btn');
  if (copyBtn) {
    copyBtn.classList.remove('copied');
    copyBtn.textContent = 'Copy Share Link';
  }
}

function handleShareOverlayKeydown(event) {
  if (event.key === 'Escape') {
    const overlay = document.getElementById('share-overlay');
    if (overlay && overlay.classList.contains('active')) {
      closeShareOverlay();
    }
  }
}

function handleShareOverlayBackdropClick(event) {
  // Close overlay if clicking on the backdrop (not on the content)
  if (event.target.id === 'share-overlay') {
    closeShareOverlay();
  }
}

function populateShareOverlay() {
  const savedIds = SavedStore.getAll();
  const totalSaved = savedIds.length;
  const allSavedColleges = savedIds.map(id => collegesById[id]).filter(c => c);
  
  // Calculate context-relevant saved colleges
  let contextSavedColleges = [];
  let contextSaved = 0;
  let contextLabel = '';
  
  // Get current filter values
  const desktopSearch = document.getElementById('search');
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  const typeVal = document.getElementById('type')?.value || '';
  const regionVal = document.getElementById('region')?.value || '';
  const stateVal = document.getElementById('state')?.value || '';
  const rankingVal = document.getElementById('ranking')?.value || '';
  
  if (activeMode === 'nearby' && home) {
    // Get radius and units
    const radiusEl = document.getElementById('radius');
    const unitsEl = document.getElementById('units');
    const radiusVal = parseFloat(radiusEl?.value || '30');
    const unitsVal = unitsEl?.value || 'mi';
    const effectiveRadius = radiusVal === 0 ? 0.5 : radiusVal;
    
    // Filter saved colleges by distance and filters
    contextSavedColleges = allSavedColleges
      .filter(c => {
        // Apply filters
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        if (stateVal && c.state !== stateVal) return false;
        if (rankingVal) {
          if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
          if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
          if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
          if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
        }
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        // Filter by distance
        const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
        return distance <= effectiveRadius;
      })
      .map(c => {
        const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
        return { college: c, distance, isContext: true };
      })
      .sort((a, b) => a.distance - b.distance);
    
    contextSaved = contextSavedColleges.length;
    contextLabel = 'nearby';
  } else if (activeMode === 'route' && route.start && route.end && route.lastResult && route.lastResult.colleges) {
    // Get route colleges that are saved
    const routeColleges = route.lastResult.colleges.filter(item => {
      const collegeId = item.college ? item.college.college_id : item.college_id;
      return collegeId && SavedStore.isSaved(collegeId);
    });
    
    // Get route distance filter
    const routeMaxDistanceEl = document.getElementById('routeMaxDistance');
    const routeUnitsEl = document.getElementById('routeUnits');
    const units = routeUnitsEl?.value || 'mi';
    
    // Extract distance from route for each college
    contextSavedColleges = routeColleges
      .map(item => {
        const college = item.college || item;
        // Extract distance from distanceText if available
        let distance = 0;
        if (item.distanceText) {
          const match = item.distanceText.match(/(\d+\.?\d*)\s*(mi|km)/i);
          if (match) {
            distance = parseFloat(match[1]);
          }
        }
        // If no distanceText, calculate distance from route start
        if (distance === 0 && route.start) {
          distance = calculateDistance(route.start.lat, route.start.lon, college.lat, college.lon, units);
        }
        return { college, distance, isContext: true };
      })
      .sort((a, b) => a.distance - b.distance);
    
    contextSaved = contextSavedColleges.length;
    contextLabel = 'along the route';
  }
  
  // Get other saved colleges (not in context)
  const contextCollegeIds = new Set(contextSavedColleges.map(item => item.college.college_id));
  const otherSavedColleges = allSavedColleges
    .filter(c => !contextCollegeIds.has(c.college_id))
    .map(c => ({ college: c, distance: 0, isContext: false }));
  
  // Populate summary section
  const summaryEl = document.getElementById('share-summary');
  if (summaryEl) {
    let summaryText = '';
    
    if (activeMode === 'nearby' && home) {
      if (contextSaved === totalSaved) {
        summaryText = `<span class="share-summary-number">${totalSaved}</span> saved ${totalSaved === 1 ? 'college' : 'colleges'} in total. All are in this area.`;
      } else {
        summaryText = `<span class="share-summary-number">${totalSaved}</span> saved ${totalSaved === 1 ? 'college' : 'colleges'} in total, <span class="share-summary-number">${contextSaved}</span> in this area.`;
      }
    } else if (activeMode === 'route' && route.start && route.end) {
      if (contextSaved === totalSaved) {
        summaryText = `<span class="share-summary-number">${totalSaved}</span> saved ${totalSaved === 1 ? 'college' : 'colleges'} in total. All are along this route.`;
      } else {
        summaryText = `<span class="share-summary-number">${totalSaved}</span> saved ${totalSaved === 1 ? 'college' : 'colleges'} in total, <span class="share-summary-number">${contextSaved}</span> along this route.`;
      }
    } else {
      summaryText = `<span class="share-summary-number">${totalSaved}</span> saved ${totalSaved === 1 ? 'college' : 'colleges'} in total.`;
    }
    
    summaryEl.innerHTML = summaryText;
  }
  
  // Populate preview section
  const previewEl = document.getElementById('share-preview');
  if (previewEl) {
    if (allSavedColleges.length === 0) {
      previewEl.innerHTML = '<div class="share-preview-item">No colleges to share.</div>';
    } else {
      // Combine context-relevant colleges first, then others
      const allPreviewColleges = [...contextSavedColleges, ...otherSavedColleges];
      const previewCount = Math.min(5, allPreviewColleges.length);
      const previewColleges = allPreviewColleges.slice(0, previewCount);
      const remainingCount = allPreviewColleges.length - previewCount;
      
      let previewHTML = '<ul class="share-preview-list">';
      previewColleges.forEach(item => {
        const collegeName = escapeHtml(item.college.name);
        const label = item.isContext ? `<span class="share-preview-label">(${contextLabel})</span>` : '';
        previewHTML += `<li class="share-preview-item"><span class="share-preview-checkmark">✓</span>${collegeName}${label}</li>`;
      });
      previewHTML += '</ul>';
      
      if (remainingCount > 0) {
        previewHTML += `<div class="share-preview-more">+${remainingCount} more</div>`;
      }
      
      previewEl.innerHTML = previewHTML;
    }
  }
}

async function handleShareCopyClick() {
  const copyBtn = document.getElementById('share-copy-btn');
  if (!copyBtn) return;
  
  // Generate share URL
  const shareUrl = generateShareURL();
  
  // Google Analytics: Track share action
  if (typeof gtag !== 'undefined') {
    const savedIds = SavedStore.getAll();
    const mode = activeMode || 'explore';
    gtag('event', 'feature_share_used', {
      'college_count': savedIds.length,
      'mode': mode
    });
  }
  
  // Copy to clipboard
  const copied = await copyToClipboard(shareUrl);
  
  if (copied) {
    // Update button state
    copyBtn.classList.add('copied');
    copyBtn.textContent = 'Link copied ✓';
    
    // Reset after 1.5 seconds
    setTimeout(() => {
      copyBtn.classList.remove('copied');
      copyBtn.textContent = 'Copy Share Link';
    }, 1500);
  }
  // If copy fails, silently do nothing (as per requirements)
}

function isLocalStorageAvailable() {
  try {
    const testKey = '__ucm_storage_test__';
    localStorage.setItem(testKey, '1');
    localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    console.warn('localStorage unavailable:', e);
    return false;
  }
}

function parseCollegesCSV(csvText, sourceLabel = 'network') {
  return new Promise((resolve, reject) => {
    Papa.parse(csvText, {
      header: true,
      dynamicTyping: true,
      complete: (results) => {
        if (results.errors && results.errors.length) {
          console.warn(`CSV parsing warnings from ${sourceLabel}:`, results.errors);
        }
        if (!results.data || !results.data.length) {
          reject(new Error('No data rows in CSV'));
          return;
        }
        console.log(`CSV parsing complete from ${sourceLabel}. Rows:`, results.data.length);
        resolve(results.data);
      },
      error: (error) => {
        reject(error);
      }
    });
  });
}

function loadCSV(url){
  if (elements.loading) elements.loading.classList.add('active');
  
  const canUseStorage = isLocalStorageAvailable();
  let cachedCSV = null;
  let cacheLoaded = false;
  
  const handleDataLoad = (data) => {
    processCollegesData(data);
    cacheLoaded = true;
    if (elements.loading) elements.loading.classList.remove('active');
    
    // Apply shared view state after data loads
    console.log('[handleDataLoad] Checking shared view:', { isSharedView, hasSharedViewState: !!window.sharedViewState, sharedViewState: window.sharedViewState });
    if (isSharedView && window.sharedViewState) {
      console.log('[handleDataLoad] Calling applySharedViewState()');
      applySharedViewState();
    } else {
      console.warn('[handleDataLoad] Not applying shared view state - isSharedView:', isSharedView, 'hasSharedViewState:', !!window.sharedViewState);
    }
  };
  
  if (canUseStorage) {
    try {
      cachedCSV = localStorage.getItem(COLLEGE_CACHE_KEY);
      if (cachedCSV) {
        parseCollegesCSV(cachedCSV, 'cache')
          .then(handleDataLoad)
          .catch(err => {
            console.warn('Failed to parse cached CSV:', err);
          });
      }
    } catch (e) {
      console.warn('Unable to read cached CSV:', e);
    }
  }
  
  fetch(url, { cache: 'no-cache' })
    .then(response => {
      if (!response.ok) {
        throw new Error(`Network response not ok (${response.status})`);
      }
      return response.text();
    })
    .then(csvText => {
      const cachedMatches = cachedCSV && csvText === cachedCSV;
      const shouldProcess = !cachedMatches || !cacheLoaded;
      const parseLabel = cachedMatches ? 'network-sync' : (cachedCSV ? 'network-refresh' : 'network');
      
      if (canUseStorage) {
        try {
          if (!cachedMatches) {
            localStorage.setItem(COLLEGE_CACHE_KEY, csvText);
          }
        } catch (e) {
          console.warn('Failed to cache CSV text:', e);
        }
      }
      
      if (shouldProcess) {
        return parseCollegesCSV(csvText, parseLabel)
          .then(handleDataLoad);
      }
    })
    .catch(error => {
      console.error('CSV fetch error:', error);
      if (!cacheLoaded) {
        if (elements.loading) elements.loading.classList.remove('active');
        showError('Error loading colleges data: ' + (error.message || 'Unknown error'));
      } else {
        console.warn('Using cached CSV due to fetch error.');
      }
    });
}

/**
 * Generate a stable fallback college_id for rows missing one.
 */
function buildFallbackCollegeId(row) {
  const safeName = (row.name || 'college')
    .toString()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '') || 'college';
  const state = (row.state || 'XX').toString().toUpperCase();
  const lat = Number(row.lat);
  const lon = Number(row.lon);
  const latStr = Number.isFinite(lat) ? lat.toFixed(3) : '0.000';
  const lonStr = Number.isFinite(lon) ? lon.toFixed(3) : '0.000';
  return `${safeName}_${state}_${latStr}_${lonStr}`;
}

/**
 * Process CSV data and map to internal college objects.
 * 
 * REQUIRED CSV COLUMNS (for creating a "slim" CSV):
 * - name: College name (used in search, popups, tooltips)
 * - lat: Latitude (required for map markers, radius/route filtering)
 * - lon: Longitude (required for map markers, radius/route filtering)
 * - state: State code (used in state filter, region filter, popups)
 * - type: College type (used in type filter dropdown, popups, TYPE_ORDER ranking)
 * - tier: Alternative type field (used as fallback in type filter: c.type || c.tier)
 * - control: Control type (used in popups: "Public | Private")
 * - acceptance: Acceptance rate (used in popups)
 * - enrollment: Enrollment number (used in popups)
 * - tuition: Tuition cost (used in popups)
 * - url: College website URL (used in popups as clickable link)
 * 
 * All other CSV columns can be removed to reduce payload size.
 */
// Lookup object: college_id -> college object
let collegesById = {};

function processCollegesData(data) {
  let processedCount = 0;
  colleges = data.filter(r => r.name && r.lat && r.lon).map(r => {
    const rawId = (r.college_id || '').toString().trim();
    const collegeId = rawId || buildFallbackCollegeId(r);
    
    // Debug: Log first few college IDs to verify format matches shared IDs
    if (isSharedView && sharedViewIds && processedCount < 3) {
      console.log(`[processCollegesData] College ID: "${collegeId}" (type: ${typeof collegeId})`);
      processedCount++;
    }
    
    return {
      college_id: collegeId,
      name: r.name,
      lat: +r.lat,
      lon: +r.lon,
      state: (r.state || '').toUpperCase(),
      type: r.type || 'Unknown',
      tier: r.tier || '', // Used as fallback in type filter: (c.type || c.tier)
      control: r.control || '',
      acceptance: r.acceptance || '',
      enrollment: r.enrollment || '',
      tuition: r.tuition || '',
      url: r.url || '',
      top25_univ: (r.top25_univ || '').toString().trim(),
      top50_univ: (r.top50_univ || '').toString().trim(),
      top10_lac: (r.top10_lac || '').toString().trim(),
      top20_lac: (r.top20_lac || '').toString().trim()
    };
  });
  
  // Build collegesById lookup
  collegesById = {};
  colleges.forEach(c => {
    if (c.college_id) {
      collegesById[c.college_id] = c;
    }
  });
  
  console.log(`Loaded ${colleges.length} colleges`);
  
  if (colleges.length === 0) {
    showError('No college data found. Please check the CSV file.');
    return;
  }
  
  const states = [...new Set(colleges.map(c => c.state))].sort();
  const types = [...new Set(colleges.map(c => c.type))].filter(Boolean);
  const ranked = [...TYPE_ORDER.filter(t => types.includes(t))];
  const leftovers = types.filter(t => !TYPE_ORDER.includes(t)).sort();
  const orderedTypes = ranked.concat(leftovers);
  
  refreshDropdown('state', states, 'All states');
  refreshDropdown('type', orderedTypes, 'All college types');
  refreshDropdown('region', ['Northeast', 'Midwest', 'South', 'West', 'Territories'], 'All regions');
  
  // Update dropdown placeholders based on current screen size (after dropdowns are refreshed)
  updateDropdownPlaceholders();
  
  // Position ranking dropdown after CSV loads
  if (typeof positionRankingDropdown === 'function') {
    positionRankingDropdown();
  }
  
  // Update filter chips after dropdowns are populated
  if (typeof updateFilterChips === 'function') {
    updateFilterChips();
  }
  
  // Ensure we're in nearby mode on initial load (default section is open)
  activeMode = 'nearby';
  
  // Render colleges on initial load (skip if in shared view - applySharedViewState will handle it)
  if (!isSharedView) {
    render();
  } else {
    console.log('Skipping initial render - shared view will handle rendering');
  }
  
}

function geocodeAddress(address, mode = 'nearby'){
  if(!address) {
    if (mode === 'nearby') {
      showError('Please enter an address');
    }
    return Promise.resolve(null);
  }
  
  // Only update map if in the correct active mode
  const shouldUpdateMap = (mode === 'nearby' && activeMode === 'nearby') || (mode === 'route' && activeMode === 'route');
  
  if (mode === 'nearby') {
    closeAutocomplete();
  }
  if (shouldUpdateMap && elements.loading) {
    elements.loading.classList.add('active');
  }
  
  // Note: Address geocoding is independent of state filter - it does not modify state/region/type filters
  // Rate limiting: Nominatim requires a User-Agent and has strict rate limits
  return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`, {
    headers: {
      'User-Agent': 'USCollegeMap/1.0'
    }
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (shouldUpdateMap && elements.loading) {
        elements.loading.classList.remove('active');
      }
      
      if (data && data[0]) {
        const lat = +data[0].lat;
        const lon = +data[0].lon;
        
        if (mode === 'nearby') {
          // Store in nearby state
          home = { lat, lon };
          nearbyState.home = { lat, lon };
          nearbyState.address = address;
          nearbyState.radius = elements.radius ? elements.radius.value : '30';
          nearbyState.units = elements.units ? elements.units.value : 'mi';
          
          // Only update map if nearby mode is active
          if (activeMode === 'nearby') {
        homeLayer.clearLayers();
            radiusLayer.clearLayers();
            
            // Add "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([lat, lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
            
            map.setView([lat, lon], 8);
            render(); // Re-render to apply radius filter
            // Track nearby search completion
            if (typeof gtag !== 'undefined') {
              gtag('event', 'feature_nearby_used');
            }
          }
          saveSharedLocation(address, lat, lon);
          saveRecent(RECENT_STORAGE_KEYS.nearby, address);
          return { lat, lon };
        } else if (mode === 'route') {
          // Return for route mode (caller will store it)
          saveSharedLocation(address, lat, lon);
          return { lat, lon, description: address };
        }
      } else {
        if (shouldUpdateMap) {
          showError('Address not found. Please try a different address.');
        }
        return null;
      }
    })
    .catch(error => {
      if (shouldUpdateMap && elements.loading) {
        elements.loading.classList.remove('active');
        showError('Error geocoding address: ' + (error.message || 'Please try again later'));
        console.error('Geocoding error:', error);
      }
      return null;
    });
}

// Address autocomplete functions
function searchAddresses(query) {
  if (!query || query.length < 3) {
    if (!showAddressRecentsIfEligible()) {
      closeAutocomplete();
    }
    return;
  }
  clearRecentState(elements.addressSuggestions);
  
  // Cancel previous request if any
  if (addressAutocomplete.abortController) {
    addressAutocomplete.abortController.abort();
  }
  
  // Show loading state
  addressAutocomplete.suggestions = [];
  addressAutocomplete.selectedIndex = -1;
  elements.addressSuggestions.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
  elements.addressSuggestions.classList.add('active');
  addressAutocomplete.isOpen = true;
  
  // Create new abort controller
  addressAutocomplete.abortController = new AbortController();
  
  // URL encoding prevents XSS and handles special characters
  const sanitizedQuery = query.trim().substring(0, 200); // Limit query length
  
  // Use Cloudflare proxy for Google Places Autocomplete API
  fetch(`https://cold-bread-f865.cannahere2007.workers.dev/?input=${encodeURIComponent(sanitizedQuery)}`, {
    signal: addressAutocomplete.abortController.signal
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      // Handle empty array or invalid response
      if (!Array.isArray(data) || data.length === 0) {
        addressAutocomplete.suggestions = [];
        renderSuggestions();
        return;
      }
      
      // Google Places API already returns well-ranked results
      // Map the response to our format, keeping up to 5 results
      const results = data.slice(0, 5).map(item => ({
        description: item.description || '',
        place_id: item.place_id || '',
        matchedQuery: query
      }));
      
      addressAutocomplete.suggestions = results;
      renderSuggestions();
    })
    .catch(error => {
      if (error.name === 'AbortError') {
        return; // Request was cancelled, ignore
      }
      console.error('Autocomplete error:', error);
      elements.addressSuggestions.innerHTML = '<div class="autocomplete-empty" style="color:#d93025;">Unable to load suggestions. Please try again.</div>';
    });
}

function formatAddressName(displayName, query = '') {
  // Clean up the display name - remove awkward commas after street numbers
  let cleanedName = displayName.replace(/(\d+),\s+/g, '$1 '); // "25, " becomes "25 "
  
  const parts = cleanedName.split(',').map(p => p.trim()).filter(p => p);
  let primary, secondary;
  
  // Format like Google Maps: primary address on first line, location details on second
  if (parts.length >= 3) {
    // Full address: "Street Address, City, State, Country"
    // Primary: Street Address (first part)
    // Secondary: City, State, Country (remaining parts)
    primary = parts[0];
    secondary = parts.slice(1).join(', ');
  } else if (parts.length === 2) {
    // Two parts: check if first is just a number
    if (/^\d+$/.test(parts[0])) {
      // If "25, Location" -> combine to "25 Location"
      primary = parts.join(' ');
      secondary = '';
    } else {
      // "Street, City" -> Primary: Street, Secondary: City
      primary = parts[0];
      secondary = parts[1];
    }
  } else {
    // Single part
    primary = cleanedName;
    secondary = '';
  }
  
  // Escape HTML first, then apply highlighting
  // This is simpler and safer - we'll find matches in escaped text
  const escapeHtml = (text) => text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  
  // Escape the text first
  let escapedPrimary = escapeHtml(primary);
  secondary = escapeHtml(secondary);
  
  // Now apply highlighting on the escaped text
  if (query && query.length >= 2) {
    const queryLower = query.toLowerCase().trim();
    const escapedQueryLower = escapeHtml(query).toLowerCase();
    const escapedPrimaryLower = escapedPrimary.toLowerCase();
    const matchIndex = escapedPrimaryLower.indexOf(escapedQueryLower);
    
    if (matchIndex !== -1) {
      const before = escapedPrimary.substring(0, matchIndex);
      const match = escapedPrimary.substring(matchIndex, matchIndex + escapeHtml(query).length);
      const after = escapedPrimary.substring(matchIndex + escapeHtml(query).length);
      escapedPrimary = `${before}<strong>${match}</strong>${after}`;
    }
  }
  
  primary = escapedPrimary;
  
  return { primary, secondary };
}

function getAddressTypeIcon(type) {
  // Determine icon based on address type
  const icons = {
    'place': '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>',
    'house': '<path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>',
    'default': '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>'
  };
  
  const addressType = (type || '').toLowerCase();
  if (addressType.includes('house') || addressType.includes('building') || addressType.includes('residential')) {
    return icons.house;
  }
  if (addressType.includes('place') || addressType.includes('point')) {
    return icons.place;
  }
  return icons.default;
}

function renderSuggestions() {
  clearRecentState(elements.addressSuggestions);
  const queryValue = (elements.address?.value || '').trim();
  const unifiedSection = buildUnifiedRecentSection(getFallbackRecentsForField('address'), {
    query: queryValue,
    filterShared: true,
    filterFallback: true
  });
  if (addressAutocomplete.suggestions.length === 0) {
    const emptyHtml = '<div class="autocomplete-empty" role="option">No suggestions found</div>';
    elements.addressSuggestions.innerHTML = unifiedSection ? unifiedSection + emptyHtml : emptyHtml;
    return;
  }
  
  const html = addressAutocomplete.suggestions.map((item, index) => {
    const isSelected = index === addressAutocomplete.selectedIndex;
    const query = item.matchedQuery || '';
    const formatted = formatAddressName(item.description, query);
    
    // formatAddressName already escapes HTML and handles <strong> tags
    const safePrimary = formatted.primary;
    const safeSecondary = formatted.secondary;
    const safeFullName = item.description.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;');
    
    // Get icon - Google Places API doesn't provide type in autocomplete, use default
    const iconPath = getAddressTypeIcon('place');
    
    return `
      <div class="autocomplete-item ${isSelected ? 'highlighted' : ''}" 
           role="option"
           id="suggestion-${index}"
           aria-selected="${isSelected}"
           tabindex="${isSelected ? '0' : '-1'}"
           data-index="${index}">
        <div class="autocomplete-item-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            ${iconPath}
          </svg>
        </div>
        <div class="autocomplete-item-content">
          <div class="address-name">${safePrimary}</div>
          ${safeSecondary ? `<div class="address-details">${safeSecondary}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  elements.addressSuggestions.innerHTML = unifiedSection + html;
  elements.address.setAttribute('aria-expanded', 'true');
  
  // Add mouseenter handlers for highlighting
  elements.addressSuggestions.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    // Ensure item is properly clickable
    item.style.pointerEvents = 'auto';
    item.style.cursor = 'pointer';
    
    // Add direct click handler - this is the primary method
    const handleClick = (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      e.stopPropagation();
      selectSuggestion(index);
      return false;
    };
    
    item.addEventListener('click', handleClick, true);
    item.addEventListener('mousedown', (e) => {
      e.preventDefault(); // Prevent input blur
    });
    
    // Update highlight without re-rendering - just update classes
    item.addEventListener('mouseenter', () => {
      addressAutocomplete.selectedIndex = index;
      updateHighlight();
    });
    
    // Also handle touch events for mobile
    item.addEventListener('touchend', handleClick, { passive: false, capture: true });
  });
}

function selectSuggestion(index) {
  if (!addressAutocomplete.suggestions || !addressAutocomplete.suggestions[index]) {
    console.warn('No suggestion at index:', index, 'Available:', addressAutocomplete.suggestions.length);
    return;
  }
  
  const suggestion = addressAutocomplete.suggestions[index];
  const description = suggestion.description || '';
  
  if (!description) {
    console.warn('No description found for suggestion at index:', index);
    return;
  }
  
  // Mark that we're programmatically setting the value (prevents triggering new search)
  addressAutocomplete.isSelecting = true;
  
  // Close dropdown FIRST - instant visual feedback
  closeAutocomplete();
  
  // Set the input value immediately - user sees it instantly
  elements.address.value = description;
  saveRecent(RECENT_STORAGE_KEYS.nearby, description);
  
  // Clear the flag after a brief delay to allow the value to be set
  setTimeout(() => {
    addressAutocomplete.isSelecting = false;
  }, 100);
  
  // Geocode the address to update the map (this happens asynchronously)
  // Always geocode and show pin if we're in nearby mode
  // Also check if the nearby section is open (even if activeMode hasn't been set yet)
  const nearbySection = document.querySelector('details.filter-section[open] summary');
  const isNearbySectionOpen = nearbySection && nearbySection.textContent.trim().includes('Find Colleges Nearby');
  
  if (activeMode === 'nearby' || isNearbySectionOpen) {
    // Ensure activeMode is set to nearby if section is open
    if (isNearbySectionOpen && activeMode !== 'nearby') {
      activeMode = 'nearby';
    }
    geocodeAddress(description, 'nearby');
  } else {
    // Store the address value but don't update map if in route mode
    nearbyState.address = description;
  }
}

function closeAutocomplete() {
  clearRecentState(elements.addressSuggestions);
  elements.addressSuggestions.classList.remove('active');
  elements.address.setAttribute('aria-expanded', 'false');
  addressAutocomplete.isOpen = false;
  addressAutocomplete.selectedIndex = -1;
}

function updateHighlight() {
  // Update highlight without re-rendering - just update classes
  elements.addressSuggestions.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    if (index === addressAutocomplete.selectedIndex) {
      item.classList.add('highlighted');
      item.setAttribute('aria-selected', 'true');
      item.setAttribute('tabindex', '0');
    } else {
      item.classList.remove('highlighted');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('tabindex', '-1');
    }
  });
}

function handleAutocompleteKeydown(e) {
  if (!addressAutocomplete.isOpen || addressAutocomplete.suggestions.length === 0) {
    if (e.key === 'Enter') {
      e.preventDefault();
      geocodeAddress(elements.address.value);
    }
    return;
  }
  
  switch(e.key) {
    case 'ArrowDown':
      e.preventDefault();
      addressAutocomplete.selectedIndex = Math.min(
        addressAutocomplete.selectedIndex + 1,
        addressAutocomplete.suggestions.length - 1
      );
      updateHighlight();
      scrollToSelected();
      break;
      
    case 'ArrowUp':
      e.preventDefault();
      addressAutocomplete.selectedIndex = Math.max(addressAutocomplete.selectedIndex - 1, -1);
      updateHighlight();
      scrollToSelected();
      break;
      
    case 'Enter':
      e.preventDefault();
      if (addressAutocomplete.selectedIndex >= 0) {
        selectSuggestion(addressAutocomplete.selectedIndex);
      } else {
        geocodeAddress(elements.address.value);
      }
      break;
      
    case 'Escape':
      e.preventDefault();
      closeAutocomplete();
      break;
  }
}

function scrollToSelected() {
  const selected = elements.addressSuggestions.querySelector('.autocomplete-item.highlighted');
  if (selected) {
    selected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

// Route autocomplete functions (similar to address autocomplete but for route fields)
function searchRouteAddresses(query, autocompleteObj, inputElement, suggestionsContainer) {
  const storageKey = inputElement && inputElement.id === 'routeStart' ? RECENT_STORAGE_KEYS.routeStart : RECENT_STORAGE_KEYS.routeEnd;
  const context = inputElement && inputElement.id === 'routeStart' ? 'routeStart' : 'routeEnd';
  if (!query || query.length < 3) {
    if (!showRouteRecentsIfEligible(inputElement, suggestionsContainer, autocompleteObj, storageKey, context)) {
      closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement);
    }
    return;
  }
  clearRecentState(suggestionsContainer);
  
  if (autocompleteObj.abortController) {
    autocompleteObj.abortController.abort();
  }
  
  autocompleteObj.suggestions = [];
  autocompleteObj.selectedIndex = -1;
  suggestionsContainer.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
  suggestionsContainer.classList.add('active');
  autocompleteObj.isOpen = true;
  
  autocompleteObj.abortController = new AbortController();
  const sanitizedQuery = query.trim().substring(0, 200);
  
  fetch(`https://cold-bread-f865.cannahere2007.workers.dev/?input=${encodeURIComponent(sanitizedQuery)}`, {
    signal: autocompleteObj.abortController.signal
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (!data || !Array.isArray(data) || data.length === 0) {
        autocompleteObj.suggestions = [];
        renderRouteSuggestions(autocompleteObj, suggestionsContainer);
        return;
      }
      
      const results = data.slice(0, 5).map(item => ({
        description: item.description || '',
        place_id: item.place_id || ''
      }));
      
      autocompleteObj.suggestions = results;
      renderRouteSuggestions(autocompleteObj, suggestionsContainer, inputElement);
    })
    .catch(error => {
      if (error.name !== 'AbortError') {
        console.error('Route autocomplete error:', error);
        autocompleteObj.suggestions = [];
        if (suggestionsContainer) {
          suggestionsContainer.innerHTML = '<div class="autocomplete-empty" style="color:#d93025;">Unable to load suggestions. Please try again.</div>';
        }
      }
    });
}

function renderRouteSuggestions(autocompleteObj, suggestionsContainer, inputElement) {
  clearRecentState(suggestionsContainer);
  const fieldId = (inputElement && inputElement.id === 'routeEnd') ? 'routeEnd' :
                  (inputElement && inputElement.id === 'routeStart') ? 'routeStart' :
                  (suggestionsContainer && suggestionsContainer.dataset.field) || '';
  const queryValue = (inputElement?.value || '').trim();
  const unifiedSection = buildUnifiedRecentSection(getFallbackRecentsForField(fieldId), {
    query: queryValue,
    filterShared: true,
    filterFallback: true
  });
  if (autocompleteObj.suggestions.length === 0) {
    const emptyHtml = '<div class="autocomplete-empty" role="option">No suggestions found</div>';
    suggestionsContainer.innerHTML = unifiedSection ? unifiedSection + emptyHtml : emptyHtml;
    return;
  }
  
  // Get icon function (same as nearby autocomplete)
  const getAddressTypeIcon = (type) => {
    const icons = {
      place: '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>',
      default: '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>'
    };
    return icons[type] || icons.default;
  };
  
  const html = autocompleteObj.suggestions.map((item, index) => {
    const isSelected = index === autocompleteObj.selectedIndex;
    const formatted = formatAddressName(item.description, '');
    const iconPath = getAddressTypeIcon('place');
    
    return `
      <div class="autocomplete-item ${isSelected ? 'highlighted' : ''}" 
           role="option" 
           aria-selected="${isSelected}" 
           tabindex="${isSelected ? '0' : '-1'}"
           data-index="${index}">
        <div class="autocomplete-item-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            ${iconPath}
          </svg>
        </div>
        <div class="autocomplete-item-content">
          <div class="address-name">${formatted.primary}</div>
          ${formatted.secondary ? `<div class="address-details">${formatted.secondary}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  suggestionsContainer.innerHTML = unifiedSection + html;
  inputElement.setAttribute('aria-expanded', 'true');
  
  suggestionsContainer.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    item.style.pointerEvents = 'auto';
    item.style.cursor = 'pointer';
    
    const handleClick = (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      e.stopPropagation();
      selectRouteSuggestion(index, autocompleteObj, inputElement, suggestionsContainer);
      return false;
    };
    
    item.addEventListener('click', handleClick, true);
    item.addEventListener('mousedown', (e) => {
      e.preventDefault();
    });
    
    item.addEventListener('mouseenter', () => {
      autocompleteObj.selectedIndex = index;
      updateRouteHighlight(autocompleteObj, suggestionsContainer);
    });
    
    item.addEventListener('touchend', handleClick, { passive: false, capture: true });
  });
}

function selectRouteSuggestion(index, autocompleteObj, inputElement, suggestionsContainer) {
  if (!autocompleteObj.suggestions || !autocompleteObj.suggestions[index]) {
    return;
  }
  
  const suggestion = autocompleteObj.suggestions[index];
  const description = suggestion.description || '';
  
  if (!description) {
    return;
  }
  
  autocompleteObj.isSelecting = true;
  closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement);
  inputElement.value = description;
  notifyRouteInputsUpdated(true);
  if (inputElement.id === 'routeStart') {
    saveRecent(RECENT_STORAGE_KEYS.routeStart, description);
  } else if (inputElement.id === 'routeEnd') {
    saveRecent(RECENT_STORAGE_KEYS.routeEnd, description);
  }
  
  setTimeout(() => {
    autocompleteObj.isSelecting = false;
  }, 100);
  
  // Geocode and store in route state (but don't update map yet)
  geocodeAddress(description, 'route').then(result => {
    if (result) {
      if (inputElement.id === 'routeStart') {
        route.start = { description, lat: result.lat, lon: result.lon };
        console.log('Route start set:', route.start);
      } else if (inputElement.id === 'routeEnd') {
        route.end = { description, lat: result.lat, lon: result.lon };
        console.log('Route end set:', route.end);
      }
    } else {
      console.warn('Geocoding failed for route address:', description);
    }
  }).catch(error => {
    console.error('Error geocoding route address:', error);
  });
}

function closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement) {
  clearRecentState(suggestionsContainer);
  suggestionsContainer.classList.remove('active');
  inputElement.setAttribute('aria-expanded', 'false');
  autocompleteObj.isOpen = false;
  autocompleteObj.selectedIndex = -1;
}

function updateRouteHighlight(autocompleteObj, suggestionsContainer) {
  suggestionsContainer.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    if (index === autocompleteObj.selectedIndex) {
      item.classList.add('highlighted');
      item.setAttribute('aria-selected', 'true');
      item.setAttribute('tabindex', '0');
    } else {
      item.classList.remove('highlighted');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('tabindex', '-1');
    }
  });
}

/**
 * LAZY LOADED: Route calculation function - only executed when route mode is first used
 * Calculate perpendicular distance from a point to a line segment (using Haversine formula)
 * Returns the shortest distance from point P to line segment AB
 * 
 * Performance: This heavy computation is only executed when user interacts with route mode
 */
function distanceToLineSegment(pointLat, pointLon, lineStartLat, lineStartLon, lineEndLat, lineEndLon, units = 'mi') {
  // Calculate distances to endpoints
  const dAP = calculateDistance(lineStartLat, lineStartLon, pointLat, pointLon, units);
  const dBP = calculateDistance(lineEndLat, lineEndLon, pointLat, pointLon, units);
  const dAB = calculateDistance(lineStartLat, lineStartLon, lineEndLat, lineEndLon, units);
  
  // If the point is exactly at one of the endpoints, return 0
  if (dAP < 0.001) return 0;
  if (dBP < 0.001) return 0;
  
  // If the line segment is very short, return distance to nearest endpoint
  if (dAB < 0.01) {
    return Math.min(dAP, dBP);
  }
  
  // Convert to radians for spherical calculations
  const toRad = Math.PI / 180;
  const R = units === 'mi' ? 3959 : 6371;
  
  const latA = lineStartLat * toRad;
  const lonA = lineStartLon * toRad;
  const latB = lineEndLat * toRad;
  const lonB = lineEndLon * toRad;
  const latP = pointLat * toRad;
  const lonP = pointLon * toRad;
  
  // Calculate angular distances (in radians)
  const angularAP = dAP / R;
  const angularAB = dAB / R;
  const angularBP = dBP / R;
  
  // Calculate bearings using atan2 for numerical stability
  // Bearing from A to B
  const dLonAB = lonB - lonA;
  const yAB = Math.sin(dLonAB) * Math.cos(latB);
  const xAB = Math.cos(latA) * Math.sin(latB) - Math.sin(latA) * Math.cos(latB) * Math.cos(dLonAB);
  const bearingAB = Math.atan2(yAB, xAB);
  
  // Bearing from A to P
  const dLonAP = lonP - lonA;
  const yAP = Math.sin(dLonAP) * Math.cos(latP);
  const xAP = Math.cos(latA) * Math.sin(latP) - Math.sin(latA) * Math.cos(latP) * Math.cos(dLonAP);
  const bearingAP = Math.atan2(yAP, xAP);
  
  // Calculate the angular difference between bearings
  const bearingDiff = bearingAP - bearingAB;
  
  // Calculate cross-track distance (perpendicular distance to the great circle)
  // This is the angular distance from point P to the great circle through A and B
  const sinCrossTrack = Math.sin(angularAP) * Math.sin(bearingDiff);
  const sinCrossTrackClamped = Math.max(-1, Math.min(1, sinCrossTrack));
  const crossTrackAngular = Math.asin(sinCrossTrackClamped);
  const crossTrackDist = Math.abs(crossTrackAngular * R);
  
  // Calculate along-track distance (distance along the great circle from A)
  // Use spherical law of cosines: cos(alongTrack) = cos(angularAP) / cos(crossTrackAngular)
  // But handle edge cases where cos(crossTrackAngular) might be very small
  const cosCrossTrack = Math.cos(crossTrackAngular);
  if (Math.abs(cosCrossTrack) < 1e-10) {
    // Perpendicular is very close to 90 degrees, use alternative calculation
    // If cross-track is near 90°, along-track is near 0
    const alongTrackDist = 0;
    
    // Check if point is within segment bounds
    if (alongTrackDist >= 0 && alongTrackDist <= dAB) {
      return crossTrackDist;
    } else {
      return Math.min(dAP, dBP);
    }
  }
  
  const cosAlongTrack = Math.cos(angularAP) / cosCrossTrack;
  const cosAlongTrackClamped = Math.max(-1, Math.min(1, cosAlongTrack));
  const alongTrackAngular = Math.acos(cosAlongTrackClamped);
  const alongTrackDist = alongTrackAngular * R;
  
  // Check if the perpendicular foot lies within the segment bounds
  // The along-track distance should be between 0 and dAB
  if (alongTrackDist >= 0 && alongTrackDist <= dAB) {
    // Perpendicular point is within the segment
    return crossTrackDist;
  } else {
    // Perpendicular point is outside the segment, return distance to nearest endpoint
    return Math.min(dAP, dBP);
  }
}

/**
 * LAZY LOADED: Route search function - only executed when user clicks "Find" in route mode
 * Prevents infinite loops by checking if already processing
 * 
 * Performance: Heavy OSRM API calls and distance calculations only run when:
 * - User enters start/end addresses AND clicks "Find" button
 * - NOT on initial page load
 * - NOT when just switching to route mode
 */
let isProcessingRoute = false;

function findCollegesAlongRoute() {
  // Guard against infinite loops
  if (isProcessingRoute) {
    console.log('Route already processing, skipping...');
    return;
  }
  
  if (activeMode !== 'route') {
    console.log('Not in route mode, current mode:', activeMode);
    return;
  }
  
  if (!route.start || !route.end) {
    showError('Please enter both starting and destination addresses.');
    console.log('Route start or end missing:', { start: route.start, end: route.end });
    return;
  }
  
  console.log('Starting route search...', { start: route.start, end: route.end });
  
  // Check if colleges data is loaded
  if (!colleges || colleges.length === 0) {
    showError('College data is still loading. Please wait a moment and try again.');
    console.log('Colleges data not loaded yet');
    return;
  }
  
  isProcessingRoute = true;
  
  // Parse maxDistance - handle 0 correctly (don't use || operator as 0 is falsy)
  const maxDistanceInputStr = elements.routeMaxDistance?.value;
  let maxDistanceInput;
  if (maxDistanceInputStr === '' || maxDistanceInputStr === null || maxDistanceInputStr === undefined) {
    maxDistanceInput = 30;
  } else {
    maxDistanceInput = parseFloat(maxDistanceInputStr);
    if (isNaN(maxDistanceInput)) {
      maxDistanceInput = 30;
    }
  }
  // If maxDistance is 0, use 0.5 instead
  const maxDistance = maxDistanceInput === 0 ? 0.5 : maxDistanceInput;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  
  // Store route search state
  route.lastSearch = {
    start: route.start,
    end: route.end,
    maxDistance,
    units
  };
  
  if (elements.loading) elements.loading.classList.add('active');
  
  // Clear previous route visualization
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  homeLayer.clearLayers();
  radiusLayer.clearLayers();
  
  // Validate route coordinates
  if (isNaN(route.start.lat) || isNaN(route.start.lon) || isNaN(route.end.lat) || isNaN(route.end.lon)) {
    console.error('Invalid route coordinates:', { start: route.start, end: route.end });
    showError('Invalid route coordinates. Please check your addresses.');
    if (elements.loading) elements.loading.classList.remove('active');
    isProcessingRoute = false;
    return;
  }
  
  // Get actual driving route using OSRM (Open Source Routing Machine)
  // Format: lon,lat (OSRM uses lon,lat order)
  const startCoords = `${route.start.lon},${route.start.lat}`;
  const endCoords = `${route.end.lon},${route.end.lat}`;
  const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${startCoords};${endCoords}?overview=full&geometries=geojson`;
  
  // Add timeout to fetch request
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
  
  fetch(osrmUrl, { signal: controller.signal })
    .then(r => {
      clearTimeout(timeoutId);
      if (!r.ok) throw new Error(`Routing failed: ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (!data || data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
        throw new Error('No route found');
      }
      
      // Validate route geometry
      if (!data.routes[0].geometry || !data.routes[0].geometry.coordinates || data.routes[0].geometry.coordinates.length === 0) {
        throw new Error('Invalid route geometry');
      }
      
      const routeGeometry = data.routes[0].geometry.coordinates;
      // Convert from [lon, lat] to [lat, lon] for Leaflet
      const routeCoords = routeGeometry.map(coord => [coord[1], coord[0]]);
      
      // Draw the actual driving route with ribbon effect
      const zoom = map ? map.getZoom() : 5;
      const routeWeights = calculateRouteLineWeights(zoom);
      
      // First draw the deep navy outline (thin line for ribbon effect)
      routeOutlinePolyline = L.polyline(routeCoords, {
        color: '#0A2CA5',
        weight: routeWeights.outlineWeight,
        opacity: routeWeights.outlineOpacity
      }).addTo(routeLayer);
      // Then draw the vivid royal blue main route line on top
      routeMainPolyline = L.polyline(routeCoords, {
        color: '#1A4CFF',
        weight: routeWeights.mainWeight,
        opacity: routeWeights.mainOpacity
      }).addTo(routeLayer);
      
      // Track route search completion
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_route_used');
      }
      
      // Draw start and destination markers (map pins - smaller size)
      // Start pin (white circle with black border)
      L.marker([route.start.lat, route.start.lon], {
        icon: L.icon({
          iconUrl: ROUTE_START_PIN_ICON,
          iconSize: [18, 18],
          iconAnchor: [9, 9],
          popupAnchor: [0, -9]
        })
      }).addTo(routeLayer).bindPopup('From');
      
      // Destination pin (red teardrop)
      L.marker([route.end.lat, route.end.lon], {
        icon: L.icon({
          iconUrl: ROUTE_END_PIN_ICON,
          iconSize: [24, 30],
          iconAnchor: [12, 30],
          popupAnchor: [0, -30]
        })
      }).addTo(routeLayer).bindPopup('To');
      
      // Calculate route bounds and fit map
      const polylineBounds = L.latLngBounds(routeCoords);
      let routeBounds = L.latLngBounds(routeCoords);
      
      // Apply cheaper filters first (type, region, state, ranking, search) before expensive distance calculations
      const typeVal = elements.type ? elements.type.value.trim() : '';
      const regionVal = elements.region ? elements.region.value.trim() : '';
      const stateVal = elements.state ? elements.state.value.trim() : '';
      const rankingVal = elements.ranking ? elements.ranking.value.trim() : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      const filtersSnapshot = { typeVal, regionVal, stateVal, rankingVal, searchVal, maxDistance, units };
      
      // Pre-filter by other criteria before expensive distance calculations
      const preFiltered = colleges.filter(c => {
        // Type filter - check both type and tier fields
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        // Region filter - use REGION_MAP to check if state is in region
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        // Ranking filter
        if (rankingVal) {
          if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
          if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
          if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
          if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
        }
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        return true;
      });
      
      // Sample route points to improve performance (check every 3rd-4th point for long routes)
      const sampleRate = routeCoords.length > 100 ? 3 : 1;
      const sampledRoute = [];
      for (let i = 0; i < routeCoords.length; i += sampleRate) {
        sampledRoute.push(routeCoords[i]);
      }
      // Always include the last point
      if (sampledRoute[sampledRoute.length - 1] !== routeCoords[routeCoords.length - 1]) {
        sampledRoute.push(routeCoords[routeCoords.length - 1]);
      }
      
      // Filter by distance to route - always calculate true minimum across all segments for accurate display
      const allRouteColleges = preFiltered.map(c => {
        // Check distance to each segment of the sampled route
        let minRouteDist = Infinity;
        
        // Check all segments to find the true minimum distance (no early exit for accuracy)
        for (let i = 0; i < sampledRoute.length - 1; i++) {
          const segmentStart = sampledRoute[i];
          const segmentEnd = sampledRoute[i + 1];
          
          const dist = distanceToLineSegment(
            c.lat, c.lon,
            segmentStart[0], segmentStart[1],
            segmentEnd[0], segmentEnd[1],
            units
          );
          
          // Always track true minimum across all segments for accurate display
          minRouteDist = Math.min(minRouteDist, dist);
        }
        
        return { college: c, distance: minRouteDist };
      }).filter(item => item.distance <= maxDistance) // Filter by true minimum distance
        .map(item => {
          // Create distance text using the true minimum distance
          const distanceText = item.distance < Infinity 
            ? `<br>Distance from route: ${item.distance.toFixed(1)} ${units}`
            : '';
          return { college: item.college, distanceText };
        });
      // Calculate bounds for ALL colleges (for caching/restoration)
      allRouteColleges.forEach(item => {
        routeBounds.extend([item.college.lat, item.college.lon]);
      });
      
      const visibleRouteColleges = savedOnlyMode
        ? allRouteColleges.filter(item => SavedStore.isSaved(item.college.college_id))
        : allRouteColleges;
      
      // Calculate bounds for VISIBLE colleges (for map focus)
      const visibleRouteBounds = L.latLngBounds(routeCoords);
      visibleRouteColleges.forEach(item => {
        visibleRouteBounds.extend([item.college.lat, item.college.lon]);
      });
      
      if (visibleRouteColleges.length === 0 && savedOnlyMode) {
        const savedCount = SavedStore.getAll().length;
        if (savedCount === 0) {
          console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
        } else {
          console.log("No saved colleges match your current filters or route.");
        }
      }
      
      // Clear and render markers (using same style as nearby mode - blue circle dots)
      markersLayer.clearLayers();
      // Clear marker registry
      Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      visibleRouteColleges.forEach(item => {
        addRouteCollegeMarker(item.college, item.distanceText, units);
      });
      
      if (elements.count) elements.count.textContent = visibleRouteColleges.length;
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Update map hints for route mode
      updateMapHints(visibleRouteColleges.length, typeVal, regionVal, stateVal, searchVal);
      
      // Map focus logic: use visible bounds for map focus
      if (visibleRouteColleges.length > 0 && visibleRouteBounds.isValid()) {
        map.fitBounds(visibleRouteBounds.pad(0.15));
      } else if (polylineBounds.isValid()) {
        map.fitBounds(polylineBounds.pad(0.15));
      }

      // Store ALL colleges bounds (for caching/restoration)
      route.lastResult = {
        bounds: routeBounds.isValid() ? routeBounds : polylineBounds,
        routeCoords,
        colleges: allRouteColleges,
        filters: filtersSnapshot,
        start: route.start ? { ...route.start } : null,
        end: route.end ? { ...route.end } : null
      };
      
      isProcessingRoute = false;
      
      // Check if saved-only mode should be turned OFF after filter change
      checkAndHandleNoVisibleSavedColleges();
      
      // Update navigation icon visibility after route search completes
      updateNavigationIconVisibility();
    })
    .catch(error => {
      clearTimeout(timeoutId);
      console.error('Route calculation error:', error);
      
      // If it's an abort error (timeout), show specific message but still use fallback
      if (error.name === 'AbortError') {
        showError('Route calculation timed out. Showing approximate results.');
      }
      
      // Wrap fallback processing in try-catch to ensure loading is always cleared
      try {
        // Check if colleges data is available for fallback
        if (!colleges || colleges.length === 0) {
          console.error('Colleges data not available for fallback');
          showError('College data is not loaded. Please refresh the page and try again.');
          if (elements.loading) elements.loading.classList.remove('active');
          isProcessingRoute = false;
          return;
        }
        
        // Fallback to straight line if routing fails
        const fallbackRouteCoords = [
          [route.start.lat, route.start.lon],
          [route.end.lat, route.end.lon]
        ];
      // Draw fallback route with ribbon effect
      const zoom = map ? map.getZoom() : 5;
      const routeWeights = calculateRouteLineWeights(zoom);
      
      // First draw the deep navy outline (thin line for ribbon effect)
      routeOutlinePolyline = L.polyline(
        fallbackRouteCoords,
        { 
          color: '#0A2CA5', 
          weight: routeWeights.outlineWeight, 
          opacity: routeWeights.outlineOpacity 
        }
      ).addTo(routeLayer);
      // Then draw the vivid royal blue main route line on top
      routeMainPolyline = L.polyline(
        fallbackRouteCoords,
        { 
          color: '#1A4CFF', 
          weight: routeWeights.mainWeight, 
          opacity: routeWeights.mainOpacity 
        }
      ).addTo(routeLayer);
      
      // Track route search completion (fallback route)
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_route_used');
      }
      
      const fallbackBounds = L.latLngBounds(fallbackRouteCoords);
      
      // Use simple distance calculation as fallback
      const filtered = colleges.filter(c => {
        const distToStart = calculateDistance(route.start.lat, route.start.lon, c.lat, c.lon, units);
        const distToEnd = calculateDistance(route.end.lat, route.end.lon, c.lat, c.lon, units);
        const routeLength = calculateDistance(route.start.lat, route.start.lon, route.end.lat, route.end.lon, units);
        
        // Simple approximation: if within maxDistance of the straight line
        const minDist = Math.min(distToStart, distToEnd);
        if (minDist <= maxDistance) return true;
        
        // Check if point is within corridor (rough approximation)
        const midLat = (route.start.lat + route.end.lat) / 2;
        const midLon = (route.start.lon + route.end.lon) / 2;
        const distToMid = calculateDistance(midLat, midLon, c.lat, c.lon, units);
        return distToMid <= maxDistance * 1.5; // Slightly more lenient for fallback
      });
      
      // Apply other filters
      const typeVal = elements.type ? elements.type.value.trim() : '';
      const regionVal = elements.region ? elements.region.value.trim() : '';
      const stateVal = elements.state ? elements.state.value.trim() : '';
      const rankingVal = elements.ranking ? elements.ranking.value.trim() : '';
      const searchVal = (elements.search ? elements.search.value.trim().toLowerCase() : '') || 
                        (document.getElementById('search-mobile') ? document.getElementById('search-mobile').value.trim().toLowerCase() : '');
      
      const filtersSnapshot = { typeVal, regionVal, stateVal, rankingVal, searchVal, maxDistance, units };
      const finalFiltered = filtered.filter(c => {
        // Type filter - check both type and tier fields
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        // Region filter - use REGION_MAP to check if state is in region
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        // Ranking filter
        if (rankingVal) {
          if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
          if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
          if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
          if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
        }
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        return true;
      });
      
      const fallbackRouteEntries = finalFiltered.map(c => {
        const distToStart = calculateDistance(route.start.lat, route.start.lon, c.lat, c.lon, units);
        const distToEnd = calculateDistance(route.end.lat, route.end.lon, c.lat, c.lon, units);
        const minDist = Math.min(distToStart, distToEnd);
        const distanceText = `<br>Approx. distance from route: ${minDist.toFixed(1)} ${units}`;
        return { college: c, distanceText };
      });
      const fallbackCollegeBounds = L.latLngBounds(fallbackRouteCoords);
      fallbackRouteEntries.forEach(entry => {
        fallbackCollegeBounds.extend([entry.college.lat, entry.college.lon]);
      });
      
      const visibleFallbackEntries = savedOnlyMode
        ? fallbackRouteEntries.filter(item => SavedStore.isSaved(item.college.college_id))
        : fallbackRouteEntries;
      
      if (visibleFallbackEntries.length === 0 && savedOnlyMode) {
        const savedCount = SavedStore.getAll().length;
        if (savedCount === 0) {
          console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
        } else {
          console.log("No saved colleges match your current filters or route.");
        }
      }
      
      // Clear and render markers (using same style as nearby mode)
      markersLayer.clearLayers();
      // Clear marker registry
      Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      visibleFallbackEntries.forEach(item => {
        addRouteCollegeMarker(item.college, item.distanceText, units);
      });
      
      if (elements.count) elements.count.textContent = visibleFallbackEntries.length;
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Update map hints for route mode (fallback)
      updateMapHints(visibleFallbackEntries.length, typeVal, regionVal, stateVal, searchVal);
      if (fallbackCollegeBounds.isValid()) {
        map.fitBounds(fallbackCollegeBounds.pad(0.15));
      } else if (fallbackBounds.isValid()) {
        map.fitBounds(fallbackBounds.pad(0.15));
      }

      route.lastResult = {
        bounds: fallbackCollegeBounds.isValid() ? fallbackCollegeBounds : fallbackBounds,
        routeCoords: fallbackRouteCoords,
        colleges: fallbackRouteEntries,
        filters: filtersSnapshot,
        start: route.start ? { ...route.start } : null,
        end: route.end ? { ...route.end } : null
      };
      
        // Only show general error if it wasn't a timeout (timeout message already shown)
        if (error.name !== 'AbortError') {
          showError('Could not calculate driving route. Showing approximate results.');
        }
      } catch (fallbackError) {
        // If fallback processing fails, ensure loading is cleared and flag is reset
        console.error('Fallback processing error:', fallbackError);
        showError('Error processing route. Please try again.');
        if (elements.loading) elements.loading.classList.remove('active');
        isProcessingRoute = false;
        return;
      }
      
      // Ensure loading indicator is cleared and flag is reset after fallback completes
      if (elements.loading) elements.loading.classList.remove('active');
      isProcessingRoute = false;
      
      // Update navigation icon visibility after route search completes
      updateNavigationIconVisibility();
      
      // Check if saved-only mode should be turned OFF after filter change
      checkAndHandleNoVisibleSavedColleges();
    });
}

// Initialize dropdowns immediately
// Region dropdown (doesn't depend on CSV)
refreshDropdown('region', ['Northeast', 'Midwest', 'South', 'West', 'Territories'], 'All regions');

// Update dropdown placeholder text based on screen size
function updateDropdownPlaceholders() {
  const width = window.innerWidth || document.documentElement.clientWidth;
  const isMobile = width <= 700;
  const isTablet = width >= 701 && width <= 1024;
  
  // Debug: log when mobile mode is detected
  if (isMobile) {
    console.log('[updateDropdownPlaceholders] Mobile mode - width:', width);
  }
  
  // List of filter dropdown IDs
  const filterDropdowns = ['type', 'region', 'state', 'ranking'];
  
  // Explicitly enforce font-size for mobile/tablet to ensure consistency
  const ua = navigator.userAgent || '';
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  if (isMobile) {
    // Mobile (≤700px): 14px for all devices, 16px for iOS
    const fontSize = isIOS ? '16px' : '14px';
    filterDropdowns.forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        select.style.fontSize = fontSize;
        select.style.setProperty('font-size', fontSize, 'important');
      }
    });
    // Also apply to ranking dropdown
    const rankingSelect = document.getElementById('ranking');
    if (rankingSelect) {
      rankingSelect.style.fontSize = fontSize;
      rankingSelect.style.setProperty('font-size', fontSize, 'important');
    }
  } else if (isTablet) {
    // Tablet (701px-1024px): 16px for all devices
    filterDropdowns.forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        select.style.fontSize = '16px';
        select.style.setProperty('font-size', '16px', 'important');
      }
    });
  } else {
    // Remove inline font-size on desktop to let CSS handle it
    filterDropdowns.forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        select.style.fontSize = '';
      }
    });
  }
  
  // Update Type dropdown
  const typeSelect = document.getElementById('type');
  if (typeSelect) {
    const typeOption = typeSelect.querySelector('option[value=""]');
    if (typeOption) {
      typeOption.textContent = isMobile ? 'All types' : 'All college types';
    }
  }
  
  // Update Region dropdown
  const regionSelect = document.getElementById('region');
  if (regionSelect) {
    const regionOption = regionSelect.querySelector('option[value=""]');
    if (regionOption) {
      regionOption.textContent = isMobile ? 'All regions' : 'All regions';
    }
  }
  
  // Update State dropdown
  const stateSelect = document.getElementById('state');
  if (stateSelect) {
    const stateOption = stateSelect.querySelector('option[value=""]');
    if (stateOption) {
      stateOption.textContent = isMobile ? 'All states' : 'All states';
    }
  }
  
  // Update Ranking dropdown
  const rankingSelect = document.getElementById('ranking');
  if (rankingSelect) {
    const rankingOption = rankingSelect.querySelector('option[value=""]');
    if (rankingOption) {
      rankingOption.textContent = 'School Ranking | No Selection';
    }
  }
}

// Ranking dropdown (static options)
refreshDropdown('ranking', ['Top 25 national universities', 'Top 50 national universities', 'Top 10 liberal arts colleges', 'Top 20 liberal arts colleges'], 'School Ranking | No Selection');
updateDropdownPlaceholders();

// Handle ranking dropdown: show "School Ranking" in field when closed, "School Ranking | No Selection" in dropdown
const rankingSelect = document.getElementById('ranking');
if (rankingSelect) {
  // Store original option text
  const rankingOption = rankingSelect.querySelector('option[value=""]');
  if (rankingOption) {
    rankingOption.setAttribute('data-dropdown-text', 'School Ranking | No Selection');
    
    // When dropdown opens (mousedown/focus), show full text in option
    rankingSelect.addEventListener('mousedown', () => {
      if (rankingOption && rankingSelect.value === '') {
        rankingOption.textContent = rankingOption.getAttribute('data-dropdown-text');
      }
    });
    
    // When dropdown closes (blur), if no selection, show shortened text in field
    // Note: We can't change what shows in the closed field without custom select,
    // but we ensure the dropdown option has the full text
    rankingSelect.addEventListener('change', () => {
      if (rankingSelect.value === '' && rankingOption) {
        rankingOption.textContent = rankingOption.getAttribute('data-dropdown-text');
      }
    });
  }
}

// Type dropdown (initialize with common types, will be updated when CSV loads)
try {
  refreshDropdown('type', TYPE_ORDER.filter(Boolean), 'Any college type');
  // Update placeholders after initial type dropdown setup
  updateDropdownPlaceholders();
} catch (e) {
  console.error('Error initializing type dropdown:', e);
  // Fallback: ensure dropdown at least exists
  const typeSelect = document.getElementById('type');
  if (typeSelect) {
    typeSelect.innerHTML = '<option value="">All college types</option>';
  }
  updateDropdownPlaceholders();
}

// Event listeners
if (elements.geocodeBtn) {
  elements.geocodeBtn.onclick = () => {
    if (activeMode === 'nearby' && elements.address) {
      hasUsedSearchControls = true; // User actively clicked Locate button
      geocodeAddress(elements.address.value, 'nearby');
    }
  };
}

// Address autocomplete
if (elements.address) {
  elements.address.addEventListener('input', debounce((e) => {
    // Don't trigger search if we're programmatically setting the value
    if (addressAutocomplete.isSelecting) {
      return;
    }
    searchAddresses(e.target.value);
  }, 400));

  elements.address.addEventListener('keydown', handleAutocompleteKeydown);
  elements.address.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.address, true);
    showAddressRecentsIfEligible();
  });
  elements.address.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.address, false);
      closeAutocomplete();
    }, 120);
  });
}

// Event delegation as backup (items have direct handlers, but this catches edge cases)
if (elements.addressSuggestions) {
  elements.addressSuggestions.addEventListener('click', (e) => {
    const item = e.target.closest('.autocomplete-item');
    if (item) {
      if (item.dataset.recent === 'true') {
        e.preventDefault();
        e.stopPropagation();
        const decodedValue = item.dataset.value ? decodeURIComponent(item.dataset.value) : '';
        handleRecentAddressSelection(decodedValue);
        return;
      }
      if (item.classList.contains('shared-location')) {
        e.preventDefault();
        e.stopPropagation();
        const field = elements.addressSuggestions?.dataset.field || 'address';
        const description = item.dataset.description ? decodeURIComponent(item.dataset.description) : '';
        handleSharedLocationSelection(field, description);
        return;
      }
      const index = parseInt(item.dataset.index, 10);
      if (!isNaN(index) && index >= 0) {
        e.preventDefault();
        e.stopPropagation();
        selectSuggestion(index);
      }
    }
  }, true);
  elements.addressSuggestions.addEventListener('mousedown', (e) => {
    if (e.target.closest('.recent-suggestion') || e.target.closest('.shared-location')) {
      e.preventDefault();
    }
  }, true);
}

// Handle route recents in suggestion containers
[elements.routeStartSuggestions, elements.routeEndSuggestions].forEach(container => {
  if (!container) return;
  container.addEventListener('click', (e) => {
    const recentItem = e.target.closest('.recent-suggestion');
    if (recentItem) {
      e.preventDefault();
      e.stopPropagation();
      const decodedValue = recentItem.dataset.value ? decodeURIComponent(recentItem.dataset.value) : '';
      handleRecentRouteSelection(decodedValue, container.dataset.recentContext || '');
      return;
    }
    const sharedItem = e.target.closest('.shared-location');
    if (sharedItem) {
      e.preventDefault();
      e.stopPropagation();
      const description = sharedItem.dataset.description ? decodeURIComponent(sharedItem.dataset.description) : '';
      const field = container.dataset.field || '';
      handleSharedLocationSelection(field, description);
    }
  }, true);
  container.addEventListener('mousedown', (e) => {
    if (e.target.closest('.recent-suggestion') || e.target.closest('.shared-location')) {
      e.preventDefault();
    }
  }, true);
});

// Close autocomplete when clicking outside
document.addEventListener('click', (e) => {
  // Only close if click is truly outside
  if (elements.address && elements.addressSuggestions && 
      !elements.address.contains(e.target) && 
      !elements.addressSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeAutocomplete();
  }
  // Close route autocompletes
  if (elements.routeStart && elements.routeStartSuggestions && 
      !elements.routeStart.contains(e.target) && 
      !elements.routeStartSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
  }
  if (elements.routeEnd && elements.routeEndSuggestions && 
      !elements.routeEnd.contains(e.target) && 
      !elements.routeEndSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
  }
}, true);

// Route autocomplete event listeners
if (elements.routeStart) {
  elements.routeStart.addEventListener('input', debounce((e) => {
    if (routeStartAutocomplete.isSelecting) {
      return;
    }
    searchRouteAddresses(e.target.value, routeStartAutocomplete, elements.routeStart, elements.routeStartSuggestions);
  }, 400));
  elements.routeStart.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.routeStart, true);
    showRouteRecentsIfEligible(elements.routeStart, elements.routeStartSuggestions, routeStartAutocomplete, RECENT_STORAGE_KEYS.routeStart, 'routeStart');
  });
  elements.routeStart.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.routeStart, false);
      if (elements.routeStartSuggestions) {
        closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
      }
    }, 120);
  });
}

if (elements.routeEnd) {
  elements.routeEnd.addEventListener('input', debounce((e) => {
    if (routeEndAutocomplete.isSelecting) {
      return;
    }
    searchRouteAddresses(e.target.value, routeEndAutocomplete, elements.routeEnd, elements.routeEndSuggestions);
  }, 400));
  elements.routeEnd.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.routeEnd, true);
    showRouteRecentsIfEligible(elements.routeEnd, elements.routeEndSuggestions, routeEndAutocomplete, RECENT_STORAGE_KEYS.routeEnd, 'routeEnd');
  });
  elements.routeEnd.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.routeEnd, false);
      if (elements.routeEndSuggestions) {
        closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
      }
    }, 120);
  });
}

// Route search button
if (elements.findRouteBtn) {
  elements.findRouteBtn.onclick = async () => {
    // If addresses are entered but not geocoded yet, geocode them first
    if (elements.routeStart && elements.routeStart.value && !route.start) {
      const startAddress = elements.routeStart.value;
      const startResult = await geocodeAddress(startAddress, 'route');
      if (startResult) {
        route.start = { description: startAddress, lat: startResult.lat, lon: startResult.lon };
        saveRecent(RECENT_STORAGE_KEYS.routeStart, startAddress);
      }
    }
    
    if (elements.routeEnd && elements.routeEnd.value && !route.end) {
      const endAddress = elements.routeEnd.value;
      const endResult = await geocodeAddress(endAddress, 'route');
      if (endResult) {
        route.end = { description: endAddress, lat: endResult.lat, lon: endResult.lon };
        saveRecent(RECENT_STORAGE_KEYS.routeEnd, endAddress);
      }
    }
    
    hasUsedSearchControls = true; // User actively clicked Find Route button
    // Now call the route search function
    findCollegesAlongRoute();
  };
}

// Route clear button
if (elements.clearRoute) {
  elements.clearRoute.onclick = () => {
    if (elements.routeStart) elements.routeStart.value = '';
    if (elements.routeEnd) elements.routeEnd.value = '';
    if (elements.routeMaxDistance) elements.routeMaxDistance.value = '30';
    if (elements.routeUnits) elements.routeUnits.value = 'mi';
    route.start = null;
    route.end = null;
    route.lastSearch = null;
     route.lastResult = null;
    routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
    if (elements.routeStartSuggestions && elements.routeStart) {
      closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
    }
    if (elements.routeEndSuggestions && elements.routeEnd) {
      closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
    }
    // Hide route planning icon when route is cleared
    updateNavigationIconVisibility();
    // When clearing route, show colleges based on current filter settings
    if (activeMode === 'route') {
      // Clear route visualization
      routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
      // Show all colleges filtered by type, region, state, and search
      markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      
      // Apply filters from dropdowns
      const stateVal = elements.state ? elements.state.value : '';
      const regionVal = elements.region ? elements.region.value : '';
      const typeVal = elements.type ? elements.type.value : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      
      let filtered = colleges.filter(c => {
        // Region filter
        const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
        if (!regionMatch) return false;
        
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        
        // Type filter
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        return true;
      });
      
      // Calculate bounds for map focus (same logic as nearby mode)
      const routeFilterBounds = filtered.length > 1 ? L.latLngBounds([]) : null;
      const isDefaultRouteState = !regionVal && !stateVal && !typeVal && !searchVal;
      const isSearchOnlyFilter = !!searchVal && !regionVal && !stateVal && !typeVal;
      
      // Render filtered colleges
      filtered.forEach(c => {
        try {
          if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
            return;
          }
          
          const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
          const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
          
          const saveButtonHtml = c.college_id ? `
            <div class="popup-save-row">
              <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
                <span class="popup-save-icon" aria-hidden="true">☆</span>
                <span class="popup-save-label">Save</span>
              </button>
            </div>` : '';

          const popupContent = `
            <div style="font-size:12px;line-height:1.4">
              <b>${c.name}</b><br>
              ${c.state} · ${(c.type||'Unknown')}<br>
              ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
              Enrollment: ${c.enrollment || 'N/A'}<br>
              Tuition: ${tuition}<br>
              ${c.url ? `For official, up-to-date info:<br><a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
              ${saveButtonHtml}
            </div>`;
          
          const marker = createCollegeMarker(c, popupContent, c.college_id);
          marker.addTo(markersLayer);
          if (routeFilterBounds) {
            routeFilterBounds.extend(marker.getLatLng());
          }
        } catch (e) {
          console.error(`Error creating marker for ${c.name}:`, e);
        }
      });
      
      if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
      
      // Update map hints after clearing route
      updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
      
      // Map focus logic (same as nearby mode when route is cleared)
      // Special handling for Territories region - zoom out to show global view
      if (regionVal === 'Territories') {
        if (filtered.length === 0) {
          // No results, show global view that includes all US territories
          map.setView([10, -170], 2);
        } else if (filtered.length === 1) {
          // Single college, zoom to it
          map.setView([filtered[0].lat, filtered[0].lon], 8);
        } else if (routeFilterBounds && routeFilterBounds.isValid()) {
          // Multiple colleges - fit bounds with padding, no mainland constraint
          const paddedBounds = routeFilterBounds.pad(0.2);
          map.fitBounds(paddedBounds);
        } else {
          // Fallback: global view centered on Pacific
          map.setView([10, -170], 2);
        }
      } else if (isDefaultRouteState || isSearchOnlyFilter) {
        // When no filters are active, restore to default US view
        const defaultView = getInitialNearbyView();
        map.setView([defaultView.center.lat, defaultView.center.lng], defaultView.zoom);
        // Update mapViewState to reflect the default view
        mapViewState.nearby = { ...defaultView };
        captureMapView('nearby');
      } else if (filtered.length === 0) {
        // No results - restore default US view
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      } else if (filtered.length === 1) {
        // Single college - zoom to it
        map.setView([filtered[0].lat, filtered[0].lon], 8);
      } else if (routeFilterBounds && routeFilterBounds.isValid()) {
        // Multiple colleges - fit bounds with padding and mainland constraint
        const paddedBounds = routeFilterBounds.pad(0.15);
        let constrainedBounds = paddedBounds;
        if (stateVal) {
          // Check if all filtered colleges are in the same state, and if that state is outside mainland
          const allSameState = filtered.every(c => c.state === stateVal);
          if (allSameState) {
            // Check if this state's colleges are outside mainland bounds
            const boundsSouth = routeFilterBounds.getSouth();
            const boundsWest = routeFilterBounds.getWest();
            const boundsNorth = routeFilterBounds.getNorth();
            const boundsEast = routeFilterBounds.getEast();
            const isOutsideMainland = 
              boundsSouth < US_MAINLAND_VIEW.getSouth() ||
              boundsWest < US_MAINLAND_VIEW.getWest() ||
              boundsNorth > US_MAINLAND_VIEW.getNorth() ||
              boundsEast > US_MAINLAND_VIEW.getEast();
            // If explicitly selected state is outside mainland, don't clamp
            if (isOutsideMainland) {
              constrainedBounds = paddedBounds;
            } else {
              constrainedBounds = clampBoundsToMainland(paddedBounds);
            }
          } else {
            // Mixed states - apply clamping
            constrainedBounds = clampBoundsToMainland(paddedBounds);
          }
        } else {
          // No state filter - apply clamping to prevent showing empty ocean
          constrainedBounds = clampBoundsToMainland(paddedBounds);
        }
        map.fitBounds(constrainedBounds);
      } else {
        // Fallback: restore default US view
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    }
    // Update navigation icon visibility after clearing route
    updateNavigationIconVisibility();
  };
}

if (elements.clearRadius) {
  elements.clearRadius.onclick = () => {
    if (elements.radius) elements.radius.value = '30';
    if (elements.address) elements.address.value = '';
    // Clear both desktop and mobile search fields
    if (elements.search) elements.search.value = '';
    const mobileSearch = document.getElementById('search-mobile');
    if (mobileSearch) mobileSearch.value = '';
    // Clear ranking filter
    if (elements.ranking) elements.ranking.value = '';
    home = null;
    homeLayer.clearLayers();
    radiusLayer.clearLayers();
    closeAutocomplete();
    map.setView([39.5, -98.35], 4);
    render();
  };
}

// Accordion behavior for filter sections - when one opens, close the other
const filterSections = document.querySelectorAll('.filter-section');
if (filterSections.length) {
  const isMobileViewport = window.innerWidth <= 700;
  if (!isMobileViewport) {
    filterSections[0].setAttribute('open', '');
  } else {
    filterSections[0].removeAttribute('open');
  }
}
filterSections.forEach(section => {
  section.addEventListener('toggle', (e) => {
    // Remove active class from all sections first
    filterSections.forEach(s => s.classList.remove('active'));
    
    // Find the currently open section and mark it as active
    const openSection = Array.from(filterSections).find(s => s.open);
    if (openSection) {
      openSection.classList.add('active');
    }
    
    // Check if route section is closing
    const summary = section.querySelector('summary');
    const isRouteSection = summary && summary.textContent.trim().includes('Find Colleges Along a Route');
    if (isRouteSection && !section.open) {
      // Route section is closing - hide route planning icon
      updateNavigationIconVisibility();
    }
    
    // Only act if this section is now open (was just opened)
    if (section.open) {
      // Determine which section opened
      const summary = section.querySelector('summary');
      const isNearby = summary && summary.textContent.trim().includes('Find Colleges Nearby');
      const isRoute = summary && summary.textContent.trim().includes('Find Colleges Along a Route');
      
      // Set active mode
      if (isNearby) {
        activeMode = 'nearby';
        // Clear route visualization when switching to nearby mode
        routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
        // Hide route planning icon when switching away from route mode
        updateNavigationIconVisibility();
        // Restore nearby state if available
        if (nearbyState.home) {
          home = nearbyState.home;
          if (elements.address && nearbyState.address) {
            elements.address.value = nearbyState.address;
          }
          if (elements.radius && nearbyState.radius) {
            elements.radius.value = nearbyState.radius;
          }
          if (elements.units && nearbyState.units) {
            elements.units.value = nearbyState.units;
          }
          // Re-apply the search and recreate the pin marker
          if (home) {
            // Clear and recreate the pin marker
        homeLayer.clearLayers();
            radiusLayer.clearLayers();
            
            // Recreate "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([home.lat, home.lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
            
            render();
          }
        } else {
          // If no nearby state, rely on render to determine framing
          render();
        }
      } else if (isRoute) {
        activeMode = 'route';
        // Clear nearby visualization when switching to route mode
        homeLayer.clearLayers();
        radiusLayer.clearLayers();
        // Restore route state if available
        if (route.lastSearch && route.start && route.end) {
          // Restore input values
          if (elements.routeStart && route.start.description) {
            elements.routeStart.value = route.start.description;
          }
          if (elements.routeEnd && route.end.description) {
            elements.routeEnd.value = route.end.description;
          }
          if (elements.routeMaxDistance && route.lastSearch.maxDistance) {
            elements.routeMaxDistance.value = route.lastSearch.maxDistance;
          }
          if (elements.routeUnits && route.lastSearch.units) {
            elements.routeUnits.value = route.lastSearch.units;
          }
          const currentFilters = getRouteFilterSignature();
          if (route.lastResult && isRouteCacheValid(route.lastResult, currentFilters, route.start, route.end)) {
            restoreRouteFromCache(route.lastResult, { preserveView: true });
            if (!applySavedMapView('route')) {
              if (route.lastResult.bounds && route.lastResult.bounds.isValid()) {
                map.fitBounds(route.lastResult.bounds.pad(0.15));
              } else if (route.lastResult.routeCoords && route.lastResult.routeCoords.length) {
                map.fitBounds(L.latLngBounds(route.lastResult.routeCoords), { padding: [50, 50] });
              }
            }
          } else {
            // Redraw the route
            findCollegesAlongRoute();
          }
          // Update navigation icon visibility when route is restored
          updateNavigationIconVisibility();
        } else {
          // If no route state, show colleges based on current filters (type, region, state, search)
          // Clear only route visualization layers, keep markers showing filtered colleges
          routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
          render();
          // Update navigation icon visibility when switching to route mode
          updateNavigationIconVisibility();
        }
      }
      
      // This section just opened, close all other sections
      filterSections.forEach(otherSection => {
        if (otherSection !== section && otherSection.open) {
          otherSection.open = false;
      }
    });
}
  });
});

// Set initial active state for the default open section
const openSection = document.querySelector('.filter-section[open]');
if (openSection) {
  openSection.classList.add('active');
}

// Store the last user-selected state value to prevent autofill from changing it
let lastUserSelectedState = '';
let isUserChangingState = false;
let autofillWatchInterval = null;
let stateProtectionActive = true; // Always active by default

// Strong protection function to restore state value
function protectStateValue() {
  if (!elements.state || isUserChangingState) {
    return;
  }
  if (elements.state.value !== lastUserSelectedState) {
    // Autofill tried to change it - restore immediately
    elements.state.value = lastUserSelectedState;
    // Force a reflow to ensure the change is applied
    void elements.state.offsetHeight;
  }
}

// Prevent autofill from changing the state dropdown
if (elements.state) {
  // Store initial value
  lastUserSelectedState = elements.state.value;
  
  // Track when any address field is being filled (autofill detection)
  const addressFields = [elements.address, elements.routeStart, elements.routeEnd].filter(Boolean);
  
  addressFields.forEach(addressField => {
    // Store state value before address field changes
    addressField.addEventListener('focus', () => {
      lastUserSelectedState = elements.state.value;
      stateProtectionActive = true;
      // Start watching for autofill changes to state dropdown - more frequent checks
      if (autofillWatchInterval) {
        clearInterval(autofillWatchInterval);
      }
      autofillWatchInterval = setInterval(() => {
        protectStateValue();
      }, 25); // Check every 25ms during autofill window (more frequent)
    });
    
    // Handle browser autofill event (some browsers fire this)
    addressField.addEventListener('change', () => {
      protectStateValue();
    });
    
    // Handle input event (autofill can trigger this)
    addressField.addEventListener('input', () => {
      protectStateValue();
    });
    
    // Stop watching when address field loses focus, but keep protection active longer
    addressField.addEventListener('blur', () => {
      // Keep protection active for a bit longer in case autofill happens after blur
      setTimeout(() => {
        if (autofillWatchInterval) {
          clearInterval(autofillWatchInterval);
          autofillWatchInterval = null;
        }
        // Final check and restore if needed
        protectStateValue();
        // Keep protection active for 3 more seconds after blur
        setTimeout(() => {
          // Protection stays active, just stop the interval
        }, 3000);
      }, 200);
    });
  });
  
  // Continuous protection - always watch for unauthorized changes
  setInterval(() => {
    if (stateProtectionActive && !isUserChangingState) {
      protectStateValue();
    }
  }, 100); // Check every 100ms continuously
  
  // Listen for user-initiated changes to state dropdown
  elements.state.addEventListener('mousedown', () => {
    isUserChangingState = true;
    lastUserSelectedState = elements.state.value;
  });
  
  elements.state.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter' || e.key === ' ') {
      isUserChangingState = true;
      lastUserSelectedState = elements.state.value;
    }
  });
  
  elements.state.addEventListener('change', function(e) {
    const currentValue = e.target.value;
    
    // If this change was initiated by user, update stored value
    if (isUserChangingState) {
      lastUserSelectedState = currentValue;
      isUserChangingState = false;
      
      // Track state filter usage
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_filter_state_used');
      }
      
      // Update filter chips
      updateFilterChips();
      
      // Continue with normal change handling
      if (activeMode === 'route' && route.lastSearch) {
        // Re-run route search with updated filters
        findCollegesAlongRoute();
      } else {
        render();
      }
      
      // Check if saved-only mode should be turned OFF after filter change
      checkAndHandleNoVisibleSavedColleges();
    } else {
      // This change was NOT from user - likely autofill - restore previous value
      elements.state.value = lastUserSelectedState;
      // Don't trigger render since this wasn't a real change
      return; // Prevent further processing of this change
    }
  });
  
  // Reset flag after a short delay (only if change event didn't fire)
  elements.state.addEventListener('blur', () => {
    setTimeout(() => {
      // Only reset if change event hasn't already processed it
      // Check if value changed - if it did, change event should have handled it
      if (elements.state.value === lastUserSelectedState) {
        // Value didn't change, so user didn't select anything - safe to reset
        isUserChangingState = false;
      }
    }, 200);
  });
}

// Update mobile pill text format - labels are hidden on mobile, so this function is not needed
function updateMobilePillText() {
  // Labels are hidden on mobile (≤700px), so no text update needed
  // The select dropdown itself will show the selected value or placeholder
  return;
}

['region', 'type', 'ranking', 'radius', 'units'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    // Track filter usage
    if (typeof gtag !== 'undefined') {
      if (id === 'type') {
        gtag('event', 'feature_filter_type_used');
      } else if (id === 'region') {
        gtag('event', 'feature_filter_region_used');
      } else if (id === 'ranking') {
        gtag('event', 'feature_filter_ranking_used');
      }
    }
    
    // Update mobile pill text
    updateMobilePillText();
    
    // Update filter chips
    updateFilterChips();
    
    if (activeMode === 'route' && route.lastSearch) {
      // Re-run route search with updated filters
      findCollegesAlongRoute();
    } else {
      render();
    }
    
    // Check if saved-only mode should be turned OFF after filter change
    checkAndHandleNoVisibleSavedColleges();
  });
});

// Function to shorten filter values for display in chips
function shortenFilterValue(value, filterType) {
  const shortenMap = {
    'type': {
      'Elite Private Universities': 'Elite Pri',
      'Public Flagship Universities': 'Pub Flagship',
      'Private Liberal Arts Colleges': 'Liberal Arts',
      'STEM / Technology Institutes': 'STEM / Tech',
      'Business / Arts / Specialty Schools': 'Biz/ Arts/Spec',
      'Health & Medical Colleges': 'Health/Med',
      'Public Regional Universities': 'Pub Reg',
      'Community Colleges': 'Community Coll',
      'Online / For-Profit': 'Online/FP'
    },
    'ranking': {
      'Top 25 national universities': 'Top25Nat',
      'Top 50 national universities': 'Top50 Nat',
      'Top 10 liberal arts colleges': 'Top10LAC',
      'Top 20 liberal arts colleges': 'Top20LAC'
    }
  };
  
  if (shortenMap[filterType] && shortenMap[filterType][value]) {
    return shortenMap[filterType][value];
  }
  return value;
}

// Function to update filter chips
function updateFilterChips() {
  const chipsContainer = document.getElementById('filter-chips');
  if (!chipsContainer) return;
  
  // Use event delegation for close buttons and clear all (handles both new and existing chips)
  if (!chipsContainer.dataset.delegationSetup) {
    chipsContainer.addEventListener('click', (e) => {
      if (e.target.classList.contains('filter-chip-close')) {
        e.stopPropagation();
        const chip = e.target.closest('.filter-chip');
        const filterType = e.target.dataset.filterType || chip?.dataset.filterType;
        if (chip && filterType) {
          chip.classList.add('slide-out');
          setTimeout(() => {
            clearFilter(filterType);
          }, 300);
        }
      } else {
        const clearAllTarget = e.target.closest('.filter-chip-clear-all');
        if (clearAllTarget) {
          e.stopPropagation();
          clearAllFilters();
        }
      }
    });
    chipsContainer.dataset.delegationSetup = 'true';
  }
  
  // Get current filter values
  const typeSelect = document.getElementById('type');
  const regionSelect = document.getElementById('region');
  const stateSelect = document.getElementById('state');
  const rankingSelect = document.getElementById('ranking');
  
  const chips = [];
  
  // Type filter
  if (typeSelect && typeSelect.value && typeSelect.value !== '') {
    const typeValue = typeSelect.options[typeSelect.selectedIndex]?.textContent || typeSelect.value;
    const shortened = shortenFilterValue(typeValue, 'type');
    chips.push({ type: 'type', label: shortened, value: typeSelect.value });
  }
  
  // Region filter
  if (regionSelect && regionSelect.value && regionSelect.value !== '') {
    const regionValue = regionSelect.options[regionSelect.selectedIndex]?.textContent || regionSelect.value;
    chips.push({ type: 'region', label: regionValue, value: regionSelect.value });
  }
  
  // State filter
  if (stateSelect && stateSelect.value && stateSelect.value !== '') {
    const stateValue = stateSelect.options[stateSelect.selectedIndex]?.textContent || stateSelect.value;
    chips.push({ type: 'state', label: stateValue, value: stateSelect.value });
  }
  
  // Ranking filter
  if (rankingSelect && rankingSelect.value && rankingSelect.value !== '') {
    const rankingValue = rankingSelect.options[rankingSelect.selectedIndex]?.textContent || rankingSelect.value;
    const shortened = shortenFilterValue(rankingValue, 'ranking');
    chips.push({ type: 'ranking', label: shortened, value: rankingSelect.value });
  }
  
  // Track existing chips to preserve animations
  const existingChips = Array.from(chipsContainer.children);
  const existingChipTypes = new Set(existingChips.map(chip => chip.dataset.filterType));
  const newChipTypes = new Set(chips.map(chip => chip.type));
  
  // Remove chips that are no longer needed (with slide-out animation)
  // Exclude "Clear All" pill from this logic - it's handled separately below
  existingChips.forEach(existingChip => {
    // Skip the "Clear All" pill - it doesn't have dataset.filterType
    if (existingChip.classList.contains('filter-chip-clear-all')) {
      return;
    }
    const chipType = existingChip.dataset.filterType;
    if (!newChipTypes.has(chipType)) {
      // Chip should be removed - animate out first
      existingChip.classList.add('slide-out');
      setTimeout(() => {
        if (existingChip.parentNode) {
          existingChip.remove();
        }
      }, 300); // Match animation duration
    }
  });
  
  // Add new chips (with slide-in animation)
  chips.forEach(chip => {
    // Check if chip already exists
    const existingChip = Array.from(chipsContainer.children).find(
      el => el.dataset.filterType === chip.type
    );
    
    if (!existingChip) {
      // New chip - create and animate in
      const chipElement = document.createElement('div');
      chipElement.className = 'filter-chip';
      chipElement.dataset.filterType = chip.type;
      chipElement.innerHTML = `
        <span class="filter-chip-label">${chip.label}</span>
        <button class="filter-chip-close" data-filter-type="${chip.type}" aria-label="Clear ${chip.type} filter" type="button">×</button>
      `;
      
      // Event delegation handles the close button click (set up above)
      chipsContainer.appendChild(chipElement);
    } else {
      // Update existing chip label if it changed
      const labelEl = existingChip.querySelector('.filter-chip-label');
      if (labelEl && labelEl.textContent !== chip.label) {
        labelEl.textContent = chip.label;
      }
      
      // Ensure existing chip doesn't have slide-out class (in case it was being removed)
      existingChip.classList.remove('slide-out');
    }
  });
  
  // Add or update "Clear All" pill when 2+ filters are active
  // Always ensure it's at the bottom of all chips
  // Don't remove/re-add it when filters change - just keep it visible and move it
  const activeFilterCount = chips.length;
  const existingClearAll = chipsContainer.querySelector('.filter-chip-clear-all');
  
  if (activeFilterCount >= 2) {
    // Show or update "Clear All" pill - keep it visible, just ensure it's at bottom
    if (!existingClearAll) {
      const clearAllElement = document.createElement('div');
      clearAllElement.className = 'filter-chip-clear-all filter-chip-new';
      clearAllElement.innerHTML = '<span>Clear all</span><span class="filter-chip-clear-all-icon">↺</span>';
      clearAllElement.setAttribute('role', 'button');
      clearAllElement.setAttribute('tabindex', '0');
      clearAllElement.setAttribute('aria-label', 'Clear all filters');
      // Event delegation handles the click (set up above)
      // Always append to end to ensure it's at the bottom
      chipsContainer.appendChild(clearAllElement);
      // Remove the animation class after animation completes
      setTimeout(() => {
        clearAllElement.classList.remove('filter-chip-new');
      }, 300);
    } else {
      // Pill already exists - just ensure it's at the bottom and visible
      // Remove any slide-out or animation classes
      existingClearAll.classList.remove('slide-out', 'filter-chip-new');
      // Move to bottom if it's not already there (this will smoothly move it down)
      // Only move if it's not already the last child to avoid unnecessary DOM manipulation
      if (existingClearAll.nextSibling || existingClearAll !== chipsContainer.lastElementChild) {
        chipsContainer.appendChild(existingClearAll);
      }
    }
  } else {
    // Only remove "Clear All" pill when there are less than 2 filters
    if (existingClearAll) {
      existingClearAll.classList.add('slide-out');
      setTimeout(() => {
        if (existingClearAll.parentNode) {
          existingClearAll.remove();
        }
      }, 300); // Match animation duration
    }
  }
}

// Function to clear all filters
function clearAllFilters() {
  const filterTypes = ['type', 'region', 'state', 'ranking'];
  
  // Clear each filter
  filterTypes.forEach(filterType => {
    const select = document.getElementById(filterType);
    if (select) {
      // Special handling for state filter due to autofill protection
      if (filterType === 'state' && elements.state) {
        // Temporarily disable autofill protection
        const wasProtectionActive = stateProtectionActive;
        stateProtectionActive = false;
        
        // Mark as user-initiated change to bypass autofill protection
        isUserChangingState = true;
        lastUserSelectedState = '';
        elements.state.value = '';
        
        // Trigger change event to update map
        const changeEvent = new Event('change', { bubbles: true });
        elements.state.dispatchEvent(changeEvent);
        
        // Reset flags after a short delay to allow change handler to process
        setTimeout(() => {
          isUserChangingState = false;
          stateProtectionActive = wasProtectionActive;
        }, 100);
      } else {
        // For other filters, just clear and trigger change
        select.value = '';
        const changeEvent = new Event('change', { bubbles: true });
        select.dispatchEvent(changeEvent);
      }
    }
  });
  
  // Update filter chips after all filters are cleared
  updateFilterChips();
  
  // Trigger render to update map
  if (activeMode === 'route' && route.lastSearch) {
    findCollegesAlongRoute();
  } else {
    render();
  }
}

// Function to clear a specific filter
function clearFilter(filterType) {
  const select = document.getElementById(filterType);
  if (select) {
    // Special handling for state filter due to autofill protection
    if (filterType === 'state' && elements.state) {
      // Temporarily disable autofill protection
      const wasProtectionActive = stateProtectionActive;
      stateProtectionActive = false;
      
      // Mark as user-initiated change to bypass autofill protection
      isUserChangingState = true;
      lastUserSelectedState = '';
      elements.state.value = '';
      
      // Update filter chips immediately
      updateFilterChips();
      
      // Trigger change event to update map
      const changeEvent = new Event('change', { bubbles: true });
      elements.state.dispatchEvent(changeEvent);
      
      // Reset flags after a short delay to allow change handler to process
      setTimeout(() => {
        isUserChangingState = false;
        stateProtectionActive = wasProtectionActive;
      }, 100);
    } else {
      // For other filters, just clear and trigger change
      select.value = '';
      
      // Update filter chips immediately
      updateFilterChips();
      
      // Trigger change event to update map
      const changeEvent = new Event('change', { bubbles: true });
      select.dispatchEvent(changeEvent);
    }
  }
}

// Function to move ranking between row-filters and row-ranking based on screen size
function positionRankingDropdown() {
  // Try to find ranking pill in either location
  let rankingPill = document.querySelector('.row-filters .pill-ranking');
  if (!rankingPill) {
    rankingPill = document.querySelector('.row-ranking .pill-ranking');
  }
  const rowRanking = document.querySelector('.row-ranking');
  const rowFilters = document.querySelector('.row-filters');
  
  if (!rankingPill || !rowRanking || !rowFilters) {
    // If elements don't exist yet, try again after a short delay
    if (document.readyState === 'loading') {
      setTimeout(positionRankingDropdown, 100);
    }
    return;
  }
  
  const isMobile = window.innerWidth <= 700;
  
  if (isMobile) {
    // Move ranking to row-ranking on mobile
    // First ensure row-ranking is visible
    rowRanking.style.display = 'flex';
    rowRanking.style.setProperty('display', 'flex', 'important');
    
    if (rankingPill.parentElement !== rowRanking) {
      // Remove display:none before moving
      rankingPill.style.display = '';
      rankingPill.style.removeProperty('display');
      rowRanking.appendChild(rankingPill);
    }
    
    // Ensure it's visible after moving
    rankingPill.style.display = 'flex';
    rankingPill.style.setProperty('display', 'flex', 'important');
  } else {
    // Move ranking back to row-filters on desktop/tablet
    if (rankingPill.parentElement !== rowFilters) {
      // Insert after state pill
      const statePill = document.querySelector('.row-filters .pill:has(#state)');
      if (statePill && statePill.nextSibling) {
        rowFilters.insertBefore(rankingPill, statePill.nextSibling);
      } else {
        rowFilters.appendChild(rankingPill);
      }
    }
  }
}

// Update mobile pill text and dropdown placeholders on initial load and window resize
updateDropdownPlaceholders();
positionRankingDropdown();
updateFilterChips();
if (window.innerWidth <= 700) {
  updateMobilePillText();
}
window.addEventListener('resize', () => {
  // Update dropdown placeholder text based on screen size
  updateDropdownPlaceholders();
  
  // Reposition ranking dropdown based on screen size
  positionRankingDropdown();
  
  if (window.innerWidth <= 700) {
    updateMobilePillText();
  } else {
    // Reset to default on desktop
    ['type', 'region', 'state', 'ranking'].forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        const labelEl = select.closest('.pill')?.querySelector('label');
        if (labelEl) {
          const labels = { type: 'Type', region: 'Region', state: 'State', ranking: 'Ranking' };
          labelEl.textContent = labels[id];
        }
      }
    });
  }
});

// Debounced search input - use event delegation to handle both desktop and mobile search fields
// Performance: Debounced to 300ms to avoid heavy re-renders on every keystroke
// Dropdown changes (Type, Region, State) are NOT debounced - they update immediately for better UX
document.querySelector('.controls').addEventListener('input', debounce((e) => {
  if (e.target.id === 'search' || e.target.id === 'search-mobile') {
    // Sync values between both search fields if they exist
    // Respect activeMode - only render in nearby mode, or re-run route search in route mode
    if (activeMode === 'route' && route.lastSearch) {
      findCollegesAlongRoute();
      return;
    }
    const desktopSearch = document.getElementById('search');
    const mobileSearch = document.getElementById('search-mobile');
    if (e.target.id === 'search' && mobileSearch) {
      mobileSearch.value = e.target.value;
    } else if (e.target.id === 'search-mobile' && desktopSearch) {
      desktopSearch.value = e.target.value;
    }
    render();
    
    // Check if saved-only mode should be turned OFF after filter change
    checkAndHandleNoVisibleSavedColleges();
  }
}, 300));

// Check if running from file:// protocol (won't work due to CORS)
if (window.location.protocol === 'file:') {
  showError('Please use a web server to test this page. CSV files cannot load from file:// protocol. Use: python3 -m http.server 8000');
  console.error('Cannot load CSV from file:// protocol due to CORS restrictions');
} else {
loadCSV(DATA_URL);
}
</script>

<!-- Feedback Widget -->
<div class="feedback-button" id="feedbackButton">Feedback</div>
<div class="feedback-popup" id="feedbackPopup">
  <div class="feedback-popup-header">
    <div></div>
    <button class="feedback-popup-close" id="feedbackClose" aria-label="Close">×</button>
  </div>
  <div class="feedback-popup-message">We're improving U.S. College Map. Got 30 seconds to tell us what to fix next?</div>
  <div class="feedback-popup-button-wrapper">
    <a href="https://forms.gle/tGNzJr9THUYKfUPZ8" target="_blank" rel="noopener noreferrer" class="feedback-popup-button" style="text-decoration:none">Open feedback form</a>
  </div>
  <a href="#" class="feedback-popup-dismiss" id="feedbackDismiss">Don't show again</a>
</div>

<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E2KP0JHTMC"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-E2KP0JHTMC');
</script>

<script>
// Feedback Widget
(function() {
  'use strict';
  
  const feedbackButton = document.getElementById('feedbackButton');
  const feedbackPopup = document.getElementById('feedbackPopup');
  
  // Check if user has dismissed the feedback widget
  if (localStorage.getItem('uscm_feedback_dismissed') === 'true') {
    if (feedbackButton) feedbackButton.style.display = 'none';
    if (feedbackPopup) feedbackPopup.style.display = 'none';
    return; // Don't set up event listeners
  }
  
  const feedbackClose = document.getElementById('feedbackClose');
  const feedbackDismiss = document.getElementById('feedbackDismiss');
  
  // Open popup
  feedbackButton.addEventListener('click', function(e) {
    e.stopPropagation();
    feedbackPopup.classList.add('active');
  });
  
  // Close popup
  feedbackClose.addEventListener('click', function() {
    feedbackPopup.classList.remove('active');
  });
  
  // Dismiss permanently
  feedbackDismiss.addEventListener('click', function(e) {
    e.preventDefault();
    localStorage.setItem('uscm_feedback_dismissed', 'true');
    feedbackButton.classList.add('hidden');
    feedbackPopup.classList.remove('active');
  });
  
  // Close popup when clicking outside
  document.addEventListener('click', function(e) {
    if (feedbackPopup.classList.contains('active') && 
        !feedbackPopup.contains(e.target) && 
        !feedbackButton.contains(e.target)) {
      feedbackPopup.classList.remove('active');
    }
  });
})();

// Ranking info tooltip functionality
(function() {
  const rankingInfoBtn = document.getElementById('ranking-info-btn');
  const rankingTooltip = document.getElementById('ranking-tooltip');
  const rankingTooltipClose = document.getElementById('ranking-tooltip-close');
  
  if (rankingInfoBtn && rankingTooltip) {
    let isTooltipOpen = false;
    
    function toggleTooltip(e) {
      e.stopPropagation();
      isTooltipOpen = !isTooltipOpen;
      if (isTooltipOpen) {
        rankingTooltip.classList.add('active');
      } else {
        rankingTooltip.classList.remove('active');
      }
    }
    
    function closeTooltip(e) {
      if (e) e.stopPropagation();
      isTooltipOpen = false;
      rankingTooltip.classList.remove('active');
    }
    
    // Close button functionality
    if (rankingTooltipClose) {
      rankingTooltipClose.addEventListener('click', closeTooltip);
    }
    
    // Desktop: hover and click
    rankingInfoBtn.addEventListener('mouseenter', () => {
      if (!isTooltipOpen) {
        rankingTooltip.classList.add('active');
      }
    });
    
    rankingInfoBtn.addEventListener('mouseleave', () => {
      if (!isTooltipOpen) {
        rankingTooltip.classList.remove('active');
      }
    });
    
    rankingInfoBtn.addEventListener('click', toggleTooltip);
    
    // Close on click outside
    document.addEventListener('click', function(e) {
      if (isTooltipOpen && 
          !rankingTooltip.contains(e.target) && 
          !rankingInfoBtn.contains(e.target)) {
        closeTooltip();
      }
    });
    
    // Mobile: tap to toggle
    rankingInfoBtn.addEventListener('touchend', function(e) {
      e.preventDefault();
      toggleTooltip(e);
    });
  }
})();

// Show "NEW!" chat bubble for ranking filter for return users who haven't seen it
(function() {
  const RANKING_NEW_BUBBLE_KEY = 'ucm_rankingNewBubbleSeen';
  
  function showRankingNewBubble() {
    // Check if user has seen it before
    const hasSeen = localStorage.getItem(RANKING_NEW_BUBBLE_KEY) === '1';
    if (hasSeen) {
      return; // Don't show if already seen
    }
    
    // Find the ranking pill and chat bubble
    const rankingPill = document.querySelector('.pill-ranking');
    const chatBubble = document.getElementById('ranking-new-chat-bubble');
    
    if (!rankingPill || !chatBubble) {
      // Retry after a short delay if elements aren't ready
      setTimeout(showRankingNewBubble, 200);
      return;
    }
    
    // Position the bubble above the ranking dropdown using fixed positioning
    // On desktop/tablet, the label is hidden, so use the select element
    const rankingSelect = rankingPill.querySelector('select#ranking');
    const label = rankingPill.querySelector('label[for="ranking"]');
    
    let targetElement = label;
    // Check if label is visible (not display:none)
    if (!label || label.offsetParent === null) {
      // Label is hidden, use select element instead
      targetElement = rankingSelect;
    }
    
    if (targetElement) {
      const rect = targetElement.getBoundingClientRect();
      // Use viewport coordinates for fixed positioning
      chatBubble.style.left = rect.left + 'px';
      chatBubble.style.top = (rect.top - 28) + 'px'; // 28px above the element
    } else {
      // Final fallback: position relative to the pill
      const pillRect = rankingPill.getBoundingClientRect();
      chatBubble.style.left = pillRect.left + 'px';
      chatBubble.style.top = (pillRect.top - 28) + 'px';
    }
    
    // Ensure bubble is visible and log for debugging
    chatBubble.style.display = 'block';
    chatBubble.style.visibility = 'visible';
    console.log('Ranking bubble positioned:', {
      left: chatBubble.style.left,
      top: chatBubble.style.top,
      visible: chatBubble.classList.contains('visible'),
      computedDisplay: window.getComputedStyle(chatBubble).display,
      computedZIndex: window.getComputedStyle(chatBubble).zIndex
    });
    
    // Show the bubble
    chatBubble.classList.add('visible');
    
    // Hide after 5 seconds
    setTimeout(() => {
      chatBubble.classList.remove('visible');
      // Mark as seen
      localStorage.setItem(RANKING_NEW_BUBBLE_KEY, '1');
    }, 5000);
  }
  
  // Show bubble after page loads and ranking dropdown is positioned
  function initRankingBubble() {
    // Wait for elements to be ready
    setTimeout(() => {
      const rankingPill = document.querySelector('.pill-ranking');
      if (rankingPill) {
        showRankingNewBubble();
      } else {
        // Retry if not ready yet
        setTimeout(initRankingBubble, 200);
      }
    }, 800);
  }
  
  document.addEventListener('DOMContentLoaded', initRankingBubble);
  
  // Also try after window load
  if (document.readyState === 'complete') {
    initRankingBubble();
  } else {
    window.addEventListener('load', initRankingBubble);
  }
  
  // Expose function for testing (can be called from console)
  window.testRankingBubble = function() {
    localStorage.removeItem(RANKING_NEW_BUBBLE_KEY);
    showRankingNewBubble();
  };
  
  // Expose function to check status
  window.checkRankingBubbleStatus = function() {
    const hasSeen = localStorage.getItem(RANKING_NEW_BUBBLE_KEY) === '1';
    console.log('Ranking bubble seen:', hasSeen);
    return hasSeen;
  };
})();
</script>

</body>
</html>
