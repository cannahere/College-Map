<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="google-site-verification" content="XLI_3QT03lSkcCEmteQWtQeDviYsA07lmIbGu_5GKCc" />
  <meta name="msvalidate.01" content="CA49DC12684491A5E489D6BA5BD08ED5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Branding and Icons -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="manifest" href="site.webmanifest">

  <!-- SEO Meta Tags -->
  <title>U.S. College Map | Explore Colleges by Type, Ranking & Location</title>
  <link rel="canonical" href="https://uscollegemap.org/">
  <meta name="description" content="Find colleges by type, region, or ranking. Explore schools near any location or along any route—ideal for early college research and campus visit planning.">
  <meta name="keywords" content="US college map, college map, college map usa, university map, interactive college map, colleges near me, community colleges near me, colleges by location, community colleges by location, map of colleges, college visit map, campus visit planner, college trip planner, colleges along a route, find colleges on a map, community college finder, campus visit planning, higher education USA, college rankings, university rankings, top 25 universities, top liberal arts colleges">
  <meta name="author" content="U.S. College Map">

  <!-- Open Graph (Social Media Preview) -->
  <meta property="og:title" content="U.S. College Map — Find Colleges Near You & Along Any Route">
  <meta property="og:description" content="Explore U.S. colleges on an interactive map. Find schools near you or along your route, filter by type or state, and save favorite colleges to your list for easy trip planning.">
  <meta property="og:image" content="https://uscollegemap.org/us-college-map-logo.png">
  <meta property="og:url" content="https://uscollegemap.org/">
  <meta property="og:type" content="website">
<meta property="og:site_name" content="U.S. College Map">

  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="U.S. College Map — Find Colleges Near You & Along Any Route">
  <meta name="twitter:description" content="Explore U.S. colleges on an interactive map. Find schools near you or along a route, filter by type or state, and save favorites for easy visit planning.">
  <meta name="twitter:image" content="https://uscollegemap.org/us-college-map-logo.png">

  <!-- Schema Markup (Structured Data) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "U.S. College Map",
    "url": "https://uscollegemap.org/",
    "description": "Explore U.S. colleges on an interactive map. Find schools near you or along a driving route, filter by type or state, and save favorite colleges to build your list for campus visit planning.",
    "applicationCategory": "Education",
    "operatingSystem": "All",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "creator": {
      "@type": "Organization",
      "name": "U.S. College Map"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "ratingCount": "150"
    },
    "featureList": [
      "Interactive map of all U.S. colleges",
      "Filter colleges by state, region, or school type",
      "Search by college name",
      "Find colleges near your location",
      "See colleges along any driving route",
      "Save favorite colleges to your personal list",
      "View only your saved schools on the map",
      "Plan early college visits efficiently"
    ]
  }
  </script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "url": "https://uscollegemap.org/",
    "name": "U.S. College Map",
    "alternateName": "US College Map",
    "description": "Interactive map of U.S. colleges where you can filter, search, save favorite schools, and explore colleges near you or along any route."
  }
  </script>
  
  <!-- BreadcrumbList Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [{
      "@type": "ListItem",
      "position": 1,
      "name": "Home",
      "item": "https://uscollegemap.org/"
    }]
  }
  </script>

  <!-- Resource Hints for Performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://nominatim.openstreetmap.org">

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body {margin:0;font-family:Inter,system-ui,sans-serif;background:#fff;color:#0f172a}
    .main-container {display:flex;flex-direction:column;min-height:100vh}
    .container {max-width:1100px;margin:0 auto;padding:16px}
    header.app-header {position:sticky;top:0;background:#fff;z-index:5000;border-bottom:1px solid #e2e8f0;box-shadow:0 10px 25px rgba(15,23,42,.08)}
    .shared-map-banner.active ~ .main-container header.app-header {top:auto}
    body:has(.shared-map-banner.active) header.app-header {top:auto}
    .app-header {display:flex;align-items:flex-start;justify-content:flex-start;padding:16px 40px;background:#fff;border-bottom:1px solid #e5e7eb;box-shadow:0 4px 10px rgba(0,0,0,0.05);transition:padding 0.25s ease, min-height 0.25s ease, box-shadow 0.25s ease}
    .header-logo-tagline {display:flex;flex-direction:column;align-items:flex-start;gap:0}
    .site-logo {height:64px;width:auto;object-fit:contain;transition:all 0.3s ease;margin-bottom:0;position: relative;z-index: 1}
    .tagline {font-family:Inter,sans-serif;font-size:14px;color:#6b7280;line-height:1.5;text-align:left;margin:0;margin-top:4px;margin-bottom:3px;margin-left:10px;font-weight:400;max-width:calc(100% - 10px)}
    .beta-badge {
      background: #2F80ED !important;
      color: white !important;
      font-size: 11px !important;
      padding: 2px 6px !important;
      border-radius: 6px !important;
      margin-left: 6px !important;
      font-weight: 600 !important;
      letter-spacing: 0.5px !important;
      display: inline-block !important;
      position: relative !important;
      z-index: 10000 !important;
      vertical-align: middle !important;
      line-height: 1 !important;
      visibility: visible !important;
      opacity: 1 !important;
      white-space: nowrap !important;
    }
    .sr-only {position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}
    @media (max-width:700px){
      .app-header{flex-direction:row;align-items:flex-start;text-align:left;padding:12px 16px;min-height:90px;}
      .app-header.collapsed{padding:6px 14px;min-height:64px;box-shadow:0 2px 6px rgba(15,23,42,0.12);}
      .header-logo-tagline{align-items:flex-start;text-align:left}
      .tagline{text-align:left;margin-left:0;max-width:100%;font-size:12px;color:#94A3B8;line-height:1.4;margin-top:4px;margin-bottom:6px;transition:opacity 0.25s ease,max-height 0.25s ease}
      .app-header.collapsed .tagline{opacity:0;max-height:0;margin:0;overflow:hidden}
      .site-logo{height:50px;width:auto;object-fit:contain;margin-bottom:0;transition:height 0.25s ease}
      .container{padding:6px;}
      .controls{padding:8px 8px;gap:2px;}
      /* Match live version exactly for type, region, state on mobile */
      .row-filters{flex-direction:row;gap:6px;flex-wrap:nowrap;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);min-width:0;padding:4px 6px;}
      .row-filters .pill label{display:none}
      .row-filters .pill select{width:100%;font-size:13px;padding:4px 8px;}
      .row-ranking .pill-ranking{padding:4px 6px;}
      .row-ranking .pill-ranking select{flex:1;margin-right:4px;width:100%;font-size:13px;padding:4px 8px;}
      .row-filters .pill-search{display:none !important}
      /* Ranking row - show on mobile only */
      .row-ranking{display:flex !important;gap:3px;justify-content:space-between;margin-bottom:3px;}
      .row-ranking .pill-ranking{flex:1 1 0;min-width:0;position:relative;display:flex !important;}
      .row-ranking .pill-ranking label{display:none !important;}
      /* Hide ranking in row-filters on mobile since it's now in row-ranking */
      .row-filters .pill-ranking{display:none !important;}
      .row-search{display:none !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .row-nearby .pill.address-autocomplete{flex:1 1 100%;}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:14px;}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:6px 10px;margin-left:4px;}
      .row-nearby .pill:not(.address-autocomplete){flex:1 1 100%;flex-direction:row;align-items:center;flex-wrap:wrap;padding:6px;}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:12px !important;font-weight:600;color:#475569;}
      .row-nearby #radius{width:70px;flex:0 0 auto;max-width:70px;}
      .row-nearby #units{width:70px;flex:0 0 auto;max-width:70px;}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:8px;}
      .pill{flex-direction:row;align-items:center;padding:6px;}
      .pill label{min-width:60px;margin-bottom:0;width:auto;font-size:11px;}
      .pill input,.pill select,.pill button{width:auto;flex:1;}
      .legend{position:relative;bottom:auto;left:auto;margin:6px;width:calc(100% - 12px);text-align:center;}
    }
    @media (max-width:399px){
      .row-filters{gap:6px;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);padding:4px 6px;}
      .row-filters .pill select{font-size:13px;padding:4px 8px;}
      .row-ranking .pill-ranking{padding:4px 6px;}
      .row-ranking .pill-ranking select{font-size:13px;padding:4px 8px;}
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .row-nearby{flex-direction:column;gap:6px}
      .row-nearby .pill.address-autocomplete{flex-direction:row;align-items:center;flex-wrap:wrap}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:11px !important;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:12px !important}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-nearby .pill:not(.address-autocomplete){flex-direction:row;align-items:center;flex-wrap:nowrap;gap:4px}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:11px !important;font-weight:600;color:#475569;flex-shrink:0}
      .row-nearby #radius{width:41px !important;flex:0 0 auto;max-width:41px;font-size:12px !important;padding:5px 4px !important}
      .row-nearby #units{width:41px !important;flex:0 0 auto;max-width:41px;font-size:12px !important;padding:5px 4px !important}
      .row-nearby #geocodeBtn{flex:0 0 auto;padding:5px 8px;font-size:12px !important;white-space:nowrap}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:5px 8px;margin-left:0;font-size:12px !important;white-space:nowrap}
      .row-route{flex-direction:column;gap:6px}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex-direction:row;align-items:center}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:40px !important;margin-bottom:0;width:auto;margin-right:5px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:12px !important}
      .row-route .pill:has(#routeMaxDistance){flex-direction:row;align-items:center;flex-wrap:nowrap}
      .row-route .pill:has(#routeMaxDistance) label{min-width:60px !important;margin-bottom:0;width:auto;margin-right:4px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:50px !important;flex:0 0 auto;max-width:50px;padding:4px 5px !important;font-size:12px !important}
      .row-route #routeUnits{width:48px !important;flex:0 0 auto;max-width:48px;font-size:12px !important;padding:4px 3px !important}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-route #clearRoute{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
    }
    @media (max-width:399px){
      .legend{position:relative;bottom:auto;left:auto;margin:6px;width:calc(100% - 12px);text-align:center;}
    }
    .controls {display:flex;flex-direction:column;gap:3px;padding:10px 12px 6px;border-top:1px solid #e5e7eb;background:#fff}
    .row {display:flex;gap:8px;justify-content:space-between}
    .row>.pill {flex:1}
    .row-filters{display:flex;gap:8px;justify-content:space-between}
    .row-filters .pill{flex:1 1 0;min-width:0;max-width:25%;}
    .row-filters .pill select,
    .row-ranking .pill-ranking select{width:100%;box-sizing:border-box;}
    .row-filters .pill-ranking{flex:1 1 0;min-width:0;max-width:25%;}
    .row-search{display:none}
    .row-filters .pill-search{display:none !important}
    /* Hide ranking row on desktop/tablet - only show on mobile (overridden in mobile media query) */
    .row-ranking{display:none;}
    @media (max-width:700px){
      .row-filters{gap:6px;justify-content:flex-start;flex-wrap:nowrap;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);max-width:none;}
    }
    @media (min-width:1025px) {
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .controls{flex-direction:row;flex-wrap:wrap;align-items:flex-start}
      .row-filters{flex:1 1 100%;margin-bottom:3px;gap:8px}
      .row-filters .pill:not(.pill-ranking){flex:1 1 0;min-width:0;max-width:23%;}
      .row-filters .pill-ranking{flex:1.2 1 0;min-width:0;max-width:31%;}
      .row-filters .pill-search{flex:1 1 auto;min-width:200px}
      .row-filters .pill-search input{font-size:14px}
      .row-filters .pill-ranking select{flex:1;margin-right:4px}
      .row-nearby{display:flex;flex-direction:row;gap:8px;flex-wrap:nowrap;margin-bottom:0;align-items:center}
      .row-nearby .pill.address-autocomplete{flex:1 1 auto;min-width:0}
      .row-nearby .pill.address-autocomplete label{min-width:60px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{font-size:14px}
      .row-nearby .pill.address-autocomplete button{font-size:14px}
      .row-nearby .pill:not(.address-autocomplete){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:60px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-nearby #radius{width:63px;flex:0 0 auto;font-size:14px}
      .row-nearby #units{width:62px;flex:0 0 auto;font-size:14px}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
      .row-route{display:flex;flex-direction:row;gap:8px;flex-wrap:nowrap;margin-bottom:0;align-items:center}
      .row-route .pill{flex:1 1 auto;min-width:0}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex:1 1 auto;min-width:0}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:45px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:14px}
      .row-route .pill:has(#routeMaxDistance){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-route .pill:has(#routeMaxDistance) label{min-width:75px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:70px;flex:0 0 auto;font-size:14px}
      .row-route #routeUnits{width:55px;flex:0 0 auto;font-size:14px}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
      .row-route #clearRoute{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
    }
    .pill {display:flex;align-items:center;gap:6px;background:#f1f5f9;border:1px solid #e2e8f0;padding:4px 8px;border-radius:12px;font-size:12px}
    .pill label {color:#475569;font-weight:600;font-size:12px;min-width:60px}
    .pill input,.pill select,.pill button {border:1px solid #e2e8f0;border-radius:10px;padding:6px 8px;background:#fff;color:#0f172a;font-size:14px;flex:1;transition:border-color 0.2s,box-shadow 0.2s}
    /* State dropdown divider */
    .pill select option.state-divider {
      background-color: #f3f4f6;
      color: #6b7280;
      font-weight: 500;
      font-size: 12px;
      padding: 8px;
      cursor: default;
    }
    .pill input:focus {outline:none;border-color:#4285f4;box-shadow:0 0 0 1px #4285f4}
    .pill button {background:#2563eb;color:#fff;border:none;font-weight:600;cursor:pointer;flex:0}
    @media (min-width:701px){
      .row-filters .pill label,
      .row-nearby .pill label,
      .row-route .pill label{font-size:14px}
      .row-filters .pill select,
      .row-filters .pill input,
      .row-nearby .pill input,
      .row-nearby .pill select,
      .row-route .pill input,
      .row-route .pill select{font-size:14px}
    }
    .pill-ranking {position:relative}
    .ranking-new-chat-bubble {display:block !important;position:fixed !important;background:#2563eb !important;color:#fff !important;padding:4px 8px !important;border-radius:8px !important;font-size:11px !important;font-weight:600 !important;white-space:nowrap !important;z-index:10001 !important;box-shadow:0 4px 12px rgba(37,99,235,0.3) !important;pointer-events:none !important;opacity:0;transform:translateY(4px);transition:opacity 0.3s ease,transform 0.3s ease;visibility:visible !important}
    .ranking-new-chat-bubble::after {content:'';position:absolute;top:100%;left:12px;border-width:6px 6px 0 6px;border-style:solid;border-color:#2563eb transparent transparent transparent}
    .ranking-new-chat-bubble.visible {opacity:1;transform:translateY(0)}
    .ranking-info-icon {width:18px !important;height:18px !important;min-width:18px !important;min-height:18px !important;max-width:18px !important;max-height:18px !important;border-radius:50% !important;background:#eff6ff !important;color:#2563eb !important;border:1px solid #3b82f6 !important;font-size:11px !important;font-weight:900 !important;-webkit-text-stroke:0.4px #2563eb !important;text-shadow:0 0 0.5px #2563eb !important;line-height:1 !important;padding:0 !important;margin:0 !important;display:inline-flex !important;align-items:center !important;justify-content:center !important;cursor:pointer !important;flex:0 0 18px !important;flex-shrink:0 !important;box-sizing:border-box !important;vertical-align:middle !important;transition:all 0.2s ease !important}
    .ranking-info-icon:hover {border-color:#2563eb !important;color:#1d4ed8 !important;background:#dbeafe !important;transform:scale(1.05) !important}
    .ranking-tooltip {position:absolute;top:calc(100% + 2px);right:0;margin-top:0;background:linear-gradient(180deg,rgba(255,249,219,0.98),rgba(255,243,191,0.98));padding:10px 12px;border-radius:12px;box-shadow:0 8px 18px rgba(15,23,42,0.18);font-size:0.75rem;max-width:260px;width:clamp(180px, calc(100vw - 32px), 260px);display:none;z-index:2000;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(234,179,8,0.5)}
    .ranking-tooltip.active {display:block;animation:fadeIn 0.2s ease-out}
    .ranking-tooltip::after {content:'';position:absolute;bottom:100%;right:9px;border-width:0 6px 6px 6px;border-style:solid;border-color:transparent transparent rgba(255,243,191,0.98) transparent;filter:drop-shadow(0 -2px 4px rgba(15,23,42,0.15))}
    .ranking-tooltip::before {content:'';position:absolute;bottom:calc(100% + 1px);right:8px;border-width:0 7px 7px 7px;border-style:solid;border-color:transparent transparent rgba(234,179,8,0.5) transparent}
    .ranking-tooltip-header {display:flex;align-items:flex-start;gap:8px;margin-bottom:0}
    .ranking-tooltip-close {position:absolute;top:8px;right:8px;background:none !important;border:none !important;color:#0f172a !important;font:inherit;font-size:14px;padding:0;line-height:1;cursor:pointer;box-shadow:none;appearance:none;width:auto;height:auto;min-width:0;min-height:0;border-radius:0;display:inline-block;flex:none}
    .ranking-tooltip-close:focus {outline:none;box-shadow:none}
    .ranking-tooltip-body {font-size:0.8125rem;line-height:1.5;color:#0f172a;padding-right:24px;flex:1}
    #map {height:calc(100vh - 280px);background:#e5e7eb;border-top:1px solid #e2e8f0;position:relative;min-height:500px}
    .legend {position:absolute;bottom:14px;left:14px;padding:0;border:none;font-size:11px;font-weight:500;color:#0f172a;text-shadow:none;z-index:1800;background:none;border-radius:0;line-height:1;text-align:left;transform:none}
    .map-hint-bubble {position:absolute;top:16px;left:16px;background:rgba(255,255,255,0.98);padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(15,23,42,0.18);font-size:0.75rem;max-width:260px;width:clamp(180px, calc(100vw - 32px), 260px);display:none;z-index:8500;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(226,232,240,0.8)}
    .map-hint-bubble.active {display:block;animation:fadeIn 0.2s ease-out}
    .map-hint-bubble-header {display:flex;align-items:center;gap:8px;margin-bottom:6px}
    .map-hint-bubble-icon {font-size:16px;line-height:1;flex-shrink:0}
    .map-hint-bubble-close {background:none;border:none;color:#94a3b8;cursor:pointer;font-size:18px;line-height:1;padding:0;width:18px;height:18px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:color 0.2s;margin-left:auto;margin-top:-2px;margin-right:-4px}
    .map-hint-bubble-close:hover {color:#64748b}
    .map-hint-bubble-title {font-weight:600;font-size:0.875rem;line-height:1.4;color:#0f172a;flex:1}
    .map-hint-bubble-body {font-size:0.8125rem;line-height:1.5;color:#64748b}
    @media (max-width:700px) {
      .map-hint-bubble {top:16px;left:12px;right:12px;width:clamp(160px, calc(100vw - 24px), 260px);max-width:calc(100vw - 24px);box-sizing:border-box}
    }
    .map-tip-bubble {position:absolute;background:rgba(255,255,255,0.98);padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(15,23,42,0.18);font-size:0.8125rem;max-width:280px;width:clamp(200px, calc(100vw - 32px), 280px);display:none;z-index:2001;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(226,232,240,0.8)}
    .map-tip-bubble.active {display:block;animation:fadeIn 0.2s ease-out}
    .map-tip-bubble::after {content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border-width:6px 6px 0 6px;border-style:solid;border-color:rgba(255,255,255,0.98) transparent transparent transparent;filter:drop-shadow(0 2px 4px rgba(15,23,42,0.15))}
    .map-tip-bubble::before {content:'';position:absolute;top:calc(100% + 1px);left:calc(50% - 1px);transform:translateX(-50%);border-width:7px 7px 0 7px;border-style:solid;border-color:rgba(226,232,240,0.8) transparent transparent transparent}
    .map-tip-bubble-content {display:flex;align-items:center;gap:8px}
    .map-tip-bubble-icon {font-size:14px;line-height:1;flex-shrink:0}
    .map-tip-bubble-text {font-size:0.8125rem;line-height:1.4;color:#0f172a;flex:1}
    .map-tip-bubble-close {background:none;border:none;color:#94a3b8;cursor:pointer;font-size:16px;line-height:1;padding:0;width:16px;height:16px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:color 0.2s;margin-left:4px}
    .map-tip-bubble-close:hover {color:#64748b}
    @media (max-width:700px) {
      .map-tip-bubble {max-width:calc(100vw - 24px);width:clamp(180px, calc(100vw - 24px), 280px);font-size:0.75rem;padding:8px 10px;box-sizing:border-box}
      .map-tip-bubble-icon {font-size:12px}
    }
    .leaflet-tooltip {background:#fff;color:#0f172a;border:1px solid #e2e8f0;border-radius:6px;font-size:12px;font-weight:500;padding:4px 8px;box-shadow:0 2px 6px rgba(0,0,0,.1)}
    /* Override Leaflet's default orange tap highlight on mobile/iPad - match desktop (white/no highlight) */
    .leaflet-interactive:active,
    .leaflet-interactive:focus,
    .leaflet-interactive.leaflet-touch-active {
      outline: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    /* Remove orange tap highlight and use white styling (matching desktop behavior) */
    /* Target both SVG circle elements and path elements used by Leaflet circleMarker */
    .leaflet-interactive.leaflet-touch-active circle,
    .leaflet-interactive:active circle,
    .leaflet-interactive:focus circle,
    .leaflet-interactive.leaflet-touch-active path,
    .leaflet-interactive:active path,
    .leaflet-interactive:focus path {
      /* Use white stroke instead of orange (matching desktop tap behavior) */
      stroke: #ffffff !important;
      stroke-width: 2 !important;
      /* Keep original blue fill */
      fill: #2563eb !important;
      fill-opacity: 0.7 !important;
      /* Remove any orange filter or effects */
      filter: none !important;
    }
    .route-hint-bubble {position:fixed;background:linear-gradient(180deg,rgba(255,249,219,0.98),rgba(255,243,191,0.98));padding:8px 12px;border-radius:12px;box-shadow:0 8px 18px rgba(15,23,42,0.18);font-size:12px;max-width:210px;display:none;z-index:6500;border:1px solid rgba(234,179,8,0.5);pointer-events:auto;opacity:0;transform:translateY(6px);transition:opacity 0.2s ease,transform 0.2s ease}
    .route-hint-bubble.visible {opacity:1;transform:translateY(0)}
    .route-hint-bubble-content {display:flex;align-items:center;font-weight:500;color:#0f172a}
    .route-hint-bubble::after {content:'';position:absolute;bottom:-8px;left:50%;transform:translateX(-50%);border-width:8px 8px 0 8px;border-style:solid;border-color:rgba(255,243,191,0.98) transparent transparent transparent;filter:drop-shadow(0 2px 4px rgba(15,23,42,0.15))}
    .route-hint-bubble::before {content:'';position:absolute;bottom:-9px;left:50%;transform:translateX(-50%);border-width:9px 9px 0 9px;border-style:solid;border-color:rgba(234,179,8,0.5) transparent transparent transparent}
    .route-hint-bubble.below::after {top:-8px;bottom:auto;border-width:0 8px 8px 8px;border-color:transparent transparent rgba(255,243,191,0.98) transparent}
    .route-hint-bubble.below::before {top:-9px;bottom:auto;border-width:0 9px 9px 9px;border-color:transparent transparent rgba(234,179,8,0.5) transparent}
    .route-hint-bubble-text {line-height:1.3;display:block;white-space:nowrap}
    .loading {display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;padding:20px;border-radius:12px;box-shadow:0 10px 25px rgba(15,23,42,.15);z-index:1000}
    .loading.active {display:block}
    .error {display:none;background:#fee;color:#c33;padding:12px;border-radius:8px;margin:12px;border:1px solid #fcc}
    .error.active {display:block}
    .site-footer {background:#fff;border-top:1px solid #e2e8f0;padding:10px 16px;font-size:12px;color:#94A3B8;text-align:center}
    .feedback-button {position:fixed;bottom:18px;right:18px;background:#2563eb;color:#fff;border:none;padding:10px 16px;border-radius:8px;font-family:Inter,sans-serif;font-size:14px;font-weight:500;cursor:pointer;box-shadow:0 4px 12px rgba(37,99,235,0.3);z-index:1000;transition:all 0.2s ease}
    .feedback-button:hover {background:#1d4ed8;box-shadow:0 6px 16px rgba(37,99,235,0.4);transform:translateY(-2px)}
    .feedback-button.hidden {display:none}
    .feedback-popup {position:fixed;bottom:70px;right:18px;width:280px;background:#fff;border-radius:12px;box-shadow:0 10px 25px rgba(15,23,42,.15);border:1px solid #e2e8f0;z-index:1001;padding:20px;display:none;animation:fadeIn 0.2s ease-out}
    .feedback-popup.active {display:block}
    .feedback-popup-header {display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px;margin-top:-2px}
    .feedback-popup-close {background:none;border:none;font-size:24px;color:#94a3b8;cursor:pointer;line-height:1;padding:0;width:24px;height:24px;display:flex;align-items:center;justify-content:center;transition:color 0.2s}
    .feedback-popup-close:hover {color:#64748b}
    .feedback-popup-message {font-size:14px;color:#0f172a;line-height:1.5;margin-bottom:16px}
    .feedback-popup-button {display:inline-block;background:#2563eb;color:#fff;border:none;padding:10px 28px;border-radius:8px;font-family:Inter,sans-serif;font-size:14px;font-weight:500;cursor:pointer;transition:background 0.2s}
    .feedback-popup-button-wrapper {text-align:center;margin-bottom:12px}
    .feedback-popup-button:hover {background:#1d4ed8}
    .feedback-popup-dismiss {display:block;text-align:center;font-size:12px;color:#94a3b8;text-decoration:none;cursor:pointer;transition:color 0.2s}
    .feedback-popup-dismiss:hover {color:#64748b}
    @media (max-width:700px){
      .feedback-popup {width:calc(100% - 36px);max-width:280px;right:18px;left:auto}
    }
    .radius-circle {stroke:#2563eb;stroke-width:2;stroke-dasharray:5,5;fill:none;opacity:0.5;pointer-events:none}
    .address-autocomplete {position:relative;z-index:10;isolation:isolate}
    .address-autocomplete.autocomplete-active {z-index:8500}
    .autocomplete-suggestions {display:none;position:absolute;top:calc(100% + 4px);left:0;right:0;background:#fff;border:none;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.1),0 8px 24px rgba(0,0,0,0.12);max-height:400px;overflow-y:auto;overflow-x:hidden;z-index:8500;margin-top:0;pointer-events:auto;transform:translateZ(0);will-change:transform}
    .autocomplete-suggestions.active {display:block;animation:fadeIn 0.15s ease-out}
    @keyframes fadeIn {from{opacity:0;transform:translateY(-4px)} to{opacity:1;transform:translateY(0)}}
    .autocomplete-item {padding:0;cursor:pointer;border-bottom:none;font-size:14px;transition:background-color 0.1s;min-height:48px;display:flex;flex-direction:row;align-items:center;position:relative;width:100%;pointer-events:auto;user-select:none;-webkit-user-select:none}
    .autocomplete-item:not(:last-child)::after {content:'';position:absolute;bottom:0;left:56px;right:0;height:1px;background:#f1f5f9}
    .autocomplete-item:hover,.autocomplete-item.highlighted {background-color:#f8f9fa}
    .autocomplete-item:focus {outline:2px solid #4285f4;outline-offset:-2px;background-color:#f8f9fa}
    .autocomplete-item-icon {width:40px;height:40px;display:flex;align-items:center;justify-content:center;flex-shrink:0;margin-left:8px}
    .autocomplete-item-icon svg {width:20px;height:20px;fill:#5f6368;display:block}
    .autocomplete-item.highlighted .autocomplete-item-icon svg,.autocomplete-item:hover .autocomplete-item-icon svg {fill:#4285f4}
    .autocomplete-item-content {flex:1;padding:12px 8px 12px 0;min-width:0;display:flex;flex-direction:column;justify-content:center}
    .autocomplete-item .address-name {font-weight:400;color:#202124;margin-bottom:2px;font-size:15px;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .autocomplete-item .address-name strong {font-weight:500;color:#202124}
    .autocomplete-item.highlighted .address-name,.autocomplete-item:hover .address-name {color:#1a73e8}
    .autocomplete-item.highlighted .address-name strong,.autocomplete-item:hover .address-name strong {color:#1a73e8;font-weight:500}
    .autocomplete-item .address-details {font-size:13px;color:#5f6368;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .autocomplete-loading {padding:16px;text-align:center;color:#5f6368;font-size:14px;display:flex;align-items:center;justify-content:center;gap:8px}
    .autocomplete-loading::before {content:'';width:16px;height:16px;border:2px solid #e0e0e0;border-top-color:#4285f4;border-radius:50%;animation:spin 0.8s linear infinite}
    @keyframes spin {to{transform:rotate(360deg)}}
    .autocomplete-empty {padding:24px;text-align:center;color:#5f6368;font-size:14px}
    .autocomplete-section-title{padding:10px 16px;font-size:12px;letter-spacing:0.08em;text-transform:uppercase;color:#94a3b8;font-weight:600}
    .autocomplete-divider{height:1px;background:#e2e8f0;margin:4px 0}
    @media (max-width: 700px) {
      .autocomplete-item {min-height:52px}
      .autocomplete-item-icon {width:44px;height:44px;margin-left:12px}
      .autocomplete-item-content {padding:14px 12px 14px 0}
      .row-nearby{flex-direction:column;gap:6px}
      .row-nearby .pill.address-autocomplete{flex-direction:row;align-items:center;flex-wrap:wrap}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:11px !important;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:12px !important}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-nearby .pill:not(.address-autocomplete){flex-direction:row;align-items:center;flex-wrap:nowrap;gap:4px}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:11px !important;font-weight:600;color:#475569;flex-shrink:0}
      .row-nearby #radius{width:41px !important;flex:0 0 auto;max-width:41px;font-size:12px !important;padding:5px 4px !important}
      .row-nearby #units{width:41px !important;flex:0 0 auto;max-width:41px;font-size:12px !important;padding:5px 4px !important}
      .row-nearby #geocodeBtn{flex:0 0 auto;padding:5px 8px;font-size:12px !important;white-space:nowrap}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:5px 8px;margin-left:0;font-size:12px !important;white-space:nowrap}
      .row-route{flex-direction:column;gap:6px}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex-direction:row;align-items:center}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:40px !important;margin-bottom:0;width:auto;margin-right:5px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:12px !important}
      .row-route .pill:has(#routeMaxDistance){flex-direction:row;align-items:center;flex-wrap:nowrap}
      .row-route .pill:has(#routeMaxDistance) label{min-width:60px !important;margin-bottom:0;width:auto;margin-right:4px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:50px !important;flex:0 0 auto;max-width:50px;padding:4px 5px !important;font-size:12px !important}
      .row-route #routeUnits{width:48px !important;flex:0 0 auto;max-width:48px;font-size:12px !important;padding:4px 3px !important}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-route #clearRoute{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
    }
    @media (max-width: 700px) {
      html.ios-device .row-nearby #units {
        width:70px !important;
        max-width:70px !important;
      }
      html.ios-device .row-route .pill:has(#routeStart) label,
      html.ios-device .row-route .pill:has(#routeEnd) label,
      html.ios-device .row-route .pill:has(#routeMaxDistance) label {
        font-size:16px !important;
      }
    }
    @media (max-width: 480px) {
      .container{padding:4px;}
      .controls{padding:8px 4px;}
      .row{gap:6px;}
      .pill{padding:8px;}
    }
    @media (min-width: 701px) and (max-width: 1024px) {
      .row-filters{flex-direction:row;gap:6px;flex-wrap:nowrap;}
      .row-filters .pill:not(.pill-ranking){flex:1 1 0;min-width:0;max-width:23%;}
      .row-filters .pill-ranking{flex:1.2 1 0;min-width:0;max-width:31%;}
      .row-filters .pill label{display:none}
      .row-filters .pill select{width:100%;font-size:14px;padding:6px 8px;}
      .row-filters .pill-ranking select{flex:1;margin-right:4px;font-size:14px;}
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .controls{flex-direction:row;flex-wrap:wrap;align-items:flex-start}
      .row-filters{flex:1 1 100%;margin-bottom:3px}
      .row-search{flex:1 1 100%;margin-bottom:3px}
      .row-nearby{display:flex;flex-direction:row;gap:6px;flex-wrap:nowrap;margin-bottom:0}
      .row-nearby .pill.address-autocomplete{flex:1 1 auto;min-width:0}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:14px;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:14px}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:6px 10px;margin-left:4px;font-size:14px}
      .row-nearby .pill:not(.address-autocomplete){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-nearby #radius{width:57px;flex:0 0 auto;max-width:57px;font-size:14px}
      .row-nearby #units{width:58px;flex:0 0 auto;max-width:58px;font-size:14px}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:14px}
      .row-route{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:0}
      .row-route .pill:first-child,.row-route .pill:nth-child(2){width:100%;box-sizing:border-box;padding:4px 6px}
      .row-route .pill:first-child label,.row-route .pill:nth-child(2) label{min-width:40px;max-width:40px;margin-bottom:0;width:40px;margin-right:5px;font-size:14px;font-weight:600;color:#475569;flex-shrink:0}
      .row-route .pill:first-child input,.row-route .pill:nth-child(2) input{min-width:0;flex:1 1 0;padding:5px 6px;font-size:14px;box-sizing:border-box}
      .row-route .pill:last-child{grid-column:1 / -1;flex-direction:row;align-items:center;margin-top:0;padding:4px 6px}
      .row-route .pill:last-child label{min-width:70px;margin-bottom:0;width:auto;margin-right:6px;font-size:14px;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:65px;flex:0 0 auto;max-width:65px;padding:5px 6px;font-size:14px}
      .row-route #routeUnits{width:50px;flex:0 0 auto;max-width:50px;padding:5px 4px;font-size:14px}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .row-route #clearRoute{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .filter-section {margin-top:3px}
      .filter-section summary {padding:8px 10px;font-size:13px}
      .filter-section-content {padding:0 10px 8px}
    }
    .filter-section {background:#f8fafc;border-radius:12px;border:1px solid #e2e8f0;margin-top:4px;overflow:visible;width:100%;flex:1 1 100%;position:relative;transition:box-shadow 0.2s ease}
    .filter-section-content {overflow:visible}
    .filter-section summary {font-weight:600;color:#0f172a;font-size:14px;padding:8px 12px;cursor:pointer;list-style:none;user-select:none;display:flex;align-items:center;gap:8px}
    .filter-section summary::-webkit-details-marker {display:none}
    .filter-section summary::before {content:'▶';font-size:10px;transition:transform 0.2s;display:inline-block}
    .filter-section[open] summary::before {transform:rotate(90deg)}
    .filter-section summary:hover {background:#f1f5f9}
    .filter-section-content {padding:0 12px 8px;display:flex;flex-direction:column;gap:3px}
    .filter-section.active {box-shadow:0 4px 12px rgba(37,99,235,0.15),0 2px 4px rgba(0,0,0,0.1);border-left:4px solid #2563eb}
    .filter-section.active summary {background:#f0f7ff}
    .about-map {max-width:1100px;margin:16px auto 24px;font-size:13px;color:#475569;background:#f8fafc;border-radius:12px;padding:10px 16px 14px;border:1px solid #e2e8f0}
    .about-map-title {font-weight:600;color:#0f172a;font-size:15px;margin:0 0 12px 0;text-align:center;padding-bottom:12px;border-bottom:2px solid #fff}
    .info-snippets {display:grid;grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));gap:14px;padding-top:8px}
    .snippet h2 {font-size:14px;font-weight:600;margin-bottom:4px;color:#1e293b;display:flex;align-items:center;gap:4px}
    .snippet h2 .star-icon {font-size:0.85em;line-height:1;display:inline-flex;align-items:center;margin-top:0}
    .snippet p {font-size:13px;color:#64748b;line-height:1.5}
    .site-disclaimer {max-width:1100px;margin:0 auto 24px;font-size:10px;line-height:1.5;color:#475569;padding:0 16px;text-align:left}
    @media (max-width:700px) {
      .info-snippets {grid-template-columns:1fr}
      .filter-section {margin-top:3px}
      .filter-section summary {padding:10px 12px;font-size:13px}
      .filter-section-content {padding:0 12px 10px}
    }
    @media (max-width:768px) {
      html.ios-device .row-search .pill,
      html.ios-device .row-search .pill input,
      html.ios-device .row-search .pill button,
      html.ios-device .row-nearby,
      html.ios-device .row-nearby .pill,
      html.ios-device .row-nearby .pill input,
      html.ios-device .row-nearby .pill select,
      html.ios-device .row-nearby .pill button,
      html.ios-device .row-route,
      html.ios-device .row-route .pill,
      html.ios-device .row-route .pill label,
      html.ios-device .row-route .pill input,
      html.ios-device .row-route .pill select,
      html.ios-device .row-route .pill button,
      html.ios-device #radius,
      html.ios-device #units,
      html.ios-device #geocodeBtn,
      html.ios-device #clearRadius,
      html.ios-device #routeMaxDistance,
      html.ios-device #routeUnits,
      html.ios-device #findRouteBtn,
      html.ios-device #clearRoute,
      html.ios-device details.filter-section summary {
        font-size:16px !important;
      }
      html.ios-device .row-route .pill input::placeholder,
      html.ios-device .row-nearby .pill input::placeholder {
        font-size:16px !important;
      }
      html.ios-device label[for="type"],
      html.ios-device label[for="region"],
      html.ios-device label[for="state"],
      html.ios-device #type,
      html.ios-device #region,
      html.ios-device #state {
        font-size:16px !important;
      }
    }
    html.ios-device .row-search .pill label,
    html.ios-device .row-nearby .pill label,
    html.ios-device .row-route .pill label,
    html.ios-device .row-filters .pill-search label {
      font-size:16px !important;
    }
    html.ios-device .row-route .pill label {
      font-size:16px !important;
    }
    /* Force 16px inputs on iOS — MUST BE AT BOTTOM OF FILE */
    html.ios-device input,
    html.ios-device textarea,
    html.ios-device select {
      font-size:16px !important;
    }
      /* iOS mobile: 16px for filter dropdowns */
      @media (max-width:700px) {
        html.ios-device .row-filters .pill select,
        html.ios-device .row-ranking .pill-ranking select,
        html.ios-device #type,
        html.ios-device #region,
        html.ios-device #state,
        html.ios-device #ranking {
          font-size:16px !important;
        }
        /* Make ranking dropdown full width on iOS mobile */
        html.ios-device .row-ranking .pill-ranking select {
          width: 100% !important;
          flex: 1 1 100% !important;
          margin-right: 0 !important;
        }
      }
      @media (min-width:701px) and (max-width:1024px) {
        html.ios-device .row-filters .pill select,
        html.ios-device .row-ranking .pill-ranking select,
        html.ios-device #type,
        html.ios-device #region,
        html.ios-device #state,
        html.ios-device #ranking {
          font-size:16px !important;
        }
      }
    /* iOS: keep route inputs at 16px so Safari doesn't zoom */
    html.ios-device #routeStart,
    html.ios-device #routeEnd {
      font-size: 16px !important;
    }
    html.ios-device .row-route .pill input,
    html.ios-device .row-nearby .pill input {
      font-size:16px !important;
    }
    @media (max-width:768px) {
      /* iOS-only: fix Safari zoom issue */
      html.ios-device .row-route .pill:has(#routeStart) input,
      html.ios-device .row-route .pill:has(#routeEnd) input {
        font-size: 16px !important;
      }
    }
    /* Popup save button styling */
    .popup-save-row {
      display: flex;
      justify-content: flex-end;
      margin-top: 8px;
      padding-top: 4px;
    }
    .popup-save-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      font-weight: 500;
      font-family: Inter, sans-serif;
      color: #64748b;
      background: #f1f5f9;
      border: 1px solid #e2e8f0;
      border-radius: 9999px;
      padding: 4px 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      line-height: 1.4;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .popup-save-btn .popup-save-label {
      min-width: 40px;
      text-align: center;
      display: inline-block;
    }
    .popup-save-btn:hover {
      background: #e2e8f0;
      color: #475569;
    }
    .popup-save-btn .popup-save-icon {
      font-size: 12px;
      line-height: 1;
      color: #64748b;
    }
    .popup-save-btn.saved {
      color: #15803d;
      background: #dcfce7;
      border-color: #86efac;
    }
    .popup-save-btn.saved .popup-save-icon {
      color: #16a34a;
    }
    .popup-save-btn.saved:hover {
      background: #bbf7d0;
      color: #15803d;
    }
    /* Ensure Leaflet popups appear above everything, including header and logo */
    .leaflet-popup-pane {
      z-index: 10000 !important;
    }
    .leaflet-popup {
      z-index: 10000 !important;
    }
    /* Saved controls overlay */
    .saved-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #E5E7EB;
      border-radius: 9999px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      height: 38px;
      padding: 0 6px;
      z-index: 8000;
      font-family: Inter, sans-serif;
      font-weight: 500;
      color: #374151;
      font-size: 12px;
      pointer-events: auto;
      gap: 4px;
    }
    /* Lower z-index for saved-controls when overlay is active so pill appears behind overlay */
    body:has(.saved-colleges-overlay.active) .saved-controls {
      z-index: 2500;
    }
    .saved-list-section,
    .saved-only-section {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 0 4px;
      cursor: pointer;
      transition: opacity 0.2s, color 0.2s, padding-right 0.15s ease;
      user-select: none;
      position: relative;
    }
    .saved-only-section.saved-only-active {
      padding-right: 36px;
    }
    .saved-only-main {
      display: flex;
      align-items: center;
      gap: 5px;
      transition: transform 0.15s ease;
    }
    .saved-only-section.saved-only-active .saved-only-main {
      transform: translateX(-2px);
    }
    .saved-only-divider {
      position: absolute;
      right: 28px;
      width: 1px;
      height: 20px;
      background: #E5E7EB;
      opacity: 0;
      transform: translateX(8px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      pointer-events: none;
      flex-shrink: 0;
    }
    .saved-only-section.saved-only-active .saved-only-divider {
      opacity: 1;
      transform: translateX(0);
    }
    .saved-share-icon {
      position: absolute;
      right: 4px;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transform: translateX(8px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      pointer-events: none;
      cursor: pointer;
      flex-shrink: 0;
    }
    .saved-only-section.saved-only-active .saved-share-icon {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }
    .saved-share-icon svg {
      width: 18px;
      height: 18px;
      stroke: #1d4ed8;
      stroke-width: 2;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.2s;
    }
    .saved-share-tooltip {
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      background: linear-gradient(180deg, rgba(255, 249, 219, 0.98), rgba(255, 243, 191, 0.98));
      color: #0f172a;
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
      border: 1px solid rgba(234, 179, 8, 0.5);
      font-size: 0.75rem;
      font-family: Inter, sans-serif;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      transform: translateY(-4px);
      z-index: 7000 !important;
      display: none;
    }
    .saved-share-icon:hover .saved-share-tooltip {
      transform: translateY(0);
    }
    .saved-share-tooltip::after {
      content: '';
      position: absolute;
      top: -6px;
      right: 10px;
      border-width: 0 6px 6px 6px;
      border-style: solid;
      border-color: transparent transparent rgba(255, 243, 191, 0.98) transparent;
      filter: drop-shadow(0 2px 4px rgba(15, 23, 42, 0.15));
    }
    .saved-share-tooltip::before {
      content: '';
      position: absolute;
      top: -7px;
      right: 9px;
      border-width: 0 7px 7px 7px;
      border-style: solid;
      border-color: transparent transparent rgba(234, 179, 8, 0.5) transparent;
    }
    /* Tooltip and hover effects only on desktop (hover-capable devices) */
    @media (hover: hover) and (pointer: fine) {
      .saved-share-icon:hover svg {
        stroke: #1e40af;
      }
      .saved-share-tooltip {
        display: block;
      }
      .saved-share-icon:hover .saved-share-tooltip:not(.tooltip-hidden) {
        opacity: 1;
      }
      .saved-share-tooltip.tooltip-hidden {
        opacity: 0 !important;
        pointer-events: none !important;
      }
    }
    /* On mobile/tablet (touch devices), hide tooltip completely and ensure tap works */
    @media (hover: none) or (pointer: coarse) {
      .saved-share-tooltip {
        display: none !important;
      }
    }
    /* Toast notification */
    .toast {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, calc(-50% + 40px));
      background: #fff;
      color: #0f172a;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
      border: 1px solid #e2e8f0;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 200px;
      max-width: 90vw;
      opacity: 0;
      pointer-events: none;
      z-index: 10000;
      font-size: 14px;
      line-height: 1.4;
      transition: opacity 0.3s ease, transform 0.3s ease;
      font-family: Inter, sans-serif;
    }
    .toast.active {
      opacity: 1;
      transform: translate(-50%, -50%);
      pointer-events: auto;
    }
    .toast-message {
      flex: 1;
      white-space: normal;
      word-wrap: break-word;
      text-align: center;
    }
    @media (min-width: 600px) {
      .toast {
        max-width: 400px;
        width: auto;
      }
    }
    /* Shared map banner */
    .shared-map-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #fef3c7;
      border-bottom: 2px solid #fbbf24;
      padding: 12px 16px;
      display: none;
      align-items: center;
      justify-content: space-between;
      z-index: 10000;
      font-size: 14px;
      color: #dc2626;
      font-weight: 700;
      font-family: Inter, sans-serif;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .shared-map-banner.active {
      display: flex;
    }
    .shared-map-banner-message {
      flex: 1;
      line-height: 1.4;
      font-weight: 700;
      color: #dc2626;
    }
    .shared-map-banner-close {
      background: none;
      border: none;
      color: #dc2626;
      cursor: pointer;
      font-size: 20px;
      line-height: 1;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 12px;
      flex-shrink: 0;
      transition: color 0.2s;
      font-weight: 700;
    }
    .shared-map-banner-close:hover {
      color: #b91c1c;
      background: rgba(220, 38, 38, 0.1);
      border-radius: 4px;
    }
    @media (max-width: 700px) {
      .shared-map-banner {
        padding: 10px 12px;
        font-size: 13px;
      }
      .shared-map-banner-message {
        font-size: 13px;
      }
    }
    .saved-list-section {
      color: #1d4ed8;
      text-decoration: none;
      gap: 6px;
    }
    .saved-pill {
      display: inline-flex;
      align-items: center;
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      border-radius: 9999px;
      padding: 3px 10px;
      box-shadow: 0 6px 16px rgba(37, 99, 235, 0.12);
      transition: background 0.2s, border-color 0.2s, color 0.2s;
      font-weight: 600;
    }
    .saved-list-section:hover .saved-pill {
      color: #1e40af;
      background: #e0e7ff;
      border-color: #a5b4fc;
    }
    .saved-list-section:focus-visible .saved-pill {
      outline: 2px solid #1d4ed8;
      outline-offset: 2px;
    }
    .saved-icon {
      width: 22px;
      height: 22px;
      flex-shrink: 0;
    }
    .saved-text {
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    }
    .saved-controls-divider {
      width: 1px;
      height: 20px;
      background: #E5E7EB;
      margin: 0 2px;
      flex-shrink: 0;
    }
    .saved-toggle {
      flex-shrink: 0;
      margin-right: 3px;
    }
    .saved-toggle-track {
      width: 30px;
      height: 16px;
      background: #D1D5DB;
      border-radius: 9999px;
      position: relative;
      transition: background-color 0.2s;
      cursor: pointer;
    }
    .saved-toggle-thumb {
      width: 12px;
      height: 12px;
      background: white;
      border-radius: 50%;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    .saved-controls.saved-only-active .saved-toggle-track {
      background: #64D85B;
    }
    .saved-controls.saved-only-active .saved-toggle-thumb {
      transform: translateX(12px);
    }
    @media (max-width: 1024px) {
      .saved-controls {
        padding: 0 5px;
      }
      .saved-list-section,
      .saved-only-section {
        padding: 0 3px;
        gap: 4px;
      }
      .saved-only-section.saved-only-active {
        padding-right: 32px;
      }
      .saved-only-divider {
        right: 24px;
        height: 20px;
      }
      .saved-share-icon {
        right: 3px;
        width: 18px;
        height: 18px;
      }
      .saved-share-icon svg {
        width: 16px;
        height: 16px;
      }
      .saved-pill {
        padding: 3px 9px;
      }
      .saved-icon {
        width: 20px;
        height: 20px;
      }
      .saved-toggle-track {
        width: 28px;
        height: 16px;
      }
      .saved-toggle-thumb {
        width: 12px;
        height: 12px;
      }
      .saved-controls.saved-only-active .saved-toggle-thumb {
        transform: translateX(12px);
      }
    }
    @media (max-width: 700px) {
      .saved-controls {
        height: 36px;
        top: 10px;
        right: 10px;
      }
      .saved-toggle-track {
        width: 24px;
        height: 14px;
      }
      .saved-toggle-thumb {
        width: 10px;
        height: 10px;
        top: 2px;
        left: 2px;
      }
      .saved-controls.saved-only-active .saved-toggle-thumb {
      transform: translateX(10px);
    }
      .saved-only-section.saved-only-active {
        padding-right: 30px;
      }
      .saved-only-divider {
        right: 22px;
        height: 18px;
      }
      .saved-share-icon {
        right: 3px;
        width: 16px;
        height: 16px;
      }
      .saved-share-icon svg {
        width: 14px;
        height: 14px;
      }
  }
  /* Filter chips */
  .filter-chips {
    position: absolute;
    top: 60px;
    right: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 1500;
    pointer-events: auto;
    font-family: Inter, sans-serif;
    font-size: 12px;
    font-weight: 400;
  }
  .filter-chips:empty {
    display: none;
  }
  .filter-chip {
    display: flex;
    align-items: center;
    gap: 6px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #E5E7EB;
    border-radius: 9999px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    padding: 4px 8px 4px 12px;
    color: #374151;
    white-space: nowrap;
    max-width: 200px;
    font-size: 11px;
    animation: slideInFromRight 0.3s ease-out;
    transform-origin: right center;
    /* iOS hardware acceleration fixes */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    will-change: transform, opacity;
    -webkit-perspective: 1000;
    perspective: 1000;
  }
  
  @keyframes slideInFromRight {
    from {
      opacity: 0;
      -webkit-transform: translateX(100%) translateZ(0);
      transform: translateX(100%) translateZ(0);
    }
    to {
      opacity: 1;
      -webkit-transform: translateX(0) translateZ(0);
      transform: translateX(0) translateZ(0);
    }
  }
  
  @-webkit-keyframes slideInFromRight {
    from {
      opacity: 0;
      -webkit-transform: translateX(100%) translateZ(0);
      transform: translateX(100%) translateZ(0);
    }
    to {
      opacity: 1;
      -webkit-transform: translateX(0) translateZ(0);
      transform: translateX(0) translateZ(0);
    }
  }
  
  @keyframes slideOutToRight {
    from {
      opacity: 1;
      -webkit-transform: translateX(0) translateZ(0);
      transform: translateX(0) translateZ(0);
    }
    to {
      opacity: 0;
      -webkit-transform: translateX(100%) translateZ(0);
      transform: translateX(100%) translateZ(0);
    }
  }
  
  @-webkit-keyframes slideOutToRight {
    from {
      opacity: 1;
      -webkit-transform: translateX(0) translateZ(0);
      transform: translateX(0) translateZ(0);
    }
    to {
      opacity: 0;
      -webkit-transform: translateX(100%) translateZ(0);
      transform: translateX(100%) translateZ(0);
    }
  }
  
  .filter-chip.slide-out {
    animation: slideOutToRight 0.3s ease-in forwards;
    -webkit-animation: slideOutToRight 0.3s ease-in forwards;
  }
  .filter-chip-label {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .filter-chip-close {
    background: none;
    border: none;
    color: #6B7280;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    padding: 0;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: color 0.2s;
  }
  .filter-chip-close:hover {
    color: #374151;
  }
  .filter-chip-clear-all {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 4px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #E5E7EB;
    border-radius: 9999px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    padding: 4px 8px 4px 12px;
    color: #374151;
    white-space: nowrap;
    max-width: 200px;
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
    font-size: 11px;
    /* iOS hardware acceleration fixes */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    will-change: transform;
    -webkit-perspective: 1000;
    perspective: 1000;
  }
  .filter-chip-clear-all span:first-child {
    flex: 1;
    text-align: left;
  }
  .filter-chip-clear-all.filter-chip-new {
    animation: slideInFromRight 0.3s ease-out;
    transform-origin: right center;
  }
  .filter-chip-clear-all:hover {
    background: rgba(249, 250, 251, 0.95);
    border-color: #D1D5DB;
  }
  .filter-chip-clear-all:active {
    background: rgba(243, 244, 246, 0.95);
  }
  .filter-chip-clear-all-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 18px;
    flex-shrink: 0;
    font-size: 18px;
    line-height: 1;
    color: #374151;
    font-weight: 400;
  }
  .filter-chip-clear-all.slide-out {
    animation: slideOutToRight 0.3s ease-in forwards;
    -webkit-animation: slideOutToRight 0.3s ease-in forwards;
  }
  @media (max-width: 700px) {
    .filter-chips {
      top: 58px;
      right: 8px;
      gap: 5px;
    }
    .filter-chip {
      padding: 3px 6px 3px 10px;
      font-size: 10px;
      max-width: 180px;
    }
    .filter-chip-clear-all {
      padding: 3px 6px 3px 10px;
      font-size: 10px;
      max-width: 180px;
      gap: 4px;
    }
    .filter-chip-clear-all-icon {
      width: 16px;
      height: 16px;
      font-size: 16px;
    }
  }
    /* Saved Colleges Overlay */
    .saved-colleges-overlay {
      position: absolute;
      top: 0;
      right: 0;
      width: 400px;
      height: 100%;
      background: linear-gradient(180deg,#ffffff 0%,#fefefe 120px,#f3f6ff 100%);
      box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
      z-index: 9000;
      display: none;
      flex-direction: column;
      font-family: Inter, sans-serif;
    }
    .saved-colleges-overlay.active {
      display: flex;
    }
    .saved-overlay-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px;
      border-bottom: 1px solid #E5E7EB;
      flex-shrink: 0;
      background: #f8fafc;
    }
    .saved-overlay-title-section {
      flex: 1;
    }
    .saved-overlay-title {
      font-size: 20px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 4px 0;
    }
    .saved-overlay-subtitle {
      font-size: 13px;
      color: #64748b;
      margin: 0;
    }
    .saved-overlay-close {
      background: none;
      border: none;
      font-size: 28px;
      color: #94a3b8;
      cursor: pointer;
      line-height: 1;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
      flex-shrink: 0;
    }
    .saved-overlay-close:hover {
      color: #64748b;
    }
    .saved-overlay-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    .saved-overlay-section {
      margin-bottom: 32px;
    }
    .saved-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .saved-section-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin: 0 0 12px 0;
    }
    .saved-section-header .saved-section-title {
      margin: 0;
      flex: 1;
    }
    .saved-search-wrapper {
      position: relative;
    }
    .saved-search-wrapper::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: -12px;
      height: 20px;
      background: linear-gradient(180deg, rgba(255,255,255,0), rgba(15,23,42,0.12));
      pointer-events: none;
      z-index: 2;
      border-bottom-left-radius: 12px;
      border-bottom-right-radius: 12px;
    }
    .saved-search-input {
      width: 100%;
      padding: 12px 16px 12px 44px;
      border: 2px solid #E5E7EB;
      border-radius: 12px;
      font-size: 14px;
      font-family: Inter, sans-serif;
      color: #0f172a;
      background: #fff;
      box-sizing: border-box;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.06);
    }
    .saved-search-wrapper::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: -8px;
      height: 12px;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(15,23,42,0.08), rgba(15,23,42,0));
      opacity: 0.8;
    }
    .saved-search-input:hover {
      border-color: #CBD5E1;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
    }
    .saved-search-input:focus {
      outline: none;
      border-color: #2563eb;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1), 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
      transform: translateY(-1px);
    }
    .saved-search-input::placeholder {
      color: #94a3b8;
    }
    .saved-search-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      color: #94a3b8;
      pointer-events: none;
      z-index: 1;
    }
    .saved-search-results {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      max-height: 300px;
      overflow-y: auto;
      padding-bottom: 12px;
      z-index: 10;
      display: none;
    }
    .saved-search-results.active {
      display: block;
    }
    .saved-search-result-item {
      padding: 12px;
      border-bottom: 1px solid #F3F4F6;
      cursor: pointer;
      transition: background 0.15s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .saved-search-result-item:hover {
      background: #F9FAFB;
    }
    .saved-search-result-item:last-child {
      border-bottom: none;
    }
    .saved-search-result-info {
      flex: 1;
      min-width: 0;
    }
    .saved-search-result-name {
      font-weight: 600;
      font-size: 13px;
      color: #0f172a;
      margin-bottom: 2px;
    }
    .saved-search-result-details {
      font-size: 12px;
      color: #64748b;
    }
    .saved-search-result-save-btn {
      flex-shrink: 0;
      margin-left: 12px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 9999px;
      border: 1px solid #E5E7EB;
      background: #f1f5f9;
      color: #64748b;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
      white-space: nowrap;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .saved-search-result-save-btn span {
      display: inline-block;
      width: 12px;
      text-align: center;
      line-height: 1;
    }
    .saved-search-result-save-btn:hover {
      background: #e2e8f0;
      color: #475569;
    }
    .saved-search-result-save-btn.saved {
      background: #dcfce7;
      border-color: #86efac;
      color: #15803d;
    }
    .saved-search-result-save-btn.saved:hover {
      background: #bbf7d0;
    }
    .saved-colleges-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .saved-college-item {
      padding: 12px;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      background: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: box-shadow 0.2s, opacity 0.25s ease, transform 0.25s ease, max-height 0.25s ease, margin 0.25s ease, padding 0.25s ease;
      max-height: 200px;
    }
    .saved-college-item:hover {
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    .saved-college-item.removing {
      opacity: 0;
      transform: translateX(12px);
      max-height: 0;
      margin-top: 0;
      margin-bottom: 0;
      padding-top: 0;
      padding-bottom: 0;
    }
    .saved-college-info {
      flex: 1;
      min-width: 0;
    }
    .saved-college-name {
      font-weight: 600;
      font-size: 14px;
      color: #0f172a;
      margin-bottom: 2px;
    }
    .saved-college-details {
      font-size: 12px;
      color: #64748b;
    }
    .saved-college-unsave-btn {
      flex-shrink: 0;
      margin-left: 12px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 9999px;
      border: 1px solid #86efac;
      background: #dcfce7;
      color: #15803d;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
      white-space: nowrap;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .saved-college-unsave-btn:hover {
      background: #bbf7d0;
    }
    .saved-empty-state {
      padding: 40px 20px;
      text-align: center;
      color: #64748b;
    }
    .saved-empty-state-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 8px;
    }
    .saved-empty-state-text {
      font-size: 13px;
      line-height: 1.5;
    }
    .unsave-all-btn {
      padding: 6px 12px;
      font-size: 14px;
      font-weight: 500;
      color: #dc2626;
      background: transparent;
      border: 1px solid #E5E7EB;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .unsave-all-btn:hover {
      background: #FEF2F2;
      border-color: #FCA5A5;
    }
    .saved-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .saved-modal-overlay.active {
      display: flex;
    }
    .saved-modal {
      background: #fff;
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: calc(100% - 40px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }
    .saved-modal-title {
      font-size: 16px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 20px 0;
    }
    .saved-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    .saved-modal-btn {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid #E5E7EB;
    }
    .saved-modal-cancel {
      background: #fff;
      color: #374151;
    }
    .saved-modal-cancel:hover {
      background: #F9FAFB;
    }
    .saved-modal-confirm {
      background: #dc2626;
      color: #fff;
      border-color: #dc2626;
    }
    .saved-modal-confirm:hover {
      background: #b91c1c;
      border-color: #b91c1c;
    }
    @media (max-width: 700px) {
      .saved-colleges-overlay {
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      .saved-modal {
        margin: 20px;
      }
    }
  </style>
</head>
<body>
<!-- Shared map banner -->
<div class="shared-map-banner" id="shared-map-banner">
  <div class="shared-map-banner-message">You're viewing a shared map of saved colleges. Your own saved list won't be changed.</div>
  <button class="shared-map-banner-close" id="shared-map-banner-close" aria-label="Close banner" type="button">×</button>
</div>
<div class="main-container">
<header class="app-header">
    <div class="header-logo-tagline">
  <!-- Logo optimization: Ideal source image size ≈ 280×70px (4:1 ratio) for header usage at 70px height on desktop, 56px on mobile -->
  <!-- Using width/height attributes for layout stability and to prevent layout shift during load -->
  <div style="display: flex; align-items: center; position: relative;">
    <img src="us-college-map-logo.png" alt="U.S. College Map interactive tool for exploring colleges by type, region, and location" class="site-logo" width="280" height="70" style="position: relative; z-index: 1;">
    <span class="beta-badge" style="position: relative; z-index: 10000;">BETA</span>
  </div>
      <h1 class="sr-only">U.S. College Map — Find Colleges Near You, Along Your Route, and Save Your List</h1>
      <p class="tagline">Planning campus visits? U.S. College Map helps you explore schools by type, region, or ranking,  and easily find colleges near any location or along any trip.</p>
    </div>
</header>

  <main>
  <nav class="container controls" aria-label="College search filters">
    <div class="row row-filters">
      <div class="pill"><label for="type">Type</label><select id="type"><option value="">All college types</option></select></div>
      <div class="pill"><label for="region">Region</label><select id="region"><option value="">All regions</option></select></div>
      <div class="pill"><label for="state">State</label><select id="state" autocomplete="one-time-code" data-prevent-autofill="true"><option value="">All states</option></select></div>
      <div class="pill pill-ranking"><label for="ranking">Ranking</label><select id="ranking"><option value="">School Ranking</option></select><div class="ranking-new-chat-bubble" id="ranking-new-chat-bubble">NEW!</div><button class="ranking-info-icon" id="ranking-info-btn" aria-label="Ranking information" type="button">i</button><div class="ranking-tooltip" id="ranking-tooltip" role="tooltip"><div class="ranking-tooltip-header"><div class="ranking-tooltip-body">School ranking is for reference only*. Some ranking tiers include extra schools to reflect variations across major lists.</div></div><button class="ranking-tooltip-close" id="ranking-tooltip-close" aria-label="Close" type="button">x</button></div></div>
      <!-- College name search temporarily hidden - functionality preserved for future use -->
      <div class="pill pill-search" style="display: none !important;"><label for="search">Search</label><input id="search" placeholder="Enter college name" /></div>
  </div>
    <div class="row row-search" style="display: none !important;">
      <div class="pill"><label for="search-mobile">Search</label><input id="search-mobile" placeholder="Enter college name" /></div>
  </div>
    <div class="row row-ranking">
      <!-- Ranking will be moved here on mobile via JavaScript -->
  </div>
    
    <details class="filter-section">
      <summary>Find Colleges Nearby</summary>
      <div class="filter-section-content">
        <div class="row row-nearby">
          <div class="pill address-autocomplete"><label for="address">Address</label><input id="address" placeholder="Enter a location or home address" autocomplete="new-password" name="search-address" data-autofill-guard="true" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-autocomplete="list" aria-expanded="false" aria-controls="addressSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="addressSuggestions" role="listbox" aria-label="Address suggestions"></div></div>
    <div class="pill"><label for="radius">Radius</label><input id="radius" type="number" min="0" step="10" value="30" style="width:90px"><select id="units"><option value="mi" selected>mi</option><option value="km">km</option></select><button id="geocodeBtn">Locate</button><button id="clearRadius" style="background:transparent;color:#0f172a;border:1px solid #e2e8f0;">Clear</button></div>
</div>
</div>
    </details>
    
    <details class="filter-section">
      <summary>Find Colleges Along a Route</summary>
      <div class="filter-section-content">
        <div class="row row-route">
          <div class="pill address-autocomplete"><label for="routeStart">From</label><input id="routeStart" placeholder="Enter starting address" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-autocomplete="list" aria-expanded="false" aria-controls="routeStartSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="routeStartSuggestions" role="listbox" aria-label="From address suggestions"></div></div>
          <div class="pill address-autocomplete"><label for="routeEnd">To</label><input id="routeEnd" placeholder="Enter destination address" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-autocomplete="list" aria-expanded="false" aria-controls="routeEndSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="routeEndSuggestions" role="listbox" aria-label="To address suggestions"></div></div>
          <div class="pill"><label for="routeMaxDistance">Within</label><input id="routeMaxDistance" type="number" min="0" step="10" value="30" style="width:90px"><select id="routeUnits"><option value="mi" selected>mi</option><option value="km">km</option></select><button id="findRouteBtn">Explore</button><button id="clearRoute" style="background:transparent;color:#0f172a;border:1px solid #e2e8f0;">Clear</button></div>
        </div>
      </div>
    </details>
  </nav>
  <div class="route-hint-bubble" id="route-hint-bubble">
      <div class="route-hint-bubble-content">
        <span class="route-hint-bubble-text">Tap to explore</span>
      </div>
    </div>
  <section id="map" aria-label="Interactive college map">
    <!-- Smart map hint popups -->
    <div class="map-hint-bubble" id="hint-too-many-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">🎯</span>
        <div class="map-hint-bubble-title">Too many colleges shown?</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('tooMany')">×</button>
      </div>
      <div class="map-hint-bubble-body">Filter by Type above or save your favorite schools to your list to focus your map.</div>
    </div>
    <div class="map-hint-bubble" id="hint-no-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">🔍</span>
        <div class="map-hint-bubble-title">No colleges found?</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('noResults')">×</button>
      </div>
      <div class="map-hint-bubble-body">Your current filters may be too narrow, or none of your saved colleges fall within this location or route.</div>
    </div>
    <!-- No saved colleges notice - appears when Saved Only is toggled on with zero saved colleges -->
    <div class="map-hint-bubble" id="hint-no-saved-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">📌</span>
        <div class="map-hint-bubble-title">No saved colleges yet.</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('noSavedColleges')">×</button>
      </div>
      <div class="map-hint-bubble-body">Go to "My Saved List" or tap a college on the map and press "Save" to add a school.</div>
    </div>
    <!-- Helper tip bubble - appears once per session -->
    <div class="map-tip-bubble" id="map-tip-bubble" role="alert">
      <div class="map-tip-bubble-content">
        <span class="map-tip-bubble-icon">💡</span>
        <span class="map-tip-bubble-text">Tap a blue dot on the map to see college details or save to your list.</span>
        <button class="map-tip-bubble-close" aria-label="Dismiss tip" onclick="dismissMapTip()">×</button>
      </div>
    </div>
    <div class="legend" id="legend">Found <span id="count">0</span> schools</div>
    <!-- Saved controls overlay -->
    <div id="saved-controls" class="saved-controls">
      <div class="saved-list-section" onclick="openSavedListPanel()" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();openSavedListPanel();}" role="button" tabindex="0">
        <svg class="saved-icon" width="22" height="22" viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path fill="#64D85B" d="M128 0C74 0 32 42 32 96C32 166 128 256 128 256C128 256 224 166 224 96C224 42 182 0 128 0Z"/>
          <path fill="#FFFFFF" d="M128 32L147 86H200L159 118L175 170L128 139L81 170L97 118L56 86H109L128 32Z"/>
        </svg>
        <span class="saved-pill"><span class="saved-text">My Saved List</span></span>
      </div>
      <div class="saved-controls-divider"></div>
      <div class="saved-only-section" id="saved-only-section">
        <div class="saved-only-main" onclick="toggleSavedOnly()">
          <div class="saved-toggle" id="saved-toggle">
            <div class="saved-toggle-track">
              <div class="saved-toggle-thumb"></div>
            </div>
          </div>
          <span class="saved-text">Map Saved Only</span>
        </div>
        <div class="saved-only-divider"></div>
        <div class="saved-share-icon" id="saved-share-icon" onclick="handleSavedShareClick(event)">
          <div class="saved-share-tooltip">Share this saved map</div>
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
          </svg>
        </div>
      </div>
    </div>
    <!-- Filter chips -->
    <div id="filter-chips" class="filter-chips"></div>
    <!-- Saved Colleges Overlay -->
    <div id="saved-colleges-overlay" class="saved-colleges-overlay">
      <div class="saved-overlay-header">
        <div class="saved-overlay-title-section">
          <h2 class="saved-overlay-title">My Saved Colleges</h2>
        </div>
        <button class="saved-overlay-close" onclick="closeSavedListPanel()" aria-label="Close saved colleges panel">×</button>
      </div>
      <div class="saved-overlay-content">
        <!-- Search & Add Section -->
        <div class="saved-overlay-section">
          <h3 class="saved-section-title">Add a college to my saved list</h3>
          <div class="saved-search-wrapper">
            <svg class="saved-search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
            </svg>
            <input 
              type="text" 
              id="saved-search-input" 
              class="saved-search-input" 
              placeholder="Search by college name…"
              autocomplete="off"
            />
            <div id="saved-search-results" class="saved-search-results"></div>
          </div>
        </div>
        <!-- Saved List Section -->
        <div class="saved-overlay-section">
          <div class="saved-section-header">
            <h3 class="saved-section-title" id="saved-overlay-count">0 Colleges Saved</h3>
            <button id="unsave-all-btn" class="unsave-all-btn" onclick="confirmUnsaveAll()" style="display: none;">Unsave all</button>
          </div>
          <div id="saved-colleges-list" class="saved-colleges-list">
            <!-- Will be populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>
    <!-- Unsave All Confirmation Modal -->
    <div id="unsave-all-modal" class="saved-modal-overlay">
      <div class="saved-modal">
        <h3 class="saved-modal-title">Remove all saved colleges?</h3>
        <div class="saved-modal-actions">
          <button class="saved-modal-btn saved-modal-cancel" onclick="closeUnsaveAllModal()">Cancel</button>
          <button class="saved-modal-btn saved-modal-confirm" onclick="unsaveAllColleges()">Unsave all</button>
        </div>
      </div>
    </div>
  </section>
<div aria-label="College map powered by OpenStreetMap data" class="sr-only"></div>
  <div class="loading" id="loading">Loading colleges data...</div>
  <div class="error" id="error"></div>
  
  <section class="about-map">
    <h2 class="about-map-title">About This Map</h2>
    <div class="info-snippets" aria-label="College visit planning resources">
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Explore and find colleges by region</h2>
        <p>When you're just starting out, it helps to see the big picture. U.S. College Map lets you explore every college across the country — by state, region, or school type — so you can spot patterns, compare areas, and learn what kinds of campuses appeal to you. Tap any school to check out basic details and start building a sense of what's out there.</p>
      </div>
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Visit colleges near you or along your route</h2>
        <p>Heading out for a family trip, tournament, or vacation? Enter any address or route to see colleges nearby or along the way. You might discover schools you've never heard of but end up loving. This makes campus visits easy, low-stress, and part of the travel you're already doing — no extra planning required.</p>
      </div>
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Save colleges and plan focused visit trips</h2>
        <p>After exploring and visiting a few campuses, save your favorite schools to your list. Then switch to Saved-Only mode to see just those colleges on the map. It's perfect for planning intentional visit trips to groups of schools that are close together — whether you're flying out for a weekend or mapping out a bigger college-visit road trip.</p>
      </div>
    </div>
  </section>
  <p class="site-disclaimer">*Ranking tiers on this site are for general reference only and are not official rankings. They reflect schools that commonly appear near the top of well-known national lists but are not based on any single ranking system. Some tiers include additional schools to account for natural year-to-year differences across sources. Families and students should use these tiers as a starting point for exploration and always research colleges directly to determine personal fit.</p>
  </main>
</div>
<footer class="site-footer">© 2025 U.S. College Map</footer>

<script>
const localMode = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
const DATA_URL = localMode ? 'colleges_usa_2024.csv' : 'https://uscollegemap.org/colleges_usa_2024.csv';
const COLLEGE_CACHE_KEY = 'ucm_colleges_csv_v1';
const ROUTE_HINT_KEY = 'ucm_routeExploreHint';

// Cache DOM references for performance
const elements = {
  state: document.getElementById('state'),
  region: document.getElementById('region'),
  type: document.getElementById('type'),
  ranking: document.getElementById('ranking'),
  search: document.getElementById('search'),
  address: document.getElementById('address'),
  radius: document.getElementById('radius'),
  units: document.getElementById('units'),
  count: document.getElementById('count'),
  loading: document.getElementById('loading'),
  error: document.getElementById('error'),
  geocodeBtn: document.getElementById('geocodeBtn'),
  clearRadius: document.getElementById('clearRadius'),
  addressSuggestions: document.getElementById('addressSuggestions'),
  routeStart: document.getElementById('routeStart'),
  routeEnd: document.getElementById('routeEnd'),
  routeMaxDistance: document.getElementById('routeMaxDistance'),
  routeUnits: document.getElementById('routeUnits'),
  clearRoute: document.getElementById('clearRoute'),
  routeStartSuggestions: document.getElementById('routeStartSuggestions'),
  routeEndSuggestions: document.getElementById('routeEndSuggestions'),
  findRouteBtn: document.getElementById('findRouteBtn')
};

function guardIOSAutofill(input) {
  if (!input || input.dataset.iosAutofillGuarded === 'true') {
    return;
  }
  input.dataset.iosAutofillGuarded = 'true';
  const originalInputMode = input.getAttribute('inputmode') || '';
  if (originalInputMode) {
    input.dataset.originalInputMode = originalInputMode;
  }
  // Don't set readonly - it prevents keyboard from appearing on iOS
  // Instead, use inputmode='none' initially, then change to 'search' on interaction
  input.setAttribute('inputmode', 'none');
  
  // Unified keyboard enable function - fires on EVERY interaction
  const enableKeyboard = (event) => {
    // Change inputmode to allow keyboard - set synchronously BEFORE browser processes
    const restoredMode = input.dataset.originalInputMode || 'search';
    // Set both attribute and property for maximum compatibility
    input.setAttribute('inputmode', restoredMode);
    if (input.inputMode !== undefined) {
      input.inputMode = restoredMode;
    }
    // Force immediate reflow to ensure inputmode change is processed
    void input.offsetHeight;
    
    // For touch/pointer events, ensure focus happens to trigger keyboard
    // Use requestAnimationFrame for better timing with iOS keyboard
    if (event && (event.type === 'touchstart' || event.type === 'pointerdown' || event.type === 'mousedown' || event.type === 'click')) {
      // Prevent default only if needed to avoid interfering with autocomplete
      if (event.type === 'touchstart' || event.type === 'pointerdown') {
        // Don't prevent default - let normal focus behavior happen
      }
      // Use requestAnimationFrame to ensure inputmode is set before focus
      requestAnimationFrame(() => {
        if (document.activeElement !== input) {
          input.focus({ preventScroll: true });
        }
      });
    }
  };
  
  // Attach listeners in capture phase to fire early - these stay active for EVERY tap
  // Use passive: false only where needed to allow preventDefault if necessary
  input.addEventListener('touchstart', enableKeyboard, { passive: true, capture: true });
  input.addEventListener('pointerdown', enableKeyboard, { passive: true, capture: true });
  input.addEventListener('mousedown', enableKeyboard, { passive: true, capture: true });
  input.addEventListener('focus', enableKeyboard, { capture: true });
  input.addEventListener('click', enableKeyboard, { passive: true, capture: true });
  
  // Set autofill prevention attributes (keep existing autocomplete if set)
  if (!input.getAttribute('autocomplete') || input.getAttribute('autocomplete') === 'off') {
    input.setAttribute('autocomplete', 'new-password');
  }
  input.setAttribute('data-lpignore', 'true'); // LastPass ignore
  input.setAttribute('data-form-type', 'other'); // Prevent form autofill
}

// Apply autofill guard immediately if elements exist, or wait for DOMContentLoaded
function applyAutofillGuards() {
  const ua = navigator.userAgent || '';
  const isIOS =
    /iPad|iPhone|iPod/.test(ua) ||
    (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  if (isIOS) {
    document.documentElement.classList.add('ios-device');
    // Apply guards to address inputs on iOS only to prevent autofill
    const inputsToGuard = [elements.address, elements.routeStart, elements.routeEnd].filter(Boolean);
    inputsToGuard.forEach(guardIOSAutofill);
  }
  // On non-iOS devices (Android, etc.), don't apply the guard to allow normal keyboard behavior
}

// Try to apply guards immediately if elements are available
if (elements.address || elements.routeStart || elements.routeEnd) {
  applyAutofillGuards();
}

document.addEventListener('DOMContentLoaded', () => {
  // Parse shared view URL if present
  parseSharedViewURL();
  
  // If CSV has already loaded (from cache) and we're in shared view, apply shared state now
  if (isSharedView && window.sharedViewState && colleges && colleges.length > 0) {
    console.log('[DOMContentLoaded] CSV already loaded, applying shared view state now');
    applySharedViewState();
  }
  
  // Initialize shared view banner
  initSharedViewBanner();
  
  // Initialize saved search
  initSavedSearch();
  
  // Apply autofill guards again in case elements weren't ready before
  applyAutofillGuards();
  
  // Position ranking dropdown on DOM ready (will be called again after it's defined and after CSV loads)
  setTimeout(() => {
    if (typeof positionRankingDropdown === 'function') {
      positionRankingDropdown();
    }
  }, 50);
  
  // Update dropdown placeholders on DOM ready (will be called again after CSV loads)
  // Note: updateDropdownPlaceholders function is defined later, but will be called after CSV loads
  
  const ua = navigator.userAgent || '';
  const isIOS =
    /iPad|iPhone|iPod/.test(ua) ||
    (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  // Note: iOS-specific placeholder override removed - now handled by updateDropdownPlaceholders()
  // which is called after CSV loads and dropdowns are refreshed
  if (window.innerWidth <= 700) {
    addHeaderInteractionListeners();
  }
  setupRouteHint();
  
  // Ensure map interactions are enabled on initial load
  // Wait a bit for map to be fully ready
  setTimeout(() => {
    const savedOverlay = document.getElementById('saved-colleges-overlay');
    if (!savedOverlay || !savedOverlay.classList.contains('active')) {
      // If overlay is not open, ensure map is interactive
      if (map && mapInteractionLock.locked) {
        resumeMapInteractions();
      } else if (map) {
        // Explicitly enable all interactions to ensure map is interactive
        if (map.dragging) map.dragging.enable();
        if (map.scrollWheelZoom) map.scrollWheelZoom.enable();
        if (map.doubleClickZoom) map.doubleClickZoom.enable();
        if (map.boxZoom) map.boxZoom.enable();
        if (map.keyboard) map.keyboard.enable();
        if (map.touchZoom) map.touchZoom.enable();
        if (map.tap && typeof map.tap.enable === 'function') map.tap.enable();
      }
    }
  }, 300);
});

if (elements.addressSuggestions) elements.addressSuggestions.dataset.field = 'address';
if (elements.routeStartSuggestions) elements.routeStartSuggestions.dataset.field = 'routeStart';
if (elements.routeEndSuggestions) elements.routeEndSuggestions.dataset.field = 'routeEnd';

let addressAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

// Route autocomplete objects
let routeStartAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

let routeEndAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

let mobileHeaderCollapsed = false;
let headerListenersAttached = false;
const headerInteractionEvents = ['pointerdown','touchstart','keydown'];

function getHeaderElement() {
  return document.querySelector('.app-header');
}

function collapseMobileHeader() {
  const header = getHeaderElement();
  if (!header || window.innerWidth > 700 || mobileHeaderCollapsed) return;
  header.classList.add('collapsed');
  mobileHeaderCollapsed = true;
  removeHeaderInteractionListeners();
}

function handleHeaderFirstInteraction(event) {
  if (mobileHeaderCollapsed || window.innerWidth > 700) return;
  const header = getHeaderElement();
  if (!header) return;
  if (header.contains(event.target)) return;
  collapseMobileHeader();
}

function addHeaderInteractionListeners() {
  if (headerListenersAttached || window.innerWidth > 700 || mobileHeaderCollapsed) return;
  headerInteractionEvents.forEach(evt => document.addEventListener(evt, handleHeaderFirstInteraction, true));
  headerListenersAttached = true;
}

function removeHeaderInteractionListeners() {
  if (!headerListenersAttached) return;
  headerInteractionEvents.forEach(evt => document.removeEventListener(evt, handleHeaderFirstInteraction, true));
  headerListenersAttached = false;
}

function resetHeaderForDesktop() {
  const header = getHeaderElement();
  if (header) header.classList.remove('collapsed');
  mobileHeaderCollapsed = false;
  removeHeaderInteractionListeners();
  if (window.innerWidth <= 700) {
    addHeaderInteractionListeners();
  }
}

const americasBounds = L.latLngBounds([[-60,-180],[85,-30]]);
const US_MAINLAND_VIEW = L.latLngBounds([[18,-130],[55,-60]]);
const INITIAL_DESKTOP_VIEW = { center: { lat: 39.5, lng: -98.35 }, zoom: 4 };
const INITIAL_MOBILE_VIEW = { center: { lat: 39.5, lng: -98.35 }, zoom: 3.5 };
function getInitialNearbyView() {
  return window.innerWidth <= 700 ? INITIAL_MOBILE_VIEW : INITIAL_DESKTOP_VIEW;
}
const mapViewState = {
  nearby: { ...getInitialNearbyView() },
  route: null
};
const map = L.map('map',{maxBounds:americasBounds,maxBoundsViscosity:1}).setView(
  [mapViewState.nearby.center.lat, mapViewState.nearby.center.lng],
  mapViewState.nearby.zoom
);
map.whenReady(() => {
  setTimeout(() => {
    map.invalidateSize();
    if (!home && !lastNearbyFilters && mapViewState.nearby) {
      map.setView([mapViewState.nearby.center.lat, mapViewState.nearby.center.lng], mapViewState.nearby.zoom);
      captureMapView('nearby');
    }
    // Ensure map interactions are enabled on initial load
    // Check if saved overlay is not open (if it is, interactions should be frozen)
    const savedOverlay = document.getElementById('saved-colleges-overlay');
    if (!savedOverlay || !savedOverlay.classList.contains('active')) {
      // If overlay is not open, ensure map is interactive
      if (mapInteractionLock.locked) {
        resumeMapInteractions();
      } else {
        // Explicitly enable all interactions to ensure map is interactive
        if (map.dragging) map.dragging.enable();
        if (map.scrollWheelZoom) map.scrollWheelZoom.enable();
        if (map.doubleClickZoom) map.doubleClickZoom.enable();
        if (map.boxZoom) map.boxZoom.enable();
        if (map.keyboard) map.keyboard.enable();
        if (map.touchZoom) map.touchZoom.enable();
        if (map.tap && typeof map.tap.enable === 'function') map.tap.enable();
      }
    }
  }, 150);
});
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap contributors',attributionControl:true}).addTo(map);

const mapInteractionLock = {
  locked: false,
  state: {}
};

function freezeMapInteractions() {
  if (!map || mapInteractionLock.locked) return;
  const state = mapInteractionLock.state = {};
  if (map.dragging) {
    state.dragging = map.dragging.enabled();
    map.dragging.disable();
  }
  if (map.scrollWheelZoom) {
    state.scrollWheelZoom = map.scrollWheelZoom.enabled();
    map.scrollWheelZoom.disable();
  }
  if (map.doubleClickZoom) {
    state.doubleClickZoom = map.doubleClickZoom.enabled();
    map.doubleClickZoom.disable();
  }
  if (map.boxZoom) {
    state.boxZoom = map.boxZoom.enabled();
    map.boxZoom.disable();
  }
  if (map.keyboard) {
    state.keyboard = map.keyboard.enabled();
    map.keyboard.disable();
  }
  if (map.touchZoom) {
    state.touchZoom = map.touchZoom.enabled();
    map.touchZoom.disable();
  }
  if (map.tap && typeof map.tap.enabled === 'function') {
    state.tap = map.tap.enabled();
    map.tap.disable();
  }
  mapInteractionLock.locked = true;
}

function resumeMapInteractions() {
  if (!map || !mapInteractionLock.locked) return;
  const state = mapInteractionLock.state || {};
  if (state.dragging && map.dragging) map.dragging.enable();
  if (state.scrollWheelZoom && map.scrollWheelZoom) map.scrollWheelZoom.enable();
  if (state.doubleClickZoom && map.doubleClickZoom) map.doubleClickZoom.enable();
  if (state.boxZoom && map.boxZoom) map.boxZoom.enable();
  if (state.keyboard && map.keyboard) map.keyboard.enable();
  if (state.touchZoom && map.touchZoom) map.touchZoom.enable();
  if (state.tap && map.tap && typeof map.tap.enable === 'function') map.tap.enable();
  mapInteractionLock.locked = false;
  mapInteractionLock.state = {};
}

function clampBoundsToMainland(bounds) {
  if (!bounds || !bounds.isValid()) return US_MAINLAND_VIEW;
  const south = bounds.getSouth();
  const west = bounds.getWest();
  const north = bounds.getNorth();
  const east = bounds.getEast();
  const needsClamp =
    south < US_MAINLAND_VIEW.getSouth() ||
    west < US_MAINLAND_VIEW.getWest() ||
    north > US_MAINLAND_VIEW.getNorth() ||
    east > US_MAINLAND_VIEW.getEast();
  if (!needsClamp) {
    return bounds;
  }
  const clampedSouth = Math.max(south, US_MAINLAND_VIEW.getSouth());
  const clampedWest = Math.max(west, US_MAINLAND_VIEW.getWest());
  const clampedNorth = Math.min(north, US_MAINLAND_VIEW.getNorth());
  const clampedEast = Math.min(east, US_MAINLAND_VIEW.getEast());
  const clamped = L.latLngBounds(
    L.latLng(clampedSouth, clampedWest),
    L.latLng(clampedNorth, clampedEast)
  );
  return clamped.isValid() ? clamped : US_MAINLAND_VIEW;
}

const markersLayer = L.layerGroup().addTo(map);

const homeLayer = L.layerGroup().addTo(map);
const radiusLayer = L.layerGroup().addTo(map);
const routeLayer = L.layerGroup().addTo(map);

// Store references to route polylines for dynamic styling
let routeOutlinePolyline = null; // Navy outline
let routeMainPolyline = null; // Royal blue main line

// Device detection for dynamic marker sizing
function detectDeviceType() {
  const width = window.innerWidth;
  const ua = navigator.userAgent || '';
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  
  // iPad detection (including iPad Pro)
  const isIPad = /iPad/.test(ua) || (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  // Mobile phones (small screens with touch)
  if (isTouchDevice && width <= 768 && !isIPad) {
    return 'mobile';
  }
  
  // Tablets/iPad (medium screens with touch)
  if (isTouchDevice && (width <= 1024 || isIPad)) {
    return 'tablet';
  }
  
  // Desktop (everything else)
  return 'desktop';
}

// Calculate marker radius based on zoom level and device type
function calculateMarkerRadius(zoom, deviceType) {
  if (deviceType === 'desktop') {
    return 5; // Always radius 5 for desktop
  }
  
  if (deviceType === 'mobile') {
    // Mobile: Low zoom (0-5) → 4-5, Medium (6-9) → 6-8, High (10+) → 9-10, cap at 10
    if (zoom <= 5) {
      return 4 + (zoom / 5); // 4 to 5 (linear interpolation)
    } else if (zoom <= 9) {
      return 6 + ((zoom - 5) / 4) * 2; // 6 to 8 (linear interpolation)
    } else {
      // High zoom: 9 to 10 (capped), reaching 10 around zoom 11-12
      return Math.min(9 + (zoom - 9) * 0.5, 10); // 9 to 10 (capped at 10)
    }
  }
  
  if (deviceType === 'tablet') {
    // iPad: Same sizing as mobile for better visibility - Low zoom (0-5) → 4-5, Medium (6-9) → 6-8, High (10+) → 9-10, cap at 10
    if (zoom <= 5) {
      return 4 + (zoom / 5); // 4 to 5 (linear interpolation)
    } else if (zoom <= 9) {
      return 6 + ((zoom - 5) / 4) * 2; // 6 to 8 (linear interpolation)
    } else {
      // High zoom: 9 to 10 (capped), reaching 10 around zoom 11-12
      return Math.min(9 + (zoom - 9) * 0.5, 10); // 9 to 10 (capped at 10)
    }
  }
  
  return 5; // Fallback to desktop size
}

// Calculate route line weights and opacity based on zoom level
// Low zoom: thinner (2-3), Medium: default (4), High: slightly thicker (4-5)
// Opacity: lighter at low zoom, stronger at high zoom
function calculateRouteLineWeights(zoom) {
  let mainOpacity, outlineOpacity;
  
  // Opacity mapping: lighter at low zoom, stronger at high zoom
  if (zoom <= 5) {
    mainOpacity = 0.6;
    outlineOpacity = 0.7; // Slightly higher for ribbon effect
  } else if (zoom <= 7) {
    mainOpacity = 0.75;
    outlineOpacity = 0.85; // Slightly higher for ribbon effect
  } else if (zoom <= 10) {
    mainOpacity = 0.9;
    outlineOpacity = 0.95; // Slightly higher for ribbon effect
  } else {
    mainOpacity = 1.0;
    outlineOpacity = 1.0; // Full opacity at high zoom
  }
  
  // Weight mapping: thinner at low zoom, thicker at high zoom
  if (zoom <= 5) {
    // Low zoom (far out): thinner and lighter
    return {
      outlineWeight: 3,
      mainWeight: 2,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  } else if (zoom <= 9) {
    // Medium zoom (normal trip-planning view): default
    return {
      outlineWeight: 5,
      mainWeight: 4,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  } else {
    // High zoom (zoomed in close): slightly thicker but subtle
    return {
      outlineWeight: 6,
      mainWeight: 5,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  }
}

// Get current marker radius based on current zoom and device
function getCurrentMarkerRadius() {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  return calculateMarkerRadius(zoom, deviceType);
}

// Calculate saved icon size based on zoom level and device type
// Maintains desktop ratio (2.4×) to blue dot diameter, with specific caps for mobile/iPad
function calculateSavedIconSize(zoom, deviceType) {
  if (deviceType === 'desktop') {
    return { width: 24, height: 30 }; // Desktop: unchanged
  }
  
  // Get current blue dot radius to maintain proportional ratio
  const blueDotRadius = calculateMarkerRadius(zoom, deviceType);
  const blueDotDiameter = blueDotRadius * 2;
  
  // Calculate proportional size using desktop ratio (24px icon / 10px blue dot diameter = 2.4×)
  // This ensures saved icons are proportionally the same size relative to blue dots on all devices
  let targetWidth = blueDotDiameter * 2.4;
  
  if (deviceType === 'mobile') {
    // Mobile: scale from ~20px (low zoom) to max 28px (high zoom cap)
    const minWidth = 20;
    const maxWidth = 28;
    targetWidth = Math.max(minWidth, Math.min(targetWidth, maxWidth));
  } else if (deviceType === 'tablet') {
    // iPad: same sizing as mobile - scale from ~20px (low zoom) to max 28px (high zoom cap)
    const minWidth = 20;
    const maxWidth = 28;
    targetWidth = Math.max(minWidth, Math.min(targetWidth, maxWidth));
  }
  
  // Maintain aspect ratio (24:30 = 0.8)
  const height = targetWidth * (30 / 24);
  
  return { width: Math.round(targetWidth), height: Math.round(height) };
}

// Get current saved icon size based on current zoom and device
function getCurrentSavedIconSize() {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  return calculateSavedIconSize(zoom, deviceType);
}

// Create a green saved icon with dynamic sizing
function createGreenSavedIcon(size) {
  const { width, height } = size || getCurrentSavedIconSize();
  return L.icon({
    iconUrl: 'data:image/svg+xml;base64,' + btoa(greenSavedPinSvg),
    iconSize: [width, height],
    iconAnchor: [width / 2, height],
    popupAnchor: [0, -height]
  });
}
const ROUTE_START_PIN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><circle cx="9" cy="9" r="4" fill="#ffffff" stroke="#111827" stroke-width="2"/></svg>';
const ROUTE_END_PIN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
const ROUTE_START_PIN_ICON = 'data:image/svg+xml;base64,' + btoa(ROUTE_START_PIN_SVG);
const ROUTE_END_PIN_ICON = 'data:image/svg+xml;base64,' + btoa(ROUTE_END_PIN_SVG);
let colleges = [], home = null;
// Shared view state (temporary, in-memory only)
let sharedViewIds = null;
let isSharedView = false;
// Saved-only mode (declared early so it can be set before CSV loads)
let savedOnlyMode = false;

// Parse shared view URL immediately (before DOMContentLoaded) to set savedOnlyMode early
// This ensures savedOnlyMode is set before any rendering happens
if (typeof URLSearchParams !== 'undefined') {
  const params = new URLSearchParams(window.location.search);
  const view = params.get('view');
  if (view === 'savedshare') {
    const collegesParam = params.get('colleges');
    if (collegesParam) {
      // Normalize IDs to strings and trim whitespace
      sharedViewIds = new Set(collegesParam.split(',').map(id => id.trim()).filter(id => id));
      console.log('[Early init] Shared view IDs parsed:', sharedViewIds.size, 'Sample IDs:', Array.from(sharedViewIds).slice(0, 5));
    } else {
      sharedViewIds = new Set();
      console.log('[Early init] No shared college IDs in URL');
    }
    isSharedView = true;
    savedOnlyMode = true; // Set immediately to prevent initial render from showing all colleges
    
    // Also set window.sharedViewState early so handleDataLoad can use it
    const lat = parseFloat(params.get('lat'));
    const lng = parseFloat(params.get('lng'));
    const zoom = parseFloat(params.get('zoom'));
    
    window.sharedViewState = {
      center: (lat && lng) ? { lat, lng } : null,
      zoom: zoom || null,
      mode: params.get('mode') || 'explore',
      nearby: null,
      route: null
    };
    
    // Parse mode-specific data
    if (window.sharedViewState.mode === 'nearby') {
      const homeLat = parseFloat(params.get('homeLat'));
      const homeLng = parseFloat(params.get('homeLng'));
      const radius = params.get('radius');
      const units = params.get('units');
      
      if (homeLat && homeLng) {
        window.sharedViewState.nearby = {
          lat: homeLat,
          lon: homeLng,
          radius: radius || null,
          units: units || 'mi'
        };
      }
    } else if (window.sharedViewState.mode === 'route') {
      const startLat = parseFloat(params.get('startLat'));
      const startLng = parseFloat(params.get('startLng'));
      const endLat = parseFloat(params.get('endLat'));
      const endLng = parseFloat(params.get('endLng'));
      const routeRadius = params.get('routeRadius');
      const routeUnits = params.get('routeUnits');
      
      if (startLat && startLng && endLat && endLng) {
        window.sharedViewState.route = {
          start: { lat: startLat, lon: startLng },
          end: { lat: endLat, lon: endLng },
          maxDistance: routeRadius || null,
          units: routeUnits || 'mi'
        };
      }
    }
    
    console.log('[Early init] Shared view detected, savedOnlyMode set to true', { sharedViewIdsSize: sharedViewIds.size, sharedViewState: window.sharedViewState });
  }
}
function captureMapView(mode) {
  if (!mode) return;
  const center = map.getCenter();
  mapViewState[mode] = {
    center: { lat: center.lat, lng: center.lng },
    zoom: map.getZoom()
  };
}
function applySavedMapView(mode) {
  const view = mode ? mapViewState[mode] : null;
  if (view && view.center && typeof view.zoom === 'number') {
    map.setView([view.center.lat, view.center.lng], view.zoom, { animate: false });
    return true;
  }
  return false;
}
map.on('moveend', () => {
  if (activeMode === 'nearby' || activeMode === 'route') {
    captureMapView(activeMode);
  }
});

// Update marker sizes dynamically on zoom for touch devices (performance optimization)
map.on('zoomend', () => {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  
  // Update route line weights based on zoom (all devices)
  if (routeOutlinePolyline && routeMainPolyline) {
    const routeWeights = calculateRouteLineWeights(zoom);
    routeOutlinePolyline.setStyle({
      weight: routeWeights.outlineWeight,
      opacity: routeWeights.outlineOpacity
    });
    routeMainPolyline.setStyle({
      weight: routeWeights.mainWeight,
      opacity: routeWeights.mainOpacity
    });
  }
  
  // Only update marker sizes on touch devices (mobile/tablet), desktop always uses radius 5 and icon size 24x30
  if (deviceType === 'desktop') return;
  
  const newRadius = getCurrentMarkerRadius();
  const newIconSize = getCurrentSavedIconSize();
  const newSavedIcon = createGreenSavedIcon(newIconSize);
  
  // Update all marker instances without recreating them
  markersLayer.eachLayer((layer) => {
    // Update circleMarker types (blue dots)
    if (layer.setRadius && typeof layer.setRadius === 'function') {
      layer.setRadius(newRadius);
    }
    // Update saved icon markers (green pins)
    else if (layer.setIcon && typeof layer.setIcon === 'function' && layer.options && layer.options.icon) {
      // Check if this is a saved marker by checking if it has the green saved icon
      const currentIcon = layer.options.icon;
      if (currentIcon && currentIcon.options && currentIcon.options.iconUrl && 
          currentIcon.options.iconUrl.includes('data:image/svg+xml') &&
          currentIcon.options.iconUrl.includes('64D85B')) {
        // This is a saved icon marker (green pin), update its size
        layer.setIcon(newSavedIcon);
      }
    }
  });
});

window.addEventListener('resize', () => {
  if (window.innerWidth > 700) {
    resetHeaderForDesktop();
  } else if (!mobileHeaderCollapsed) {
    addHeaderInteractionListeners();
  }
});

// SavedStore: Manages saved college IDs in localStorage
const SAVED_STORAGE_KEY = 'uscm_saved_v1';
const SavedStore = (() => {
  const STORAGE_KEY = SAVED_STORAGE_KEY;
  let savedIds = new Set();
  
  // Load from localStorage on init
  function load() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed)) {
          savedIds = new Set(parsed);
        } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.saved)) {
          savedIds = new Set(parsed.saved);
        }
      }
    } catch (err) {
      console.warn('SavedStore: failed to load saved state', err);
      savedIds = new Set();
    }
  }
  
  // Save to localStorage
  function save() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(Array.from(savedIds)));
    } catch (err) {
      console.warn('SavedStore: failed to persist state', err);
    }
  }
  
  // Initialize on load
  load();
  
  return {
    isSaved(collegeId) {
      // In shared view, check sharedViewIds instead of local savedIds
      if (isSharedView && sharedViewIds) {
        // Normalize collegeId to string for consistent comparison
        const normalizedId = String(collegeId || '').trim();
        const isInShared = sharedViewIds.has(normalizedId);
        return isInShared;
      }
      return savedIds.has(collegeId);
    },
    toggle(collegeId) {
      if (!collegeId) return;
      if (savedIds.has(collegeId)) {
        savedIds.delete(collegeId);
      } else {
        savedIds.add(collegeId);
      }
      save();
      // Track save/unsave action
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_saved_used');
      }
    },
    getAll() {
      // In shared view, return shared IDs instead of local savedIds
      if (isSharedView && sharedViewIds) {
        return Array.from(sharedViewIds);
      }
      return Array.from(savedIds);
    }
  };
})();

// Parse URL for shared view
function parseSharedViewURL() {
  const params = new URLSearchParams(window.location.search);
  const view = params.get('view');
  
  if (view !== 'savedshare') {
    return false;
  }
  
  // Parse shared college IDs
  const collegesParam = params.get('colleges');
  if (collegesParam) {
    // Normalize IDs to strings and trim whitespace
    sharedViewIds = new Set(collegesParam.split(',').map(id => id.trim()).filter(id => id));
    console.log('Shared view IDs parsed:', sharedViewIds.size, 'Sample IDs:', Array.from(sharedViewIds).slice(0, 5));
  } else {
    sharedViewIds = new Set();
    console.log('No shared college IDs in URL');
  }
  
  isSharedView = true;
  console.log('Shared view enabled', { isSharedView, sharedViewIdsSize: sharedViewIds.size });
  
  // Google Analytics: Track shared map view
  if (typeof gtag !== 'undefined') {
    const mode = window.sharedViewState?.mode || 'explore';
    gtag('event', 'feature_shared_map_viewed', {
      'college_count': sharedViewIds ? sharedViewIds.size : 0,
      'mode': mode
    });
  }
  
  // Immediately set Map Saved Only to ON for shared views
  savedOnlyMode = true;
  const savedToggle = document.getElementById('saved-toggle');
  const savedControls = document.getElementById('saved-controls');
  const savedOnlySection = document.getElementById('saved-only-section');
  if (savedToggle) {
    savedToggle.classList.add('active');
  }
  if (savedControls) {
    savedControls.classList.add('saved-only-active');
  }
  if (savedOnlySection) {
    savedOnlySection.classList.add('saved-only-active');
  }
  console.log('Map Saved Only set to ON for shared view');
  
  // Show banner
  const banner = document.getElementById('shared-map-banner');
  if (banner) {
    banner.classList.add('active');
  }
  
  // Parse map center and zoom
  const lat = parseFloat(params.get('lat'));
  const lng = parseFloat(params.get('lng'));
  const zoom = parseFloat(params.get('zoom'));
  
  // Store shared view state for later use
  window.sharedViewState = {
    center: (lat && lng) ? { lat, lng } : null,
    zoom: zoom || null,
    mode: params.get('mode') || 'explore',
    nearby: null,
    route: null
  };
  
  // Parse mode-specific data
  if (window.sharedViewState.mode === 'nearby') {
    const homeLat = parseFloat(params.get('homeLat'));
    const homeLng = parseFloat(params.get('homeLng'));
    const radius = params.get('radius');
    const units = params.get('units');
    
    if (homeLat && homeLng) {
      window.sharedViewState.nearby = {
        lat: homeLat,
        lon: homeLng,
        radius: radius || null,
        units: units || 'mi'
      };
    }
  } else if (window.sharedViewState.mode === 'route') {
    const startLat = parseFloat(params.get('startLat'));
    const startLng = parseFloat(params.get('startLng'));
    const endLat = parseFloat(params.get('endLat'));
    const endLng = parseFloat(params.get('endLng'));
    const routeRadius = params.get('routeRadius');
    const routeUnits = params.get('routeUnits');
    
    if (startLat && startLng && endLat && endLng) {
      window.sharedViewState.route = {
        start: { lat: startLat, lon: startLng },
        end: { lat: endLat, lon: endLng },
        maxDistance: routeRadius || null,
        units: routeUnits || 'mi'
      };
    }
  }
  
  return true;
}

// Initialize shared view banner close handler
function initSharedViewBanner() {
  const banner = document.getElementById('shared-map-banner');
  const closeBtn = document.getElementById('shared-map-banner-close');
  
  if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      if (banner) {
        banner.classList.remove('active');
      }
    });
  }
}

// Apply shared view state to map and UI
function applySharedViewState() {
  console.log('[applySharedViewState] Called', { isSharedView, hasSharedViewState: !!window.sharedViewState, sharedViewIdsSize: sharedViewIds ? sharedViewIds.size : 'null' });
  
  if (!isSharedView || !window.sharedViewState) {
    console.log('[applySharedViewState] Returning early - shared view not active or state not available', { isSharedView, sharedViewState: window.sharedViewState });
    return;
  }
  
  const state = window.sharedViewState;
  console.log('[applySharedViewState] Applying shared view state', state);
  
  // Saved-only mode is already set in parseSharedViewURL(), but ensure UI is updated
  // (in case elements weren't ready when parseSharedViewURL() ran)
  savedOnlyMode = true;
  const savedToggle = document.getElementById('saved-toggle');
  const savedControls = document.getElementById('saved-controls');
  const savedOnlySection = document.getElementById('saved-only-section');
  if (savedToggle) {
    savedToggle.classList.add('active');
  }
  if (savedControls) {
    savedControls.classList.add('saved-only-active');
  }
  if (savedOnlySection) {
    savedOnlySection.classList.add('saved-only-active');
  }
  
  // Wait for map to be ready before applying state
  if (!map) {
    console.warn('[applySharedViewState] Map not ready, retrying...');
    setTimeout(applySharedViewState, 100);
    return;
  }
  
  console.log('[applySharedViewState] Map is ready, proceeding with state application');
  
  // Set map center and zoom
  if (state.center && state.zoom) {
    map.setView([state.center.lat, state.center.lng], state.zoom, { animate: false });
  }
  
  // Apply mode-specific state
  if (state.mode === 'nearby' && state.nearby) {
    activeMode = 'nearby';
    // Set home location for nearby mode
    home = { lat: state.nearby.lat, lon: state.nearby.lon };
    console.log('Set home location for shared view:', home);
    
    // Update nearby UI elements
    if (elements.address) {
      // Set address display (we'll need to reverse geocode or use a placeholder)
      elements.address.value = 'Shared location';
    }
    if (elements.radius && state.nearby.radius) {
      elements.radius.value = state.nearby.radius;
    }
    if (elements.units && state.nearby.units) {
      elements.units.value = state.nearby.units;
    }
    
    // Switch to nearby mode
    const nearbyDetails = document.querySelector('details[data-mode="nearby"]');
    const routeDetails = document.querySelector('details[data-mode="route"]');
    if (nearbyDetails) nearbyDetails.open = true;
    if (routeDetails) routeDetails.open = false;
    
    // Trigger nearby search after map is ready
    map.whenReady(() => {
      setTimeout(() => {
        if (home) {
          console.log('Applying nearby shared view', { home, state: state.nearby });
          // Use existing nearby search logic
          const radiusVal = parseFloat(elements.radius?.value || state.nearby.radius || '0') || 0;
          const unitsVal = elements.units?.value || state.nearby.units || 'mi';
          const radiusInMeters = unitsVal === 'mi' ? radiusVal * 1609.34 : radiusVal * 1000;
          
          // Clear and draw home location pin and radius circle
          if (homeLayer) {
            homeLayer.clearLayers();
            // Add "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([home.lat, home.lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
          }
          
          // Draw radius circle
          if (radiusLayer) {
            radiusLayer.clearLayers();
            // Draw circle even if radius is 0 (use 0.5)
            const effectiveRadius = radiusVal === 0 ? 0.5 : radiusVal;
            const effectiveRadiusInMeters = unitsVal === 'mi' ? effectiveRadius * 1609.34 : effectiveRadius * 1000;
            L.circle([home.lat, home.lon], {
              radius: effectiveRadiusInMeters,
              color: '#2563eb',
              fillColor: '#2563eb',
              fillOpacity: 0.1,
              weight: 2
            }).addTo(radiusLayer);
          }
          
          // Render colleges
          render();
        }
      }, 200);
    });
    
  } else if (state.mode === 'route' && state.route) {
    activeMode = 'route';
    route.start = state.route.start;
    route.end = state.route.end;
    
    // Update route UI elements
    if (elements.routeStart) {
      elements.routeStart.value = 'Shared start';
    }
    if (elements.routeEnd) {
      elements.routeEnd.value = 'Shared end';
    }
    if (elements.routeMaxDistance && state.route.maxDistance) {
      elements.routeMaxDistance.value = state.route.maxDistance;
    }
    if (elements.routeUnits && state.route.units) {
      elements.routeUnits.value = state.route.units;
    }
    
    // Switch to route mode
    const nearbyDetails = document.querySelector('details[data-mode="nearby"]');
    const routeDetails = document.querySelector('details[data-mode="route"]');
    if (nearbyDetails) nearbyDetails.open = false;
    if (routeDetails) routeDetails.open = true;
    
    // Store route search state so it can be re-rendered
    // Parse maxDistance - handle 0 correctly (don't use || operator as 0 is falsy)
    const maxDistanceInputStr = elements.routeMaxDistance?.value || state.route.maxDistance;
    let maxDistanceInput;
    if (maxDistanceInputStr === '' || maxDistanceInputStr === null || maxDistanceInputStr === undefined) {
      maxDistanceInput = 30;
    } else {
      maxDistanceInput = parseFloat(maxDistanceInputStr);
      if (isNaN(maxDistanceInput)) {
        maxDistanceInput = 30;
      }
    }
    // If maxDistance is 0, use 0.5 instead
    const maxDistance = maxDistanceInput === 0 ? 0.5 : maxDistanceInput;
    const units = elements.routeUnits?.value || state.route.units || 'mi';
    route.lastSearch = {
      start: route.start,
      end: route.end,
      maxDistance,
      units
    };
    
    // Trigger route search after map is ready
    map.whenReady(() => {
      setTimeout(() => {
        if (route.start && route.end) {
          console.log('Applying route shared view', { start: route.start, end: route.end });
          // Use existing route search logic
          findCollegesAlongRoute();
        }
      }, 200);
    });
  } else {
    // Explore mode - just render with saved-only filter
    console.log('[applySharedViewState] Explore mode - setting up render');
    if (!map) {
      console.warn('[applySharedViewState] Map not ready for explore mode, retrying...');
      setTimeout(applySharedViewState, 100);
      return;
    }
    
    map.whenReady(() => {
      setTimeout(() => {
        console.log('[applySharedViewState] Applying explore shared view - calling render()');
        console.log('[applySharedViewState] Before render - savedOnlyMode:', savedOnlyMode, 'sharedViewIds size:', sharedViewIds ? sharedViewIds.size : 'null');
        render();
        console.log('[applySharedViewState] After render - markers should be visible');
      }, 200);
    });
  }
}

// Active mode state: 'nearby' or 'route'
let activeMode = 'nearby';

// Track if user has actively used search controls (Locate or Find Route buttons)
let hasUsedSearchControls = false;

// Marker registry: maps college_id to Leaflet marker instance
const markersByCollegeId = {};

// Create green saved icon (pin with white star)
const greenSavedPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 256 256"><path d="M128 0C74 0 32 42 32 96C32 166 128 256 128 256C128 256 224 166 224 96C224 42 182 0 128 0Z" fill="#64D85B"/><path d="M128 32L147 86H200L159 118L175 170L128 139L81 170L97 118L56 86H109L128 32Z" fill="#FFFFFF"/></svg>';
// Default green saved icon (desktop size, used as fallback)
// Note: For dynamic sizing, use createGreenSavedIcon() instead
const greenSavedIcon = createGreenSavedIcon({ width: 24, height: 30 });

// Create blue circle icon for unsaved colleges
const blueCircleSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="4" fill="#2563eb" fill-opacity="0.7" stroke="#2563eb" stroke-width="2"/></svg>';
const blueDotIcon = L.divIcon({
  html: blueCircleSvg,
  className: 'blue-dot-marker',
  iconSize: [10, 10],
  iconAnchor: [5, 5]
});

// Helper function to create a marker with appropriate icon based on saved state
function createCollegeMarker(college, popupContent, collegeId) {
  const isSaved = collegeId && SavedStore.isSaved(collegeId);
  
  let marker;
  if (isSaved) {
    // Use green pin icon for saved colleges with dynamic sizing
    const iconSize = getCurrentSavedIconSize();
    marker = L.marker([college.lat, college.lon], {
      icon: createGreenSavedIcon(iconSize)
    });
  } else {
    // Use blue circle marker for unsaved colleges with dynamic sizing for touch devices
    const radius = getCurrentMarkerRadius();
    marker = L.circleMarker([college.lat, college.lon], {
      radius: radius,
      color: '#2563eb',
      weight: 2,
      fillOpacity: 0.7
    });
  }
  
  marker
    .bindTooltip(college.name, {permanent: false, direction: 'top'})
    .bindPopup(popupContent);
  marker.on('click', () => {
    if (marker.closeTooltip) {
      marker.closeTooltip();
    }
  });
  
  // Register marker in registry
  if (collegeId) {
    markersByCollegeId[collegeId] = marker;
  }
  
  return marker;
}

// Update popup save button visual state
// Cached references to avoid repeated DOM queries
const buttonCache = new WeakMap();

function updatePopupSaveButton(button, collegeId) {
  if (!button || !collegeId) return;
  
  // Cache DOM references to avoid repeated querySelector calls
  let cached = buttonCache.get(button);
  if (!cached) {
    cached = {
      icon: button.querySelector('.popup-save-icon'),
      label: button.querySelector('.popup-save-label')
    };
    buttonCache.set(button, cached);
  }
  
  const icon = cached.icon;
  const label = cached.label;
  const isSaved = SavedStore.isSaved(collegeId);
  
  // Update button class
  if (isSaved) {
    button.classList.add('saved');
  } else {
    button.classList.remove('saved');
  }
  
  // Update icon and label
  if (icon) {
    icon.textContent = isSaved ? '★' : '☆';
  }
  if (label) {
    label.textContent = isSaved ? 'Saved' : 'Save';
  }
}

// Track tooltip states to restore them when popup closes
const tooltipStates = new WeakMap();

// Handle popup open: disable all tooltips and update save button state
map.on('popupopen', (event) => {
  const popupEl = event.popup && event.popup.getElement ? event.popup.getElement() : null;
  if (!popupEl) return;
  const sourceMarker = event.popup && event.popup._source;
  if (sourceMarker && sourceMarker.closeTooltip) {
    sourceMarker.closeTooltip();
  }
  
  // Disable tooltips on all markers when popup is open
  markersLayer.eachLayer((layer) => {
    if (layer.getTooltip && layer.getTooltip()) {
      const tooltip = layer.getTooltip();
      const tooltipContent = tooltip.getContent();
      // Store tooltip content to restore later
      tooltipStates.set(layer, tooltipContent);
      // Unbind tooltip to prevent it from showing on hover
      layer.unbindTooltip();
    }
  });
  
  const button = popupEl.querySelector('.popup-save-btn');
  if (!button) return;
  
  const collegeId = button.dataset.collegeId || '';
  if (!collegeId) {
    button.style.display = 'none';
    return;
  }
  
  // Defer button state update to allow popup to appear first (performance optimization)
  // This makes taps feel instant on mobile by not blocking popup appearance
  requestAnimationFrame(() => {
    // Update button state based on saved status
    updatePopupSaveButton(button, collegeId);
  });
  
  // Attach click handler if not already attached
  if (!button.dataset.listenerAttached) {
    button.addEventListener('click', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      
      // Toggle saved state
      SavedStore.toggle(collegeId);
      
      // Immediately update button visual state (user action, so update synchronously)
      updatePopupSaveButton(button, collegeId);
      
      // Update marker icon
      const marker = markersByCollegeId[collegeId];
      if (marker) {
        const isSaved = SavedStore.isSaved(collegeId);
        const latlng = marker.getLatLng();
        const popup = marker.getPopup();
        const tooltip = marker.getTooltip();
        const popupContent = popup ? popup.getContent() : '';
        const tooltipContent = tooltip ? tooltip.getContent() : '';
        const wasPopupOpen = popup && marker.isPopupOpen();
        
        // Remove old marker
        marker.remove();
        
        // Create new marker with appropriate icon
        let newMarker;
        if (isSaved) {
          // Use green pin icon for saved colleges with dynamic sizing
          const iconSize = getCurrentSavedIconSize();
          newMarker = L.marker(latlng, {
            icon: createGreenSavedIcon(iconSize)
          });
        } else {
          // Use blue circle marker for unsaved colleges with dynamic sizing
          const radius = getCurrentMarkerRadius();
          newMarker = L.circleMarker(latlng, {
            radius: radius,
            color: '#2563eb',
            weight: 2,
            fillOpacity: 0.7
          });
        }
        
        if (popupContent) newMarker.bindPopup(popupContent);
        if (tooltipContent) newMarker.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
        newMarker.addTo(markersLayer);
        markersByCollegeId[collegeId] = newMarker;
        
        // Reopen popup if it was open before
        if (wasPopupOpen) {
          newMarker.openPopup();
        }
      }
    });
    button.dataset.listenerAttached = '1';
  }
});

// Handle popup close: re-enable tooltips on all markers
map.on('popupclose', () => {
  // Re-enable tooltips on all markers when popup closes
  markersLayer.eachLayer((layer) => {
    const tooltipContent = tooltipStates.get(layer);
    if (tooltipContent) {
      // Rebind tooltip with stored content
      layer.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
      tooltipStates.delete(layer);
    }
  });
});

// Route state
let route = {
  start: null, // { description, lat, lon }
  end: null,
  lastSearch: null, // { start, end, maxDistance, units }
  lastResult: null // Cached visualization data for restoring route view quickly
};

// Nearby state (for restoration)
let nearbyState = {
  address: null,
  home: null,
  radius: null,
  units: null
};
let lastNearbyFilters = null;

const TYPE_ORDER = ["Ivy League","Elite Private Universities","Public Flagship Universities","Private Liberal Arts Colleges","STEM / Technology Institutes","Business / Arts / Specialty Schools","Health & Medical Colleges","Faith-Based","Public Regional Universities","Community Colleges","Online / For-Profit"];

// Region mapping for better performance
const REGION_MAP = {
  'Northeast': ['ME','NH','VT','MA','RI','CT','NY','NJ','PA'],
  'Midwest': ['OH','MI','IN','IL','WI','MN','IA','MO','ND','SD','NE','KS'],
  'South': ['DE','MD','DC','VA','WV','NC','SC','GA','FL','KY','TN','AL','MS','AR','LA','TX','OK'],
  'West': ['MT','ID','WY','CO','NM','AZ','UT','NV','CA','OR','WA','HI','AK'],
  'Territories': ['PR','GU','VI','AS','MP']
};

// U.S. states and territories mapping
const US_STATES = [
  { code: "AL", name: "Alabama" },
  { code: "AK", name: "Alaska" },
  { code: "AZ", name: "Arizona" },
  { code: "AR", name: "Arkansas" },
  { code: "CA", name: "California" },
  { code: "CO", name: "Colorado" },
  { code: "CT", name: "Connecticut" },
  { code: "DE", name: "Delaware" },
  { code: "FL", name: "Florida" },
  { code: "GA", name: "Georgia" },
  { code: "HI", name: "Hawaii" },
  { code: "ID", name: "Idaho" },
  { code: "IL", name: "Illinois" },
  { code: "IN", name: "Indiana" },
  { code: "IA", name: "Iowa" },
  { code: "KS", name: "Kansas" },
  { code: "KY", name: "Kentucky" },
  { code: "LA", name: "Louisiana" },
  { code: "ME", name: "Maine" },
  { code: "MD", name: "Maryland" },
  { code: "MA", name: "Massachusetts" },
  { code: "MI", name: "Michigan" },
  { code: "MN", name: "Minnesota" },
  { code: "MS", name: "Mississippi" },
  { code: "MO", name: "Missouri" },
  { code: "MT", name: "Montana" },
  { code: "NE", name: "Nebraska" },
  { code: "NV", name: "Nevada" },
  { code: "NH", name: "New Hampshire" },
  { code: "NJ", name: "New Jersey" },
  { code: "NM", name: "New Mexico" },
  { code: "NY", name: "New York" },
  { code: "NC", name: "North Carolina" },
  { code: "ND", name: "North Dakota" },
  { code: "OH", name: "Ohio" },
  { code: "OK", name: "Oklahoma" },
  { code: "OR", name: "Oregon" },
  { code: "PA", name: "Pennsylvania" },
  { code: "RI", name: "Rhode Island" },
  { code: "SC", name: "South Carolina" },
  { code: "SD", name: "South Dakota" },
  { code: "TN", name: "Tennessee" },
  { code: "TX", name: "Texas" },
  { code: "UT", name: "Utah" },
  { code: "VT", name: "Vermont" },
  { code: "VA", name: "Virginia" },
  { code: "WA", name: "Washington" },
  { code: "WV", name: "West Virginia" },
  { code: "WI", name: "Wisconsin" },
  { code: "WY", name: "Wyoming" },
  { code: "DC", name: "District of Columbia" }
];

const US_TERRITORIES = [
  { code: "AS", name: "American Samoa" },
  { code: "GU", name: "Guam" },
  { code: "MP", name: "Northern Mariana Islands" },
  { code: "PR", name: "Puerto Rico" },
  { code: "VI", name: "U.S. Virgin Islands" },
  { code: "FM", name: "Federated States of Micronesia" },
  { code: "MH", name: "Marshall Islands" },
  { code: "PW", name: "Palau" }
];

// Territories to hide from the state dropdown (but still support in data/filtering)
const HIDDEN_TERRITORIES = ['GU', 'MP', 'FM', 'MH', 'PW'];

// Helper: Create a lookup map from code to name (for backward compatibility)
const STATE_NAME_MAP = {};
[...US_STATES, ...US_TERRITORIES].forEach(item => {
  STATE_NAME_MAP[item.code] = item.name;
});

// Calculate distance between two coordinates (Haversine formula)
function calculateDistance(lat1, lon1, lat2, lon2, unit = 'mi') {
  const R = unit === 'mi' ? 3959 : 6371; // Earth radius in miles or km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Debounce function for search input
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function showError(message) {
  if (elements.error) {
    elements.error.textContent = message;
    elements.error.classList.add('active');
    setTimeout(() => {
      if (elements.error) {
        elements.error.classList.remove('active');
      }
    }, 5000);
  }
}

const RECENT_STORAGE_KEYS = {
  nearby: 'ucm_recentAddresses',
  routeStart: 'ucm_routeRecentStart',
  routeEnd: 'ucm_routeRecentEnd'
};
const MAX_RECENT_ITEMS = 5;
const SHARED_RECENT_KEY = 'ucm_recentLocations';
const MAX_SHARED_RECENT_ITEMS = 10;

function escapeHtml(text = '') {
  return text.replace(/&/g, '&amp;')
             .replace(/</g, '&lt;')
             .replace(/>/g, '&gt;')
             .replace(/"/g, '&quot;')
             .replace(/'/g, '&#39;');
}

function loadRecents(storageKey) {
  try {
    const stored = localStorage.getItem(storageKey);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(item => typeof item === 'string' && item.trim().length);
  } catch (error) {
    console.warn('Unable to load recents for key', storageKey, error);
    return [];
  }
}

function loadSharedLocations() {
  try {
    const stored = localStorage.getItem(SHARED_RECENT_KEY);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(item => {
      return item && typeof item.description === 'string' &&
             typeof item.lat === 'number' && !isNaN(item.lat) &&
             typeof item.lon === 'number' && !isNaN(item.lon);
    });
  } catch (error) {
    console.warn('Unable to load shared locations', error);
    return [];
  }
}

function saveSharedLocation(description, lat, lon) {
  if (!description || typeof description !== 'string') return;
  const trimmed = description.trim();
  const latNum = typeof lat === 'number' ? lat : parseFloat(lat);
  const lonNum = typeof lon === 'number' ? lon : parseFloat(lon);
  if (!trimmed || isNaN(latNum) || isNaN(lonNum)) return;
  const normalizedKey = `${trimmed.toLowerCase()}|${latNum.toFixed(6)}|${lonNum.toFixed(6)}`;
  const existing = loadSharedLocations().filter(item => {
    const itemKey = `${(item.description || '').toLowerCase()}|${item.lat.toFixed(6)}|${item.lon.toFixed(6)}`;
    return itemKey !== normalizedKey;
  });
  existing.unshift({ description: trimmed, lat: latNum, lon: lonNum });
  try {
    localStorage.setItem(SHARED_RECENT_KEY, JSON.stringify(existing.slice(0, MAX_SHARED_RECENT_ITEMS)));
  } catch (error) {
    console.warn('Unable to persist shared locations', error);
  }
}

function saveRecent(storageKey, value) {
  if (!storageKey || typeof value !== 'string') return;
  const trimmed = value.trim();
  if (!trimmed.length) return;
  const existing = loadRecents(storageKey).filter(item => item.toLowerCase() !== trimmed.toLowerCase());
  existing.unshift(trimmed);
  try {
    localStorage.setItem(storageKey, JSON.stringify(existing.slice(0, MAX_RECENT_ITEMS)));
  } catch (error) {
    console.warn('Unable to persist recents for key', storageKey, error);
  }
}

function getFallbackRecentsForField(field) {
  if (!field) return [];
  if (field === 'address') return loadRecents(RECENT_STORAGE_KEYS.nearby);
  if (field === 'routeStart') return loadRecents(RECENT_STORAGE_KEYS.routeStart);
  if (field === 'routeEnd') return loadRecents(RECENT_STORAGE_KEYS.routeEnd);
  return [];
}

function clearRecentState(container) {
  if (!container) return;
  delete container.dataset.showingRecents;
  delete container.dataset.recentContext;
}

function shouldShowRecentsForInput(inputElement) {
  if (!inputElement) return false;
  if (document.activeElement !== inputElement) return false;
  return (inputElement.value || '').trim().length < 3;
}

function buildUnifiedRecentSection(fallbackRecents = [], options = {}) {
  const query = (options.query || '').trim().toLowerCase();
  const shouldFilterShared = options.filterShared && query.length > 0;
  const shouldFilterFallback = options.filterFallback && query.length > 0;
  const sharedLocations = loadSharedLocations();
  let sharedItems = sharedLocations;
  if (shouldFilterShared) {
    sharedItems = sharedLocations.filter(loc => (loc.description || '').toLowerCase().startsWith(query));
  }
  let sectionItems = '';
  if (sharedItems.length) {
    sectionItems = sharedItems.map(loc => {
      const encodedDescription = encodeURIComponent(loc.description || '');
      const safeDescription = escapeHtml(loc.description || '');
      const safeDetails = `${loc.lat.toFixed(3)}, ${loc.lon.toFixed(3)}`;
      return `
        <div class="autocomplete-item shared-location" role="option" tabindex="0"
             data-shared="true"
             data-description="${encodedDescription}"
             data-lat="${loc.lat}"
             data-lon="${loc.lon}">
          <div class="autocomplete-item-icon">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
            </svg>
          </div>
          <div class="autocomplete-item-content">
            <div class="address-name">${safeDescription}</div>
            <div class="address-details">${safeDetails}</div>
          </div>
        </div>`;
    }).join('');
  } else {
    let fallbackItems = fallbackRecents;
    if (shouldFilterFallback) {
      fallbackItems = fallbackRecents.filter(value => value.toLowerCase().startsWith(query));
    }
    if (fallbackItems.length) {
      sectionItems = fallbackItems.map(value => {
        const encodedValue = encodeURIComponent(value);
        const safeValue = escapeHtml(value);
        return `
          <div class="autocomplete-item recent-suggestion" role="option" tabindex="0" data-recent="true" data-value="${encodedValue}">
            <div class="autocomplete-item-icon">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2a10 10 0 1 0 10 10A10.011 10.011 0 0 0 12 2zm0 18a8 8 0 1 1 8-8a8.009 8.009 0 0 1-8 8zm.75-12h-1.5v5l4.25 2.55l.75-1.23l-3.5-2.07z"/>
              </svg>
            </div>
            <div class="autocomplete-item-content">
              <div class="address-name">${safeValue}</div>
            </div>
          </div>`;
      }).join('');
    }
  }
  if (!sectionItems) {
    return '';
  }
  return `
    <div class="autocomplete-section-title">Recent locations</div>
    ${sectionItems}
    <div class="autocomplete-divider" role="separator"></div>`;
}

function toggleAutocompleteLayer(inputElement, isActive) {
  const wrapper = inputElement ? inputElement.closest('.address-autocomplete') : null;
  if (!wrapper) return;
  if (isActive) {
    wrapper.classList.add('autocomplete-active');
  } else {
    wrapper.classList.remove('autocomplete-active');
  }
}

function showRecentSuggestions(container, recents, inputElement, context, options = {}) {
  if (!container || !inputElement) return false;
  const unifiedSection = buildUnifiedRecentSection(recents, options);
  if (!unifiedSection) {
    clearRecentState(container);
    return false;
  }
  container.innerHTML = unifiedSection;
  container.classList.add('active');
  container.dataset.showingRecents = 'true';
  container.dataset.recentContext = context || '';
  inputElement.setAttribute('aria-expanded', 'true');
  return true;
}

function showAddressRecentsIfEligible() {
  if (!elements.address || !elements.addressSuggestions) return false;
  const queryValue = (elements.address.value || '').trim();
  if (!shouldShowRecentsForInput(elements.address)) {
    return false;
  }
  const recents = loadRecents(RECENT_STORAGE_KEYS.nearby);
  const shown = showRecentSuggestions(
    elements.addressSuggestions,
    recents,
    elements.address,
    'address',
    {
      query: queryValue,
      filterShared: true,
      filterFallback: true
    }
  );
  if (shown) {
    addressAutocomplete.suggestions = [];
    addressAutocomplete.selectedIndex = -1;
  }
  return shown;
}

function showRouteRecentsIfEligible(inputElement, suggestionsContainer, autocompleteObj, storageKey, context) {
  if (!inputElement || !suggestionsContainer) return false;
  const queryValue = (inputElement.value || '').trim();
  if (!shouldShowRecentsForInput(inputElement)) {
    return false;
  }
  const recents = loadRecents(storageKey);
  const shown = showRecentSuggestions(
    suggestionsContainer,
    recents,
    inputElement,
    context,
    {
      query: queryValue,
      filterShared: true,
      filterFallback: true
    }
  );
  if (shown && autocompleteObj) {
    autocompleteObj.suggestions = [];
    autocompleteObj.selectedIndex = -1;
  }
  return shown;
}

function handleRecentAddressSelection(value) {
  if (!value) return;
  addressAutocomplete.suggestions = [{ description: value }];
  selectSuggestion(0);
}

function handleRecentRouteSelection(value, context) {
  if (!value) return;
  if (context === 'routeStart' && elements.routeStart && elements.routeStartSuggestions) {
    routeStartAutocomplete.suggestions = [{ description: value }];
    selectRouteSuggestion(0, routeStartAutocomplete, elements.routeStart, elements.routeStartSuggestions);
  } else if (context === 'routeEnd' && elements.routeEnd && elements.routeEndSuggestions) {
    routeEndAutocomplete.suggestions = [{ description: value }];
    selectRouteSuggestion(0, routeEndAutocomplete, elements.routeEnd, elements.routeEndSuggestions);
  }
}

function handleSharedLocationSelection(field, description) {
  if (!field || !description) return;
  if (field === 'address') {
    handleRecentAddressSelection(description);
  } else if (field === 'routeStart') {
    handleRecentRouteSelection(description, 'routeStart');
  } else if (field === 'routeEnd') {
    handleRecentRouteSelection(description, 'routeEnd');
  }
}

function getRouteFilterSignature() {
  const typeVal = elements.type ? elements.type.value.trim() : '';
  const regionVal = elements.region ? elements.region.value.trim() : '';
  const stateVal = elements.state ? elements.state.value.trim() : '';
  const rankingVal = elements.ranking ? elements.ranking.value.trim() : '';
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  // Parse maxDistance - handle 0 correctly (don't use || operator as 0 is falsy)
  const maxDistanceInputStr = elements.routeMaxDistance?.value;
  let maxDistanceInput;
  if (maxDistanceInputStr === '' || maxDistanceInputStr === null || maxDistanceInputStr === undefined) {
    maxDistanceInput = 30;
  } else {
    maxDistanceInput = parseFloat(maxDistanceInputStr);
    if (isNaN(maxDistanceInput)) {
      maxDistanceInput = 30;
    }
  }
  // If maxDistance is 0, use 0.5 instead
  const maxDistance = maxDistanceInput === 0 ? 0.5 : maxDistanceInput;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  return { typeVal, regionVal, stateVal, rankingVal, searchVal, maxDistance, units };
}

function addRouteCollegeMarker(college, distanceText, units) {
  try {
    if (isNaN(college.lat) || isNaN(college.lon) || college.lat === 0 || college.lon === 0) {
      console.warn(`Invalid coordinates for ${college.name}:`, college.lat, college.lon);
      return;
    }

    const tuition = college.tuition ? (college.tuition.toString().includes('$') ? college.tuition : `$${Number(college.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = college.acceptance ? (college.acceptance.toString().includes('%') ? college.acceptance : `${parseFloat(college.acceptance).toFixed(1)}%`) : 'N/A';

    const saveButtonHtml = college.college_id ? `
      <div class="popup-save-row">
        <button type="button" class="popup-save-btn" data-college-id="${college.college_id}">
          <span class="popup-save-icon" aria-hidden="true">☆</span>
          <span class="popup-save-label">Save</span>
        </button>
      </div>` : '';

    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${college.name}</b><br>
        ${college.state} · ${(college.type||'Unknown')}${distanceText || ''}<br>
        ${college.control ? college.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${college.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${college.url ? `<a href="https://${college.url.replace(/^https?:\/\//,'')}" target="_blank">${college.url}</a>` : ''}
        ${saveButtonHtml}
      </div>`;

    const marker = createCollegeMarker(college, popupContent, college.college_id);
    marker.addTo(markersLayer);
  } catch (e) {
    console.error(`Error creating marker for ${college.name}:`, e);
  }
}

function areNearbySignaturesEqual(a, b) {
  if (!a || !b) return false;
  const keys = ['typeVal', 'regionVal', 'stateVal', 'rankingVal', 'searchVal', 'radiusVal', 'unitsVal', 'homeLat', 'homeLon'];
  return keys.every(key => (a[key] ?? '') === (b[key] ?? ''));
}

function isRouteCacheValid(cache, filters, currentStart, currentEnd) {
  if (!cache || !cache.filters || !filters) return false;
  const keys = ['typeVal', 'regionVal', 'stateVal', 'rankingVal', 'searchVal', 'maxDistance', 'units'];
  const filtersMatch = keys.every(key => (cache.filters[key] || '') === (filters[key] || ''));
  const sameStart = cache.start && currentStart &&
    cache.start.lat === currentStart.lat &&
    cache.start.lon === currentStart.lon &&
    (cache.start.description || '') === (currentStart.description || '');
  const sameEnd = cache.end && currentEnd &&
    cache.end.lat === currentEnd.lat &&
    cache.end.lon === currentEnd.lon &&
    (cache.end.description || '') === (currentEnd.description || '');
  return filtersMatch && sameStart && sameEnd && Array.isArray(cache.routeCoords) && cache.routeCoords.length > 0;
}

function restoreRouteFromCache(cache, options = {}) {
  if (!cache) return false;
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;

  // Draw route with ribbon effect
  const zoom = map ? map.getZoom() : 5;
  const routeWeights = calculateRouteLineWeights(zoom);
  
  // First draw the deep navy outline (thin line for ribbon effect)
  routeOutlinePolyline = L.polyline(cache.routeCoords, {
    color: '#0A2CA5',
    weight: routeWeights.outlineWeight,
    opacity: routeWeights.outlineOpacity
  }).addTo(routeLayer);
  // Then draw the vivid royal blue main route line on top
  routeMainPolyline = L.polyline(cache.routeCoords, {
    color: '#1A4CFF',
    weight: routeWeights.mainWeight,
    opacity: routeWeights.mainOpacity
  }).addTo(routeLayer);

  const startData = cache.start;
  if (startData) {
    L.marker([startData.lat, startData.lon], {
      icon: L.icon({
        iconUrl: ROUTE_START_PIN_ICON,
        iconSize: [18, 18],
        iconAnchor: [9, 9],
        popupAnchor: [0, -9]
      })
    }).addTo(routeLayer).bindPopup('From');
  }

  const endData = cache.end;
  if (endData) {
    L.marker([endData.lat, endData.lon], {
      icon: L.icon({
        iconUrl: ROUTE_END_PIN_ICON,
        iconSize: [24, 30],
        iconAnchor: [12, 30],
        popupAnchor: [0, -30]
      })
    }).addTo(routeLayer).bindPopup('To');
  }

  const units = cache.filters?.units || 'mi';
  let collegesToRender = cache.colleges || [];
  
  // Apply saved-only filter if enabled
  if (savedOnlyMode) {
    collegesToRender = collegesToRender.filter(item => SavedStore.isSaved(item.college.college_id));
  }
  
  collegesToRender.forEach(item => {
    addRouteCollegeMarker(item.college, item.distanceText || '', units);
  });

  if (elements.count) elements.count.textContent = collegesToRender.length;
  updateMapHints(
    collegesToRender.length,
    cache.filters?.typeVal || '',
    cache.filters?.regionVal || '',
    cache.filters?.stateVal || '',
    cache.filters?.searchVal || ''
  );

  if (!options.preserveView) {
    if (cache.bounds && cache.bounds.isValid()) {
      map.fitBounds(cache.bounds.pad(0.15));
    } else if (cache.routeCoords && cache.routeCoords.length) {
      map.fitBounds(L.latLngBounds(cache.routeCoords), { padding: [50, 50] });
    }
  }
  if (elements.loading) elements.loading.classList.remove('active');
  return true;
}

// Re-filter colleges along route without redrawing the route line
function refilterCollegesAlongRoute() {
  if (!route.lastResult || !route.lastResult.routeCoords) {
    // No cached route, need to fetch it
    findCollegesAlongRoute();
    return;
  }
  
  const cache = route.lastResult;
  const routeCoords = cache.routeCoords;
  
  // Skip if this is a fallback route (only 2 points = straight line)
  // We don't want to process fallback routes when toggling saved-only
  if (routeCoords.length <= 2) {
    console.log('Skipping refilter - route is a fallback straight line');
    return;
  }
  // Parse maxDistance - handle 0 correctly (don't use || operator as 0 is falsy)
  const maxDistanceInputStr = elements.routeMaxDistance?.value;
  let maxDistanceInput;
  if (maxDistanceInputStr === '' || maxDistanceInputStr === null || maxDistanceInputStr === undefined) {
    maxDistanceInput = 30;
  } else {
    maxDistanceInput = parseFloat(maxDistanceInputStr);
    if (isNaN(maxDistanceInput)) {
      maxDistanceInput = 30;
    }
  }
  // If maxDistance is 0, use 0.5 instead
  const maxDistance = maxDistanceInput === 0 ? 0.5 : maxDistanceInput;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  
  // Sample route points for performance
  const sampleRate = routeCoords.length > 100 ? 10 : 1;
  const sampledRoute = [];
  for (let i = 0; i < routeCoords.length; i += sampleRate) {
    sampledRoute.push(routeCoords[i]);
  }
  if (sampledRoute[sampledRoute.length - 1] !== routeCoords[routeCoords.length - 1]) {
    sampledRoute.push(routeCoords[routeCoords.length - 1]);
  }
  
  // Filter colleges by distance to route
  const filtered = colleges.filter(c => {
    let minDistance = Infinity;
    for (let i = 0; i < sampledRoute.length - 1; i++) {
      const segmentStart = sampledRoute[i];
      const segmentEnd = sampledRoute[i + 1];
      const dist = distanceToLineSegment(
        c.lat, c.lon,
        segmentStart[0], segmentStart[1],
        segmentEnd[0], segmentEnd[1],
        units
      );
      minDistance = Math.min(minDistance, dist);
      if (minDistance <= maxDistance) break;
    }
    return minDistance <= maxDistance;
  });
  
  // Apply other filters
  const typeVal = elements.type ? elements.type.value.trim() : '';
  const regionVal = elements.region ? elements.region.value.trim() : '';
  const stateVal = elements.state ? elements.state.value.trim() : '';
  const rankingVal = elements.ranking ? elements.ranking.value.trim() : '';
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  
  const finalFiltered = filtered.filter(c => {
    if (typeVal && (c.type || c.tier) !== typeVal) return false;
    if (regionVal) {
      const regionStates = REGION_MAP[regionVal] || [];
      if (!regionStates.includes(c.state)) return false;
    }
    if (stateVal && c.state !== stateVal) return false;
    if (rankingVal) {
      if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
      if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
      if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
      if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
    }
    if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
    return true;
  });
  
  const routeEntries = finalFiltered.map(c => {
    let distanceText = '';
    let minRouteDist = Infinity;
    for (let i = 0; i < sampledRoute.length - 1; i++) {
      const dist = distanceToLineSegment(
        c.lat, c.lon,
        sampledRoute[i][0], sampledRoute[i][1],
        sampledRoute[i + 1][0], sampledRoute[i + 1][1],
        units
      );
      minRouteDist = Math.min(minRouteDist, dist);
    }
    if (minRouteDist < Infinity) {
      distanceText = `<br>Distance from route: ${minRouteDist.toFixed(1)} ${units}`;
    }
    return { college: c, distanceText };
  });
  
  const visibleRouteEntries = savedOnlyMode
    ? routeEntries.filter(item => SavedStore.isSaved(item.college.college_id))
    : routeEntries;
  
  if (visibleRouteEntries.length === 0 && savedOnlyMode) {
    const savedCount = SavedStore.getAll().length;
    if (savedCount === 0) {
      console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
    } else {
      console.log("No saved colleges match your current filters or route.");
    }
  }
  
  // Clear and render markers only (don't touch routeLayer)
  markersLayer.clearLayers();
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  
  const routeBounds = L.latLngBounds(routeCoords);
  routeEntries.forEach(item => {
    routeBounds.extend([item.college.lat, item.college.lon]);
  });
  
  visibleRouteEntries.forEach(item => {
    addRouteCollegeMarker(item.college, item.distanceText, units);
  });
  
  if (elements.count) elements.count.textContent = visibleRouteEntries.length;
  updateMapHints(visibleRouteEntries.length, typeVal, regionVal, stateVal, searchVal);
  
  route.lastResult.colleges = routeEntries;
  route.lastResult.filters = { typeVal, regionVal, stateVal, searchVal, maxDistance, units };
  if (routeBounds.isValid()) {
    route.lastResult.bounds = routeBounds;
  }
}

/**
 * Render colleges on the map based on current filters.
 * 
 * Performance: This function is NOT called during map pan/zoom interactions.
 * Markers are only re-rendered when:
 * - User changes filters (Type, Region, State, Search)
 * - User sets/changes address/radius
 * - User switches between Nearby/Route modes
 * - NOT during map dragging/zooming (Leaflet handles marker visibility automatically)
 */
function render(){
  // Only render in nearby mode - route mode uses findCollegesAlongRoute()
  if (activeMode === 'route') {
    // If route search has been performed, re-run it with updated filters
    if (route.lastSearch) {
      findCollegesAlongRoute();
    } else {
      // If in route mode but no route search, show colleges based on filters only
      // Clear route visualization
      routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      
      // Apply filters from dropdowns
      const stateVal = elements.state ? elements.state.value : '';
      const regionVal = elements.region ? elements.region.value : '';
      const typeVal = elements.type ? elements.type.value : '';
      const rankingVal = elements.ranking ? elements.ranking.value : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      
      let filtered = colleges.filter(c => {
        // Region filter
        const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
        if (!regionMatch) return false;
        
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        
        // Type filter
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        
        // Ranking filter
        if (rankingVal) {
          if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
          if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
          if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
          if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
        }
        
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        return true;
      });
      
      // Apply saved-only filter if enabled
      if (savedOnlyMode) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(c => SavedStore.isSaved(c.college_id));
        
        // Edge case: Show message if no saved colleges match filters
        if (filtered.length === 0) {
          const savedCount = SavedStore.getAll().length;
          if (savedCount === 0) {
            // No saved colleges at all
            console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
          } else {
            // Saved colleges exist but don't match current filters
            console.log("No saved colleges match your current filters or route.");
          }
        }
      }
      
      // Render filtered colleges
      filtered.forEach(c => {
        try {
          if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
            return;
          }
          
    const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
          
          const saveButtonHtml = c.college_id ? `
            <div class="popup-save-row">
              <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
                <span class="popup-save-icon" aria-hidden="true">☆</span>
                <span class="popup-save-label">Save</span>
              </button>
            </div>` : '';

    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${c.name}</b><br>
        ${c.state} · ${(c.type||'Unknown')}<br>
        ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${c.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
              ${saveButtonHtml}
      </div>`;

          const marker = createCollegeMarker(c, popupContent, c.college_id);
          marker.addTo(markersLayer);
        } catch (e) {
          console.error(`Error creating marker for ${c.name}:`, e);
        }
      });
      
      if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
      
      // Show tip bubble when blue dots first appear (first-time users only)
      // Check if we have any blue dots (unsaved markers) and haven't shown the tip yet
      if (filtered.length > 0 && sessionStorage.getItem('ucm_seenTapDotHint') !== '1') {
        // Check if there are any unsaved markers (blue dots)
        let hasBlueDots = false;
        markersLayer.eachLayer((layer) => {
          if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius !== undefined)) {
            hasBlueDots = true;
            return false; // Break the loop
          }
        });
        
        if (hasBlueDots) {
          // Wait a bit for map to finish rendering, then show tip
          setTimeout(() => {
            showMapTip();
          }, 300);
        }
      }
      
      // Update map hints for route mode (no route search yet)
      updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
    }
    return;
  }
  
  // Clear route visualization when in nearby mode
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  
  // Check if colleges data is loaded
  if (!colleges || colleges.length === 0) {
    console.log('No colleges data available yet');
    if (elements.count) elements.count.textContent = '0';
    return;
  }
  
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  radiusLayer.clearLayers();
  
  const stateVal = elements.state ? elements.state.value : '';
  const regionVal = elements.region ? elements.region.value : '';
  const typeVal = elements.type ? elements.type.value : '';
  const rankingVal = elements.ranking ? elements.ranking.value : '';
  // Get search value from either desktop or mobile search field (prefer the one with a value, or desktop first)
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  const radiusVal = parseFloat(elements.radius?.value || '0') || 0;
  const unitsVal = elements.units ? elements.units.value : 'mi';
  const nearbySignature = {
    typeVal,
    regionVal,
    stateVal,
    rankingVal,
    searchVal,
    radiusVal,
    unitsVal,
    homeLat: home ? Number(home.lat.toFixed(6)) : null,
    homeLon: home ? Number(home.lon.toFixed(6)) : null
  };
  const shouldAutoFrameNearby = !lastNearbyFilters || !mapViewState.nearby || !areNearbySignaturesEqual(lastNearbyFilters, nearbySignature);
  const isDefaultNearbyState = !home && !regionVal && !stateVal && !typeVal && !rankingVal && !searchVal;
  const isSearchOnlyFilter = !!searchVal && !home && !regionVal && !stateVal && !typeVal && !rankingVal;

  let filtered = colleges.filter(c => {
    // Region filter
    const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
    if (!regionMatch) return false;
    
    // State filter
    if (stateVal && c.state !== stateVal) return false;
    
    // Type filter
    if (typeVal && (c.type || c.tier) !== typeVal) return false;
    
    // Ranking filter
    if (rankingVal) {
      if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
      if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
      if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
      if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
    }
    
    // Search filter
    if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
    
    // Radius filter (if home location is set)
    if (home) {
      // If radius is 0, use 0.5 instead
      const effectiveRadius = radiusVal === 0 ? 0.5 : radiusVal;
      const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
      if (distance > effectiveRadius) return false;
    }
    
    return true;
  });
  
  // Apply saved-only filter if enabled
  if (savedOnlyMode) {
    const beforeCount = filtered.length;
    console.log(`[render] Applying saved-only filter. Before: ${beforeCount} colleges. isSharedView: ${isSharedView}, sharedViewIds size: ${sharedViewIds ? sharedViewIds.size : 'null'}`);
    
    if (isSharedView && sharedViewIds) {
      // Debug: Show sample IDs from both sets for comparison
      const sampleCollegeIds = filtered.slice(0, 5).map(c => ({ id: c.college_id, name: c.name }));
      const sampleSharedIds = Array.from(sharedViewIds).slice(0, 5);
      console.log(`[render] Sample college IDs from filtered (first 5):`, sampleCollegeIds);
      console.log(`[render] Sample IDs from sharedViewIds (first 5):`, sampleSharedIds);
      
      // Check if any IDs match
      let matchCount = 0;
      filtered.slice(0, 10).forEach(c => {
        const normalizedId = String(c.college_id || '').trim();
        if (sharedViewIds.has(normalizedId)) {
          matchCount++;
          if (matchCount <= 3) {
            console.log(`[render] ✓ Match found: "${c.name}" (ID: "${normalizedId}")`);
          }
        }
      });
      console.log(`[render] Found ${matchCount} matches in first 10 colleges`);
    }
    
    filtered = filtered.filter(c => {
      const isSaved = SavedStore.isSaved(c.college_id);
      return isSaved;
    });
    console.log(`[render] After saved-only filter: ${filtered.length} colleges will be displayed`);
    
    if (filtered.length === 0 && isSharedView && sharedViewIds && sharedViewIds.size > 0) {
      console.error(`[render] WARNING: No colleges matched after filtering! sharedViewIds has ${sharedViewIds.size} IDs but 0 colleges matched.`);
      console.error(`[render] This suggests an ID format mismatch. Sample shared IDs:`, Array.from(sharedViewIds).slice(0, 3));
      console.error(`[render] Sample college IDs:`, colleges.slice(0, 3).map(c => c.college_id));
    }
    
    // Edge case: Show message if no saved colleges match filters
    if (filtered.length === 0) {
      const savedCount = SavedStore.getAll().length;
      if (savedCount === 0) {
        // No saved colleges at all
        console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
      } else {
        // Saved colleges exist but don't match current filters
        console.log("No saved colleges match your current filters or route.");
      }
    }
  } else {
    console.log(`[render] savedOnlyMode is false, showing all colleges`);
  }

  // Draw radius circle if home is set (use 0.5 if radius is 0)
  if (home) {
    const effectiveRadius = radiusVal === 0 ? 0.5 : radiusVal;
    const radiusMeters = effectiveRadius * (unitsVal === 'mi' ? 1609.34 : 1000);
    L.circle([home.lat, home.lon], {
      radius: radiusMeters,
      color: '#2563eb',
      fillColor: '#2563eb',
      fillOpacity: 0.1,
      weight: 2,
      dashArray: '5, 5'
    }).addTo(radiusLayer);
  }

  console.log(`Rendering ${filtered.length} colleges (activeMode: ${activeMode}, home: ${home ? 'set' : 'null'})`);
  
  const nearbyBounds = filtered.length > 1 ? L.latLngBounds([]) : null;
  filtered.forEach(c => {
    try {
      // Validate coordinates
      if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
        console.warn(`Invalid coordinates for ${c.name}:`, c.lat, c.lon);
        return;
      }
      
    const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
      
      // Calculate distance if home is set
      let distanceText = '';
      if (home) {
        const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
        distanceText = `<br>Distance: ${distance.toFixed(1)} ${unitsVal}`;
      }
      
    const saveButtonHtml = c.college_id ? `
      <div class="popup-save-row">
        <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
          <span class="popup-save-icon" aria-hidden="true">☆</span>
          <span class="popup-save-label">Save</span>
        </button>
      </div>` : '';

    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${c.name}</b><br>
          ${c.state} · ${(c.type||'Unknown')}${distanceText}<br>
        ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${c.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
        ${saveButtonHtml}
      </div>`;

    const marker = createCollegeMarker(c, popupContent, c.college_id);
    marker.addTo(markersLayer);
    if (nearbyBounds) {
      nearbyBounds.extend(marker.getLatLng());
    }
    } catch (e) {
      console.error(`Error creating marker for ${c.name}:`, e);
    }
  });

  if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
  console.log(`Added ${filtered.length} markers to map`);
  
  // Show tip bubble when blue dots first appear (first-time users only)
  // Check if we have any blue dots (unsaved markers) and haven't shown the tip yet
  if (filtered.length > 0 && sessionStorage.getItem('ucm_seenTapDotHint') !== '1') {
    // Check if there are any unsaved markers (blue dots)
    let hasBlueDots = false;
    markersLayer.eachLayer((layer) => {
      if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius !== undefined)) {
        hasBlueDots = true;
        return false; // Break the loop
      }
    });
    
    if (hasBlueDots) {
      // Wait a bit for map to finish rendering, then show tip
      setTimeout(() => {
        showMapTip();
      }, 300);
    }
  }
  
  // Update map hints based on filtered results
  updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
  
  if (shouldAutoFrameNearby) {
    // Special handling for Territories region - zoom out to show global view
    if (regionVal === 'Territories') {
      if (filtered.length === 0) {
        // No results, show global view that includes all US territories
        // Territories span: PR/VI (Caribbean), GU/MP (Western Pacific), AS (South Pacific)
        // Use a wide view centered on Pacific to show all territories
        map.setView([10, -170], 2);
      } else if (filtered.length === 1) {
        // Single college, zoom to it
        map.setView([filtered[0].lat, filtered[0].lon], 8);
      } else if (nearbyBounds && nearbyBounds.isValid()) {
        // Multiple colleges - fit bounds with padding, no mainland constraint
        // Territories are spread globally, so don't clamp to mainland
        const paddedBounds = nearbyBounds.pad(0.2);
        map.fitBounds(paddedBounds);
      } else {
        // Fallback: global view centered on Pacific
        map.setView([10, -170], 2);
      }
    } else if (isDefaultNearbyState || isSearchOnlyFilter) {
      // When no filters are active, restore to default US view (not saved view which might be from a territory)
      const defaultView = getInitialNearbyView();
      map.setView([defaultView.center.lat, defaultView.center.lng], defaultView.zoom);
      // Update mapViewState to reflect the default view
      mapViewState.nearby = { ...defaultView };
      captureMapView('nearby');
    } else if (filtered.length === 0) {
      if (home) {
        map.setView([home.lat, home.lon], 8);
      } else {
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    } else if (filtered.length === 1) {
      map.setView([filtered[0].lat, filtered[0].lon], 8);
    } else if (nearbyBounds && nearbyBounds.isValid()) {
      const paddedBounds = nearbyBounds.pad(0.15);
      // Only clamp to mainland if no state filter is active, or if the state filter is for a mainland state
      // This allows territories like AS, HI, AK, PR to be shown when explicitly selected
      let constrainedBounds = paddedBounds;
      if (stateVal) {
        // Check if all filtered colleges are in the same state, and if that state is outside mainland
        // If user explicitly selected a non-mainland state, don't clamp
        const allSameState = filtered.every(c => c.state === stateVal);
        if (allSameState) {
          // Check if this state's colleges are outside mainland bounds
          const boundsSouth = nearbyBounds.getSouth();
          const boundsWest = nearbyBounds.getWest();
          const boundsNorth = nearbyBounds.getNorth();
          const boundsEast = nearbyBounds.getEast();
          const isOutsideMainland = 
            boundsSouth < US_MAINLAND_VIEW.getSouth() ||
            boundsWest < US_MAINLAND_VIEW.getWest() ||
            boundsNorth > US_MAINLAND_VIEW.getNorth() ||
            boundsEast > US_MAINLAND_VIEW.getEast();
          // If explicitly selected state is outside mainland, don't clamp
          if (isOutsideMainland) {
            constrainedBounds = paddedBounds;
          } else {
            constrainedBounds = clampBoundsToMainland(paddedBounds);
          }
        } else {
          // Mixed states - apply clamping
          constrainedBounds = clampBoundsToMainland(paddedBounds);
        }
      } else {
        // No state filter - apply clamping to prevent showing empty ocean
        constrainedBounds = clampBoundsToMainland(paddedBounds);
      }
      map.fitBounds(constrainedBounds);
    } else if (home) {
      map.setView([home.lat, home.lon], 8);
    } else {
      map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
    }
  } else {
    if (!applySavedMapView('nearby')) {
      if (home) {
        map.setView([home.lat, home.lon], 8);
      } else {
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    }
  }
  lastNearbyFilters = nearbySignature;
}

function refreshDropdown(id, values, placeholder) {
  const select = document.getElementById(id);
  // Special handling for state dropdown: use codes as values but full names as labels
  if (id === 'state') {
    // Create sets of available state and territory codes from the data
    const availableCodes = new Set(values);
    
    // Filter and sort states by name
    const availableStates = US_STATES
      .filter(state => availableCodes.has(state.code))
      .sort((a, b) => a.name.localeCompare(b.name));
    
    // Filter and sort territories by name (excluding hidden territories)
    const availableTerritories = US_TERRITORIES
      .filter(territory => availableCodes.has(territory.code) && !HIDDEN_TERRITORIES.includes(territory.code))
      .sort((a, b) => a.name.localeCompare(b.name));
    
    // Build HTML: placeholder, states, divider (if territories exist), territories
    let html = `<option value="">${placeholder}</option>`;
    
    // Add states
    availableStates.forEach(state => {
      html += `<option value="${state.code}">${state.name}</option>`;
    });
    
    // Add divider if there are territories
    if (availableTerritories.length > 0) {
      html += `<option value="" disabled class="state-divider">U.S. territories & associated states</option>`;
    }
    
    // Add territories
    availableTerritories.forEach(territory => {
      html += `<option value="${territory.code}">${territory.name}</option>`;
    });
    
    select.innerHTML = html;
  } else {
    select.innerHTML = `<option value="">${placeholder}</option>` + values.map(v => `<option>${v}</option>`).join('');
  }
  // Ensure font-size is consistent after dropdown refresh (especially for mobile/tablet)
  const width = window.innerWidth || document.documentElement.clientWidth;
  const isMobile = width <= 700;
  const isTablet = width >= 701 && width <= 1024;
  const ua = navigator.userAgent || '';
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  if (isMobile) {
    // Mobile (≤700px): 14px for all devices, 16px for iOS
    const fontSize = isIOS ? '16px' : '14px';
    select.style.fontSize = fontSize;
    select.style.setProperty('font-size', fontSize, 'important');
  } else if (isTablet) {
    // Tablet (701px-1024px): 16px for all devices
    select.style.fontSize = '16px';
    select.style.setProperty('font-size', '16px', 'important');
  } else {
    // Remove inline font-size on desktop to let CSS handle it
    select.style.fontSize = '';
  }
}

/**
 * Update map hint popups based on filtered results and filter state
 * Only shows hints when user has actively used search controls
 * Priority: No Results > Too Many Colleges (never show both)
 */
function updateMapHints(visibleCount, typeVal, regionVal, stateVal, searchVal) {
  const hintTooMany = document.getElementById('hint-too-many-colleges');
  const hintNoResults = document.getElementById('hint-no-colleges');
  
  if (!hintTooMany || !hintNoResults) {
    console.warn('Map hint elements not found');
    return;
  }
  
  // Don't show any hints if user hasn't actively used search controls
  if (!hasUsedSearchControls) {
    hintTooMany.classList.remove('active');
    hintNoResults.classList.remove('active');
    return;
  }
  
  // Only show hints when in nearby or route mode
  if (activeMode !== 'nearby' && activeMode !== 'route') {
    hintTooMany.classList.remove('active');
    hintNoResults.classList.remove('active');
    return;
  }
  
  const tooManyViews = getHintViewCount('tooMany');
  const noResultViews = getHintViewCount('noResults');

  const hasNonDefaultFilter = regionVal || stateVal || searchVal;
  const hasAnyFilter = typeVal || hasNonDefaultFilter;
  
  // Priority 1: No Results hint
  if (visibleCount === 0 && hasAnyFilter && noResultViews < 1) {
    if (hintNoResults.dataset.active !== 'true') {
      incrementHintViewCount('noResults');
    }
    hintNoResults.dataset.active = 'true';
    hintNoResults.classList.add('active');
    hintTooMany.classList.remove('active');
    hintTooMany.dataset.active = '';
    startHintAutoHide('noResults');
    return;
  } else {
    hintNoResults.classList.remove('active');
    hintNoResults.dataset.active = '';
    clearHintAutoHide('noResults');
  }
  
  // Priority 2: Too Many Colleges hint (only if No Results is not showing)
  if (visibleCount > 30 && !typeVal && tooManyViews < 1) {
    if (hintTooMany.dataset.active !== 'true') {
      incrementHintViewCount('tooMany');
    }
    hintTooMany.dataset.active = 'true';
    hintTooMany.classList.add('active');
    startHintAutoHide('tooMany');
  } else {
    hintTooMany.classList.remove('active');
    hintTooMany.dataset.active = '';
    clearHintAutoHide('tooMany');
  }
}

/**
 * Dismiss a map hint and store in sessionStorage
 */
function dismissMapHint(type) {
  if (type === 'tooMany') {
    const hint = document.getElementById('hint-too-many-colleges');
    if (hint) {
      hint.classList.remove('active');
      hint.dataset.active = '';
    }
    clearHintAutoHide('tooMany');
  } else if (type === 'noResults') {
    const hint = document.getElementById('hint-no-colleges');
    if (hint) {
      hint.classList.remove('active');
      hint.dataset.active = '';
    }
    clearHintAutoHide('noResults');
  } else if (type === 'noSavedColleges') {
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) hint.classList.remove('active');
    // Automatically turn off Saved Only toggle and restore previous state
    if (savedOnlyMode) {
      savedOnlyMode = false;
      const savedControls = document.getElementById("saved-controls");
      if (savedControls) {
        savedControls.classList.remove("saved-only-active");
      }
      // Re-render map without saved-only filter
      if (activeMode === 'route' && route.lastSearch) {
        refilterCollegesAlongRoute();
      } else {
        render();
      }
    }
  }
}

function getHintStorageKey(type) {
  return type === 'tooMany' ? 'ucm_hintTooManyCount' : 'ucm_hintNoResultsCount';
}

function getHintViewCount(type) {
  const key = getHintStorageKey(type);
  const val = parseInt(sessionStorage.getItem(key) || '0', 10);
  return Number.isNaN(val) ? 0 : val;
}

function incrementHintViewCount(type) {
  const key = getHintStorageKey(type);
  const current = getHintViewCount(type);
  const maxViews = type === 'tooMany' ? 1 : HINT_MAX_VIEWS;
  sessionStorage.setItem(key, String(Math.min(maxViews, current + 1)));
}

function startHintAutoHide(type) {
  clearHintAutoHide(type);
  mapHintTimeouts[type] = setTimeout(() => {
    dismissMapHint(type);
  }, 60000);
}

function clearHintAutoHide(type) {
  if (mapHintTimeouts[type]) {
    clearTimeout(mapHintTimeouts[type]);
    mapHintTimeouts[type] = null;
  }
}


/**
 * Show the map tip bubble pointing to a blue dot near the center
 * Only shows for first-time users when blue dots first appear
 */
function showMapTip() {
  const tipBubble = document.getElementById('map-tip-bubble');
  if (!tipBubble || !map) return;
  
  // Check if already seen this session
  if (sessionStorage.getItem('ucm_seenTapDotHint') === '1') {
    return;
  }
  
  // Check if user has seen it before (first-time user check)
  if (localStorage.getItem('ucm_seenTapDotHint') === '1') {
    return;
  }
  
  // Find a blue dot (unsaved marker) near the center of the map
  const mapCenter = map.getCenter();
  let closestBlueDot = null;
  let closestDistance = Infinity;
  
  markersLayer.eachLayer((layer) => {
    // Check if this is a blue dot (circleMarker, not a saved marker with icon)
    if (layer instanceof L.CircleMarker || (layer.options && layer.options.radius !== undefined)) {
      const markerLatLng = layer.getLatLng();
      const distance = mapCenter.distanceTo(markerLatLng);
      
      if (distance < closestDistance) {
        closestDistance = distance;
        closestBlueDot = markerLatLng;
      }
    }
  });
  
  // If no blue dot found, don't show the tip
  if (!closestBlueDot) {
    return;
  }
  
  // Convert marker position to pixel coordinates
  const markerPoint = map.latLngToContainerPoint(closestBlueDot);
  const bubbleHeight = 60; // Approximate height of bubble
  const bubbleOffset = 10; // Space between bubble and marker
  
  // Position bubble above the marker
  tipBubble.style.top = `${markerPoint.y - bubbleHeight - bubbleOffset}px`;
  tipBubble.style.left = `${markerPoint.x}px`;
  tipBubble.style.transform = 'translateX(-50%)';
  tipBubble.style.right = 'auto';
  
  // Show the tip bubble
  tipBubble.classList.add('active');
  
  // Auto-hide after 8 seconds
  setTimeout(() => {
    dismissMapTip();
  }, 8000);
}

/**
 * Dismiss the map tip bubble and store in sessionStorage and localStorage
 */
function dismissMapTip() {
  sessionStorage.setItem('ucm_seenTapDotHint', '1');
  localStorage.setItem('ucm_seenTapDotHint', '1');
  const tipBubble = document.getElementById('map-tip-bubble');
  if (tipBubble) tipBubble.classList.remove('active');
}

// Saved controls functions
let savedSearchTimeout = null;
let savedSearchResults = [];
const mapHintTimeouts = {
  tooMany: null,
  noResults: null
};
const HINT_MAX_VIEWS = 3;
let routeHintShown = sessionStorage.getItem(ROUTE_HINT_KEY) === '1';
let routeHintUserInteracted = false;
let routeHintDismissTimer = null;

function openSavedListPanel() {
  const overlay = document.getElementById('saved-colleges-overlay');
  if (overlay && !overlay.classList.contains('active')) {
    overlay.classList.add('active');
    // Lower z-index of saved-controls so pill appears behind overlay
    const savedControls = document.getElementById('saved-controls');
    if (savedControls) {
      savedControls.style.zIndex = '2500';
    }
    freezeMapInteractions();
    updateSavedOverlay();
    // Focus search input
    const searchInput = document.getElementById('saved-search-input');
    if (searchInput) {
      setTimeout(() => searchInput.focus(), 100);
    }
    // Track saved list opened
    if (typeof gtag !== 'undefined') {
      gtag('event', 'feature_saved_list_opened');
    }
  }
}

function closeSavedListPanel() {
  const overlay = document.getElementById('saved-colleges-overlay');
  if (overlay && overlay.classList.contains('active')) {
    overlay.classList.remove('active');
    // Restore z-index of saved-controls
    const savedControls = document.getElementById('saved-controls');
    if (savedControls) {
      savedControls.style.zIndex = '';
    }
    resumeMapInteractions();
    // Clear search
    const searchInput = document.getElementById('saved-search-input');
    const searchResults = document.getElementById('saved-search-results');
    if (searchInput) searchInput.value = '';
    if (searchResults) {
      searchResults.classList.remove('active');
      searchResults.innerHTML = '';
    }
  }
}

function updateSavedOverlay() {
  const savedIds = SavedStore.getAll();
  const countEl = document.getElementById('saved-overlay-count');
  const listEl = document.getElementById('saved-colleges-list');
  const unsaveAllBtn = document.getElementById('unsave-all-btn');
  
  if (countEl) {
    countEl.textContent = `${savedIds.length} Colleges Saved`;
  }
  
  if (unsaveAllBtn) {
    unsaveAllBtn.style.display = savedIds.length > 0 ? 'block' : 'none';
  }
  
  if (listEl) {
    if (savedIds.length === 0) {
      listEl.innerHTML = `
        <div class="saved-empty-state">
          <div class="saved-empty-state-title">You haven't saved any colleges yet.</div>
          <div class="saved-empty-state-text">Tap a college on the map or use search above to start a saved list.</div>
        </div>
      `;
    } else {
      listEl.innerHTML = savedIds.map(collegeId => {
        const college = collegesById[collegeId];
        if (!college) return '';
        const typeDisplay = college.type || 'Unknown';
        return `
          <div class="saved-college-item" data-college-id="${collegeId}">
            <div class="saved-college-info">
              <div class="saved-college-name">${escapeHtml(college.name)}</div>
              <div class="saved-college-details">${college.state} · ${escapeHtml(typeDisplay)}</div>
            </div>
            <button class="saved-college-unsave-btn" onclick="unsaveCollegeFromOverlay('${collegeId}')">
              <span style="color: #16a34a;">★</span> Saved
            </button>
          </div>
        `;
      }).join('');
    }
  }
}

function setupRouteHint() {
  const routeHint = document.getElementById('route-hint-bubble');
  const startInput = elements.routeStart;
  const endInput = elements.routeEnd;
  if (!routeHint || !startInput || !endInput || routeHintShown) return;

  const handleEvent = (event) => {
    if (routeHintShown) return;
    if (event && (event.type === 'input' || event.type === 'change')) {
      routeHintUserInteracted = true;
    }
    const force = event ? event.type === 'blur' : false;
    maybeShowRouteHint(force);
  };

  ['input', 'change', 'blur'].forEach(evtName => {
    startInput.addEventListener(evtName, handleEvent);
    endInput.addEventListener(evtName, handleEvent);
  });
}

function maybeShowRouteHint(force = false) {
  if (routeHintShown) return;
  const startFilled = !!(elements.routeStart && elements.routeStart.value.trim());
  const endFilled = !!(elements.routeEnd && elements.routeEnd.value.trim());
  if (!startFilled || !endFilled) return;
  if (!routeHintUserInteracted && !force) return;
  showRouteHintBubble();
}

function notifyRouteInputsUpdated(forceUserInteraction = false) {
  if (forceUserInteraction) {
    routeHintUserInteracted = true;
  }
  maybeShowRouteHint(forceUserInteraction);
}

function showRouteHintBubble() {
  const routeHint = document.getElementById('route-hint-bubble');
  const exploreBtn = elements.findRouteBtn;
  if (!routeHint || !exploreBtn || routeHintShown) return;

  routeHint.style.display = 'block';
  routeHint.style.visibility = 'hidden';
  routeHint.classList.remove('visible');
  routeHint.classList.remove('below');

  const buttonRect = exploreBtn.getBoundingClientRect();
  const headerRect = document.querySelector('.app-header')?.getBoundingClientRect();
  const bubbleRect = routeHint.getBoundingClientRect();
  const minTop = headerRect ? headerRect.bottom + 8 : 12;
  let placeBelow = false;
  let top = buttonRect.top - bubbleRect.height - 8;
  if (top < minTop) {
    top = Math.max(buttonRect.bottom + 8, minTop);
    placeBelow = true;
  }
  if (placeBelow) {
    routeHint.classList.add('below');
  }
  let left = buttonRect.left + (buttonRect.width / 2) - (bubbleRect.width / 2);
  const maxLeft = window.innerWidth - bubbleRect.width - 12;
  left = Math.min(Math.max(12, left), maxLeft);

  routeHint.style.top = `${top}px`;
  routeHint.style.left = `${left}px`;
  routeHint.style.visibility = 'visible';

  requestAnimationFrame(() => {
    routeHint.classList.add('visible');
  });

  if (routeHintDismissTimer) {
    clearTimeout(routeHintDismissTimer);
    routeHintDismissTimer = null;
  }
  routeHint.onclick = () => dismissRouteHint();
  routeHintDismissTimer = setTimeout(() => dismissRouteHint(), 5000);
  routeHintShown = true;
  sessionStorage.setItem(ROUTE_HINT_KEY, '1');
}

function dismissRouteHint() {
  const routeHint = document.getElementById('route-hint-bubble');
  if (!routeHint) return;
  routeHint.onclick = null;
  routeHint.classList.remove('visible');
  if (routeHintDismissTimer) {
    clearTimeout(routeHintDismissTimer);
    routeHintDismissTimer = null;
  }
  setTimeout(() => {
    routeHint.style.display = 'none';
    routeHint.style.visibility = '';
  }, 200);
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Search functionality
function initSavedSearch() {
  const searchInput = document.getElementById('saved-search-input');
  if (!searchInput) return;
  
  searchInput.addEventListener('input', (e) => {
    const query = (e.target.value || '').trim().toLowerCase();
    const resultsEl = document.getElementById('saved-search-results');
    
    if (!resultsEl) return;
    
    // Clear previous timeout
    if (savedSearchTimeout) {
      clearTimeout(savedSearchTimeout);
    }
    
    if (query.length < 2) {
      resultsEl.classList.remove('active');
      resultsEl.innerHTML = '';
      return;
    }
    
    // Debounce search
    savedSearchTimeout = setTimeout(() => {
      const queryLower = query.toLowerCase();
      const queryWords = queryLower.split(/\s+/).filter(w => w.length > 0);
      
      // Score and filter colleges
      const scored = colleges.map(college => {
        if (!college.name) return null;
        const nameLower = college.name.toLowerCase();
        
        // Perfect match (exact)
        if (nameLower === queryLower) {
          return { college, score: 1000, matchType: 'exact' };
        }
        
        // Starts with query
        if (nameLower.startsWith(queryLower)) {
          return { college, score: 500, matchType: 'starts' };
        }
        
        // Contains query as substring
        if (nameLower.includes(queryLower)) {
          return { college, score: 300, matchType: 'contains' };
        }
        
        // Word-based matching
        const nameWords = nameLower.split(/\s+/);
        let wordMatches = 0;
        let allWordsMatch = true;
        
        for (const queryWord of queryWords) {
          let wordMatched = false;
          for (const nameWord of nameWords) {
            if (nameWord.startsWith(queryWord)) {
              wordMatches += 2; // Word starts with query word
              wordMatched = true;
              break;
            } else if (nameWord.includes(queryWord)) {
              wordMatches += 1; // Word contains query word
              wordMatched = true;
              break;
            }
          }
          if (!wordMatched) {
            allWordsMatch = false;
          }
        }
        
        if (wordMatches > 0) {
          const score = allWordsMatch ? 200 + wordMatches : 100 + wordMatches;
          return { college, score, matchType: 'words' };
        }
        
        return null;
      }).filter(item => item !== null);
      
      // Sort by score (highest first), then alphabetically
      scored.sort((a, b) => {
        if (b.score !== a.score) {
          return b.score - a.score;
        }
        return a.college.name.localeCompare(b.college.name);
      });
      
      const matches = scored.slice(0, 10).map(item => item.college);
      
      if (matches.length === 0) {
        resultsEl.classList.remove('active');
        resultsEl.innerHTML = '';
        return;
      }
      
      resultsEl.innerHTML = matches.map(college => {
        const isSaved = SavedStore.isSaved(college.college_id);
        const typeDisplay = college.type || 'Unknown';
        const collegeIdEscaped = escapeHtml(college.college_id);
        return `
          <div class="saved-search-result-item" data-college-id="${collegeIdEscaped}">
            <div class="saved-search-result-info">
              <div class="saved-search-result-name">${escapeHtml(college.name)}</div>
              <div class="saved-search-result-details">${college.state} · ${escapeHtml(typeDisplay)}</div>
            </div>
            <button class="saved-search-result-save-btn ${isSaved ? 'saved' : ''}" 
                    data-college-id="${collegeIdEscaped}"
                    onclick="saveCollegeFromSearch('${collegeIdEscaped.replace(/'/g, "\\'")}')">
              <span style="color: ${isSaved ? '#16a34a' : '#64748b'}; display: inline-block; width: 12px; text-align: center; line-height: 1;">${isSaved ? '★' : '☆'}</span>
              ${isSaved ? 'Saved' : 'Save'}
            </button>
          </div>
        `;
      }).join('');
      
      resultsEl.classList.add('active');
      resultsEl.scrollTop = 0; // Reset scroll to top
      savedSearchResults = matches;
    }, 200);
  });
  
  // Close results when clicking outside
  document.addEventListener('click', (e) => {
    const searchInput = document.getElementById('saved-search-input');
    if (!searchInput) return;
    const searchWrapper = searchInput.closest('.saved-search-wrapper');
    if (searchWrapper && !searchWrapper.contains(e.target)) {
      const resultsEl = document.getElementById('saved-search-results');
      if (resultsEl) {
        resultsEl.classList.remove('active');
      }
    }
  });
}

function saveCollegeFromSearch(collegeId) {
  if (!collegeId) return;
  
  SavedStore.toggle(collegeId);
  updateMarkerIcon(collegeId);
  updateSavedOverlay();
  
  // Update search result button using data attribute
  const resultsEl = document.getElementById('saved-search-results');
  if (resultsEl) {
    const btn = resultsEl.querySelector(`button[data-college-id="${collegeId}"]`);
    if (btn) {
      const isSaved = SavedStore.isSaved(collegeId);
      if (isSaved) {
        btn.classList.add('saved');
      } else {
        btn.classList.remove('saved');
      }
      btn.innerHTML = `
        <span style="color: ${isSaved ? '#16a34a' : '#64748b'}; display: inline-block; width: 12px; text-align: center; line-height: 1;">${isSaved ? '★' : '☆'}</span>
        ${isSaved ? 'Saved' : 'Save'}
      `;
    }
  }
  
  // Re-render if saved-only mode is on
  if (savedOnlyMode) {
    if (activeMode === 'route' && route.lastSearch) {
      refilterCollegesAlongRoute();
    } else {
      render();
    }
  }
}

function getSavedOverlayItem(collegeId) {
  if (!collegeId) return null;
  const selector = '.saved-college-item[data-college-id="%s"]';
  if (window.CSS && CSS.escape) {
    return document.querySelector(selector.replace('%s', CSS.escape(collegeId)));
  }
  return document.querySelector(selector.replace('%s', collegeId.replace(/"/g, '\\"')));
}

function unsaveCollegeFromOverlay(collegeId) {
  if (!collegeId) return;
  
  const listItem = getSavedOverlayItem(collegeId);
  if (listItem) {
    listItem.classList.add('removing');
  }
  
  const finalize = () => {
    SavedStore.toggle(collegeId);
    updateMarkerIcon(collegeId);
    updateSavedOverlay();
    
    if (savedOnlyMode) {
      if (activeMode === 'route' && route.lastSearch) {
        refilterCollegesAlongRoute();
      } else {
        render();
      }
    }
  };
  
  if (listItem) {
    setTimeout(finalize, 260);
  } else {
    finalize();
  }
}

function updateMarkerIcon(collegeId) {
  const marker = markersByCollegeId[collegeId];
  if (!marker) return;
  
  const isSaved = SavedStore.isSaved(collegeId);
  const latlng = marker.getLatLng();
  const popup = marker.getPopup();
  const tooltip = marker.getTooltip();
  const popupContent = popup ? popup.getContent() : '';
  const tooltipContent = tooltip ? tooltip.getContent() : '';
  const wasPopupOpen = popup && marker.isPopupOpen();
  
  marker.remove();
  
  let newMarker;
  if (isSaved) {
    // Use green pin icon for saved colleges with dynamic sizing
    const iconSize = getCurrentSavedIconSize();
    newMarker = L.marker(latlng, { icon: createGreenSavedIcon(iconSize) });
  } else {
    // Use dynamic radius for touch devices
    const radius = getCurrentMarkerRadius();
    newMarker = L.circleMarker(latlng, { radius: radius, color: '#2563eb', weight: 2, fillOpacity: 0.7 });
  }
  
  if (popupContent) newMarker.bindPopup(popupContent);
  if (tooltipContent) newMarker.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
  newMarker.addTo(markersLayer);
  markersByCollegeId[collegeId] = newMarker;
  
  if (wasPopupOpen) {
    newMarker.openPopup();
  }
}

function confirmUnsaveAll() {
  const modal = document.getElementById('unsave-all-modal');
  if (modal) {
    modal.classList.add('active');
  }
}

function closeUnsaveAllModal() {
  const modal = document.getElementById('unsave-all-modal');
  if (modal) {
    modal.classList.remove('active');
  }
}

function unsaveAllColleges() {
  const savedIds = SavedStore.getAll();
  
  savedIds.forEach(collegeId => {
    SavedStore.toggle(collegeId);
    updateMarkerIcon(collegeId);
  });
  
  closeUnsaveAllModal();
  updateSavedOverlay();

  // If Saved Only was on, turn it off and revert UI/state
  if (savedOnlyMode) {
    savedOnlyMode = false;
    const savedControls = document.getElementById("saved-controls");
    const savedOnlySection = document.getElementById("saved-only-section");
    if (savedControls) {
      savedControls.classList.remove("saved-only-active");
    }
    if (savedOnlySection) {
      savedOnlySection.classList.remove("saved-only-active");
    }
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) hint.classList.remove('active');
  }
  
  // Re-render to reflect unsaved state with saved-only off
  if (activeMode === 'route' && route.lastSearch) {
    refilterCollegesAlongRoute();
  } else {
    render();
  }
}

// savedOnlyMode is declared earlier in the file (near line 2262) for early initialization
// let savedOnlyMode = false;
function toggleSavedOnly() {
  savedOnlyMode = !savedOnlyMode;
  const savedControls = document.getElementById("saved-controls");
  const savedOnlySection = document.getElementById("saved-only-section");
  if (savedControls) {
    savedControls.classList.toggle("saved-only-active", savedOnlyMode);
  }
  if (savedOnlySection) {
    savedOnlySection.classList.toggle("saved-only-active", savedOnlyMode);
  }
  console.log("Saved Only:", savedOnlyMode);
  // Track saved only toggle
  if (typeof gtag !== 'undefined') {
    gtag('event', 'feature_saved_only_toggled');
  }
  
  // Check if Saved Only is turned ON and there are no saved colleges
  if (savedOnlyMode) {
    const savedIds = SavedStore.getAll();
    if (savedIds.length === 0) {
      // Show notice that there are no saved colleges yet
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) {
        hint.classList.add('active');
        // Auto-dismiss after 8 seconds and turn off toggle
        setTimeout(() => {
          if (hint) {
            hint.classList.remove('active');
            // Automatically turn off Saved Only toggle and restore previous state
            if (savedOnlyMode) {
              savedOnlyMode = false;
              const savedControls = document.getElementById("saved-controls");
              const savedOnlySection = document.getElementById("saved-only-section");
              if (savedControls) {
                savedControls.classList.remove("saved-only-active");
              }
              if (savedOnlySection) {
                savedOnlySection.classList.remove("saved-only-active");
              }
              // Re-render map without saved-only filter
              if (activeMode === 'route' && route.lastSearch) {
                refilterCollegesAlongRoute();
              } else {
                render();
              }
            }
          }
        }, 8000);
      }
    } else {
      // Hide the notice if it was showing
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) hint.classList.remove('active');
    }
  } else {
    // Hide the notice when Saved Only is turned OFF
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) hint.classList.remove('active');
    // Remove active class from saved-only-section when turning OFF
    const savedOnlySection = document.getElementById("saved-only-section");
    if (savedOnlySection) {
      savedOnlySection.classList.remove("saved-only-active");
    }
  }
  
  // Defer heavy rendering work to allow toggle UI feedback to appear first
  requestAnimationFrame(() => {
    // Re-render map with saved-only filter
    if (activeMode === 'route' && route.lastSearch) {
      // Use cached route data to avoid redrawing the route line
      refilterCollegesAlongRoute();
    } else {
      render();
    }
  });
}

// Placeholder function for share icon click
// Toast notification system
const toast = (() => {
  let toastElement = null;
  let hideTimer = null;
  
  const init = () => {
    if (!toastElement) {
      const mapContainer = document.getElementById('map');
      if (mapContainer) {
        toastElement = document.createElement('div');
        toastElement.className = 'toast';
        toastElement.id = 'share-toast';
        toastElement.innerHTML = '<div class="toast-message"></div>';
        mapContainer.appendChild(toastElement);
      }
    }
    return toastElement;
  };
  
  const show = (message, duration = 3000) => {
    const toast = init();
    const messageEl = toast.querySelector('.toast-message');
    if (messageEl) {
      messageEl.textContent = message;
    }
    toast.classList.add('active');
    
    if (hideTimer) {
      clearTimeout(hideTimer);
    }
    hideTimer = setTimeout(() => {
      hide();
    }, duration);
  };
  
  const hide = () => {
    if (toastElement) {
      toastElement.classList.remove('active');
    }
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }
  };
  
  return { show, hide };
})();

// Generate share URL
function generateShareURL() {
  const baseUrl = window.location.origin + window.location.pathname;
  const params = new URLSearchParams();
  
  // Flag for shared saved map
  params.set('view', 'savedshare');
  
  // Get saved college IDs and normalize to strings
  const savedIds = SavedStore.getAll();
  if (savedIds.length > 0) {
    // Ensure all IDs are strings for consistent URL encoding
    const normalizedIds = savedIds.map(id => String(id).trim()).filter(id => id);
    params.set('colleges', normalizedIds.join(','));
    console.log('[generateShareURL] Sharing', normalizedIds.length, 'college IDs:', normalizedIds.slice(0, 5));
  }
  
  // Get current map center and zoom
  const center = map.getCenter();
  const zoom = map.getZoom();
  params.set('lat', center.lat.toFixed(6));
  params.set('lng', center.lng.toFixed(6));
  params.set('zoom', zoom.toString());
  
  // Add mode-specific data
  if (activeMode === 'nearby' && home) {
    params.set('mode', 'nearby');
    params.set('homeLat', home.lat.toFixed(6));
    params.set('homeLng', home.lon.toFixed(6));
    if (elements.radius && elements.radius.value) {
      params.set('radius', elements.radius.value);
    }
    if (elements.units && elements.units.value) {
      params.set('units', elements.units.value);
    }
  } else if (activeMode === 'route' && route.start && route.end) {
    params.set('mode', 'route');
    params.set('startLat', route.start.lat.toFixed(6));
    params.set('startLng', route.start.lon.toFixed(6));
    params.set('endLat', route.end.lat.toFixed(6));
    params.set('endLng', route.end.lon.toFixed(6));
    if (elements.routeMaxDistance && elements.routeMaxDistance.value) {
      params.set('routeRadius', elements.routeMaxDistance.value);
    }
    if (elements.routeUnits && elements.routeUnits.value) {
      params.set('routeUnits', elements.routeUnits.value);
    }
  } else {
    params.set('mode', 'explore');
  }
  
  return `${baseUrl}?${params.toString()}`;
}

// Copy to clipboard
async function copyToClipboard(text) {
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      const success = document.execCommand('copy');
      document.body.removeChild(textArea);
      return success;
    }
  } catch (err) {
    console.error('Failed to copy to clipboard:', err);
    return false;
  }
}

// Share icon click handler
async function handleSavedShareClick(event) {
  event.stopPropagation();
  
  // Hide tooltip on click (desktop) - it will reappear when mouse leaves and re-enters
  const shareIcon = document.getElementById('saved-share-icon');
  const tooltip = shareIcon?.querySelector('.saved-share-tooltip');
  if (tooltip) {
    tooltip.classList.add('tooltip-hidden');
    // Remove hidden class when mouse leaves the icon so tooltip can show again on next hover
    const handleMouseLeave = () => {
      tooltip.classList.remove('tooltip-hidden');
      shareIcon.removeEventListener('mouseleave', handleMouseLeave);
    };
    shareIcon.addEventListener('mouseleave', handleMouseLeave);
  }
  
  // Generate share URL
  const shareUrl = generateShareURL();
  
  // Google Analytics: Track share action
  if (typeof gtag !== 'undefined') {
    const savedIds = SavedStore.getAll();
    const mode = activeMode || 'explore';
    gtag('event', 'feature_share_used', {
      'college_count': savedIds.length,
      'mode': mode
    });
  }
  
  // Copy to clipboard
  const copied = await copyToClipboard(shareUrl);
  
  if (copied) {
    // Show success toast
    toast.show('Link copied — share this map of your saved colleges.', 4000);
  }
  // If copy fails, silently do nothing (as per MVP requirements)
}

function isLocalStorageAvailable() {
  try {
    const testKey = '__ucm_storage_test__';
    localStorage.setItem(testKey, '1');
    localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    console.warn('localStorage unavailable:', e);
    return false;
  }
}

function parseCollegesCSV(csvText, sourceLabel = 'network') {
  return new Promise((resolve, reject) => {
    Papa.parse(csvText, {
      header: true,
      dynamicTyping: true,
      complete: (results) => {
        if (results.errors && results.errors.length) {
          console.warn(`CSV parsing warnings from ${sourceLabel}:`, results.errors);
        }
        if (!results.data || !results.data.length) {
          reject(new Error('No data rows in CSV'));
          return;
        }
        console.log(`CSV parsing complete from ${sourceLabel}. Rows:`, results.data.length);
        resolve(results.data);
      },
      error: (error) => {
        reject(error);
      }
    });
  });
}

function loadCSV(url){
  if (elements.loading) elements.loading.classList.add('active');
  
  const canUseStorage = isLocalStorageAvailable();
  let cachedCSV = null;
  let cacheLoaded = false;
  
  const handleDataLoad = (data) => {
    processCollegesData(data);
    cacheLoaded = true;
    if (elements.loading) elements.loading.classList.remove('active');
    
    // Apply shared view state after data loads
    console.log('[handleDataLoad] Checking shared view:', { isSharedView, hasSharedViewState: !!window.sharedViewState, sharedViewState: window.sharedViewState });
    if (isSharedView && window.sharedViewState) {
      console.log('[handleDataLoad] Calling applySharedViewState()');
      applySharedViewState();
    } else {
      console.warn('[handleDataLoad] Not applying shared view state - isSharedView:', isSharedView, 'hasSharedViewState:', !!window.sharedViewState);
    }
  };
  
  if (canUseStorage) {
    try {
      cachedCSV = localStorage.getItem(COLLEGE_CACHE_KEY);
      if (cachedCSV) {
        parseCollegesCSV(cachedCSV, 'cache')
          .then(handleDataLoad)
          .catch(err => {
            console.warn('Failed to parse cached CSV:', err);
          });
      }
    } catch (e) {
      console.warn('Unable to read cached CSV:', e);
    }
  }
  
  fetch(url, { cache: 'no-cache' })
    .then(response => {
      if (!response.ok) {
        throw new Error(`Network response not ok (${response.status})`);
      }
      return response.text();
    })
    .then(csvText => {
      const cachedMatches = cachedCSV && csvText === cachedCSV;
      const shouldProcess = !cachedMatches || !cacheLoaded;
      const parseLabel = cachedMatches ? 'network-sync' : (cachedCSV ? 'network-refresh' : 'network');
      
      if (canUseStorage) {
        try {
          if (!cachedMatches) {
            localStorage.setItem(COLLEGE_CACHE_KEY, csvText);
          }
        } catch (e) {
          console.warn('Failed to cache CSV text:', e);
        }
      }
      
      if (shouldProcess) {
        return parseCollegesCSV(csvText, parseLabel)
          .then(handleDataLoad);
      }
    })
    .catch(error => {
      console.error('CSV fetch error:', error);
      if (!cacheLoaded) {
        if (elements.loading) elements.loading.classList.remove('active');
        showError('Error loading colleges data: ' + (error.message || 'Unknown error'));
      } else {
        console.warn('Using cached CSV due to fetch error.');
      }
    });
}

/**
 * Generate a stable fallback college_id for rows missing one.
 */
function buildFallbackCollegeId(row) {
  const safeName = (row.name || 'college')
    .toString()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '') || 'college';
  const state = (row.state || 'XX').toString().toUpperCase();
  const lat = Number(row.lat);
  const lon = Number(row.lon);
  const latStr = Number.isFinite(lat) ? lat.toFixed(3) : '0.000';
  const lonStr = Number.isFinite(lon) ? lon.toFixed(3) : '0.000';
  return `${safeName}_${state}_${latStr}_${lonStr}`;
}

/**
 * Process CSV data and map to internal college objects.
 * 
 * REQUIRED CSV COLUMNS (for creating a "slim" CSV):
 * - name: College name (used in search, popups, tooltips)
 * - lat: Latitude (required for map markers, radius/route filtering)
 * - lon: Longitude (required for map markers, radius/route filtering)
 * - state: State code (used in state filter, region filter, popups)
 * - type: College type (used in type filter dropdown, popups, TYPE_ORDER ranking)
 * - tier: Alternative type field (used as fallback in type filter: c.type || c.tier)
 * - control: Control type (used in popups: "Public | Private")
 * - acceptance: Acceptance rate (used in popups)
 * - enrollment: Enrollment number (used in popups)
 * - tuition: Tuition cost (used in popups)
 * - url: College website URL (used in popups as clickable link)
 * 
 * All other CSV columns can be removed to reduce payload size.
 */
// Lookup object: college_id -> college object
let collegesById = {};

function processCollegesData(data) {
  let processedCount = 0;
  colleges = data.filter(r => r.name && r.lat && r.lon).map(r => {
    const rawId = (r.college_id || '').toString().trim();
    const collegeId = rawId || buildFallbackCollegeId(r);
    
    // Debug: Log first few college IDs to verify format matches shared IDs
    if (isSharedView && sharedViewIds && processedCount < 3) {
      console.log(`[processCollegesData] College ID: "${collegeId}" (type: ${typeof collegeId})`);
      processedCount++;
    }
    
    return {
      college_id: collegeId,
      name: r.name,
      lat: +r.lat,
      lon: +r.lon,
      state: (r.state || '').toUpperCase(),
      type: r.type || 'Unknown',
      tier: r.tier || '', // Used as fallback in type filter: (c.type || c.tier)
      control: r.control || '',
      acceptance: r.acceptance || '',
      enrollment: r.enrollment || '',
      tuition: r.tuition || '',
      url: r.url || '',
      top25_univ: (r.top25_univ || '').toString().trim(),
      top50_univ: (r.top50_univ || '').toString().trim(),
      top10_lac: (r.top10_lac || '').toString().trim(),
      top20_lac: (r.top20_lac || '').toString().trim()
    };
  });
  
  // Build collegesById lookup
  collegesById = {};
  colleges.forEach(c => {
    if (c.college_id) {
      collegesById[c.college_id] = c;
    }
  });
  
  console.log(`Loaded ${colleges.length} colleges`);
  
  if (colleges.length === 0) {
    showError('No college data found. Please check the CSV file.');
    return;
  }
  
  const states = [...new Set(colleges.map(c => c.state))].sort();
  const types = [...new Set(colleges.map(c => c.type))].filter(Boolean);
  const ranked = [...TYPE_ORDER.filter(t => types.includes(t))];
  const leftovers = types.filter(t => !TYPE_ORDER.includes(t)).sort();
  const orderedTypes = ranked.concat(leftovers);
  
  refreshDropdown('state', states, 'All states');
  refreshDropdown('type', orderedTypes, 'All college types');
  refreshDropdown('region', ['Northeast', 'Midwest', 'South', 'West', 'Territories'], 'All regions');
  
  // Update dropdown placeholders based on current screen size (after dropdowns are refreshed)
  updateDropdownPlaceholders();
  
  // Position ranking dropdown after CSV loads
  if (typeof positionRankingDropdown === 'function') {
    positionRankingDropdown();
  }
  
  // Update filter chips after dropdowns are populated
  if (typeof updateFilterChips === 'function') {
    updateFilterChips();
  }
  
  // Ensure we're in nearby mode on initial load (default section is open)
  activeMode = 'nearby';
  
  // Render colleges on initial load (skip if in shared view - applySharedViewState will handle it)
  if (!isSharedView) {
    render();
  } else {
    console.log('Skipping initial render - shared view will handle rendering');
  }
  
}

function geocodeAddress(address, mode = 'nearby'){
  if(!address) {
    if (mode === 'nearby') {
      showError('Please enter an address');
    }
    return Promise.resolve(null);
  }
  
  // Only update map if in the correct active mode
  const shouldUpdateMap = (mode === 'nearby' && activeMode === 'nearby') || (mode === 'route' && activeMode === 'route');
  
  if (mode === 'nearby') {
    closeAutocomplete();
  }
  if (shouldUpdateMap && elements.loading) {
    elements.loading.classList.add('active');
  }
  
  // Note: Address geocoding is independent of state filter - it does not modify state/region/type filters
  // Rate limiting: Nominatim requires a User-Agent and has strict rate limits
  return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`, {
    headers: {
      'User-Agent': 'USCollegeMap/1.0'
    }
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (shouldUpdateMap && elements.loading) {
        elements.loading.classList.remove('active');
      }
      
      if (data && data[0]) {
        const lat = +data[0].lat;
        const lon = +data[0].lon;
        
        if (mode === 'nearby') {
          // Store in nearby state
          home = { lat, lon };
          nearbyState.home = { lat, lon };
          nearbyState.address = address;
          nearbyState.radius = elements.radius ? elements.radius.value : '30';
          nearbyState.units = elements.units ? elements.units.value : 'mi';
          
          // Only update map if nearby mode is active
          if (activeMode === 'nearby') {
        homeLayer.clearLayers();
            radiusLayer.clearLayers();
            
            // Add "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([lat, lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
            
            map.setView([lat, lon], 8);
            render(); // Re-render to apply radius filter
            // Track nearby search completion
            if (typeof gtag !== 'undefined') {
              gtag('event', 'feature_nearby_used');
            }
          }
          saveSharedLocation(address, lat, lon);
          saveRecent(RECENT_STORAGE_KEYS.nearby, address);
          return { lat, lon };
        } else if (mode === 'route') {
          // Return for route mode (caller will store it)
          saveSharedLocation(address, lat, lon);
          return { lat, lon, description: address };
        }
      } else {
        if (shouldUpdateMap) {
          showError('Address not found. Please try a different address.');
        }
        return null;
      }
    })
    .catch(error => {
      if (shouldUpdateMap && elements.loading) {
        elements.loading.classList.remove('active');
        showError('Error geocoding address: ' + (error.message || 'Please try again later'));
        console.error('Geocoding error:', error);
      }
      return null;
    });
}

// Address autocomplete functions
function searchAddresses(query) {
  if (!query || query.length < 3) {
    if (!showAddressRecentsIfEligible()) {
      closeAutocomplete();
    }
    return;
  }
  clearRecentState(elements.addressSuggestions);
  
  // Cancel previous request if any
  if (addressAutocomplete.abortController) {
    addressAutocomplete.abortController.abort();
  }
  
  // Show loading state
  addressAutocomplete.suggestions = [];
  addressAutocomplete.selectedIndex = -1;
  elements.addressSuggestions.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
  elements.addressSuggestions.classList.add('active');
  addressAutocomplete.isOpen = true;
  
  // Create new abort controller
  addressAutocomplete.abortController = new AbortController();
  
  // URL encoding prevents XSS and handles special characters
  const sanitizedQuery = query.trim().substring(0, 200); // Limit query length
  
  // Use Cloudflare proxy for Google Places Autocomplete API
  fetch(`https://cold-bread-f865.cannahere2007.workers.dev/?input=${encodeURIComponent(sanitizedQuery)}`, {
    signal: addressAutocomplete.abortController.signal
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      // Handle empty array or invalid response
      if (!Array.isArray(data) || data.length === 0) {
        addressAutocomplete.suggestions = [];
        renderSuggestions();
        return;
      }
      
      // Google Places API already returns well-ranked results
      // Map the response to our format, keeping up to 5 results
      const results = data.slice(0, 5).map(item => ({
        description: item.description || '',
        place_id: item.place_id || '',
        matchedQuery: query
      }));
      
      addressAutocomplete.suggestions = results;
      renderSuggestions();
    })
    .catch(error => {
      if (error.name === 'AbortError') {
        return; // Request was cancelled, ignore
      }
      console.error('Autocomplete error:', error);
      elements.addressSuggestions.innerHTML = '<div class="autocomplete-empty" style="color:#d93025;">Unable to load suggestions. Please try again.</div>';
    });
}

function formatAddressName(displayName, query = '') {
  // Clean up the display name - remove awkward commas after street numbers
  let cleanedName = displayName.replace(/(\d+),\s+/g, '$1 '); // "25, " becomes "25 "
  
  const parts = cleanedName.split(',').map(p => p.trim()).filter(p => p);
  let primary, secondary;
  
  // Format like Google Maps: primary address on first line, location details on second
  if (parts.length >= 3) {
    // Full address: "Street Address, City, State, Country"
    // Primary: Street Address (first part)
    // Secondary: City, State, Country (remaining parts)
    primary = parts[0];
    secondary = parts.slice(1).join(', ');
  } else if (parts.length === 2) {
    // Two parts: check if first is just a number
    if (/^\d+$/.test(parts[0])) {
      // If "25, Location" -> combine to "25 Location"
      primary = parts.join(' ');
      secondary = '';
    } else {
      // "Street, City" -> Primary: Street, Secondary: City
      primary = parts[0];
      secondary = parts[1];
    }
  } else {
    // Single part
    primary = cleanedName;
    secondary = '';
  }
  
  // Escape HTML first, then apply highlighting
  // This is simpler and safer - we'll find matches in escaped text
  const escapeHtml = (text) => text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  
  // Escape the text first
  let escapedPrimary = escapeHtml(primary);
  secondary = escapeHtml(secondary);
  
  // Now apply highlighting on the escaped text
  if (query && query.length >= 2) {
    const queryLower = query.toLowerCase().trim();
    const escapedQueryLower = escapeHtml(query).toLowerCase();
    const escapedPrimaryLower = escapedPrimary.toLowerCase();
    const matchIndex = escapedPrimaryLower.indexOf(escapedQueryLower);
    
    if (matchIndex !== -1) {
      const before = escapedPrimary.substring(0, matchIndex);
      const match = escapedPrimary.substring(matchIndex, matchIndex + escapeHtml(query).length);
      const after = escapedPrimary.substring(matchIndex + escapeHtml(query).length);
      escapedPrimary = `${before}<strong>${match}</strong>${after}`;
    }
  }
  
  primary = escapedPrimary;
  
  return { primary, secondary };
}

function getAddressTypeIcon(type) {
  // Determine icon based on address type
  const icons = {
    'place': '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>',
    'house': '<path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>',
    'default': '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>'
  };
  
  const addressType = (type || '').toLowerCase();
  if (addressType.includes('house') || addressType.includes('building') || addressType.includes('residential')) {
    return icons.house;
  }
  if (addressType.includes('place') || addressType.includes('point')) {
    return icons.place;
  }
  return icons.default;
}

function renderSuggestions() {
  clearRecentState(elements.addressSuggestions);
  const queryValue = (elements.address?.value || '').trim();
  const unifiedSection = buildUnifiedRecentSection(getFallbackRecentsForField('address'), {
    query: queryValue,
    filterShared: true,
    filterFallback: true
  });
  if (addressAutocomplete.suggestions.length === 0) {
    const emptyHtml = '<div class="autocomplete-empty" role="option">No suggestions found</div>';
    elements.addressSuggestions.innerHTML = unifiedSection ? unifiedSection + emptyHtml : emptyHtml;
    return;
  }
  
  const html = addressAutocomplete.suggestions.map((item, index) => {
    const isSelected = index === addressAutocomplete.selectedIndex;
    const query = item.matchedQuery || '';
    const formatted = formatAddressName(item.description, query);
    
    // formatAddressName already escapes HTML and handles <strong> tags
    const safePrimary = formatted.primary;
    const safeSecondary = formatted.secondary;
    const safeFullName = item.description.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;');
    
    // Get icon - Google Places API doesn't provide type in autocomplete, use default
    const iconPath = getAddressTypeIcon('place');
    
    return `
      <div class="autocomplete-item ${isSelected ? 'highlighted' : ''}" 
           role="option"
           id="suggestion-${index}"
           aria-selected="${isSelected}"
           tabindex="${isSelected ? '0' : '-1'}"
           data-index="${index}">
        <div class="autocomplete-item-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            ${iconPath}
          </svg>
        </div>
        <div class="autocomplete-item-content">
          <div class="address-name">${safePrimary}</div>
          ${safeSecondary ? `<div class="address-details">${safeSecondary}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  elements.addressSuggestions.innerHTML = unifiedSection + html;
  elements.address.setAttribute('aria-expanded', 'true');
  
  // Add mouseenter handlers for highlighting
  elements.addressSuggestions.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    // Ensure item is properly clickable
    item.style.pointerEvents = 'auto';
    item.style.cursor = 'pointer';
    
    // Add direct click handler - this is the primary method
    const handleClick = (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      e.stopPropagation();
      selectSuggestion(index);
      return false;
    };
    
    item.addEventListener('click', handleClick, true);
    item.addEventListener('mousedown', (e) => {
      e.preventDefault(); // Prevent input blur
    });
    
    // Update highlight without re-rendering - just update classes
    item.addEventListener('mouseenter', () => {
      addressAutocomplete.selectedIndex = index;
      updateHighlight();
    });
    
    // Also handle touch events for mobile
    item.addEventListener('touchend', handleClick, { passive: false, capture: true });
  });
}

function selectSuggestion(index) {
  if (!addressAutocomplete.suggestions || !addressAutocomplete.suggestions[index]) {
    console.warn('No suggestion at index:', index, 'Available:', addressAutocomplete.suggestions.length);
    return;
  }
  
  const suggestion = addressAutocomplete.suggestions[index];
  const description = suggestion.description || '';
  
  if (!description) {
    console.warn('No description found for suggestion at index:', index);
    return;
  }
  
  // Mark that we're programmatically setting the value (prevents triggering new search)
  addressAutocomplete.isSelecting = true;
  
  // Close dropdown FIRST - instant visual feedback
  closeAutocomplete();
  
  // Set the input value immediately - user sees it instantly
  elements.address.value = description;
  saveRecent(RECENT_STORAGE_KEYS.nearby, description);
  
  // Clear the flag after a brief delay to allow the value to be set
  setTimeout(() => {
    addressAutocomplete.isSelecting = false;
  }, 100);
  
  // Geocode the address to update the map (this happens asynchronously)
  // Always geocode and show pin if we're in nearby mode
  // Also check if the nearby section is open (even if activeMode hasn't been set yet)
  const nearbySection = document.querySelector('details.filter-section[open] summary');
  const isNearbySectionOpen = nearbySection && nearbySection.textContent.trim().includes('Find Colleges Nearby');
  
  if (activeMode === 'nearby' || isNearbySectionOpen) {
    // Ensure activeMode is set to nearby if section is open
    if (isNearbySectionOpen && activeMode !== 'nearby') {
      activeMode = 'nearby';
    }
    geocodeAddress(description, 'nearby');
  } else {
    // Store the address value but don't update map if in route mode
    nearbyState.address = description;
  }
}

function closeAutocomplete() {
  clearRecentState(elements.addressSuggestions);
  elements.addressSuggestions.classList.remove('active');
  elements.address.setAttribute('aria-expanded', 'false');
  addressAutocomplete.isOpen = false;
  addressAutocomplete.selectedIndex = -1;
}

function updateHighlight() {
  // Update highlight without re-rendering - just update classes
  elements.addressSuggestions.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    if (index === addressAutocomplete.selectedIndex) {
      item.classList.add('highlighted');
      item.setAttribute('aria-selected', 'true');
      item.setAttribute('tabindex', '0');
    } else {
      item.classList.remove('highlighted');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('tabindex', '-1');
    }
  });
}

function handleAutocompleteKeydown(e) {
  if (!addressAutocomplete.isOpen || addressAutocomplete.suggestions.length === 0) {
    if (e.key === 'Enter') {
      e.preventDefault();
      geocodeAddress(elements.address.value);
    }
    return;
  }
  
  switch(e.key) {
    case 'ArrowDown':
      e.preventDefault();
      addressAutocomplete.selectedIndex = Math.min(
        addressAutocomplete.selectedIndex + 1,
        addressAutocomplete.suggestions.length - 1
      );
      updateHighlight();
      scrollToSelected();
      break;
      
    case 'ArrowUp':
      e.preventDefault();
      addressAutocomplete.selectedIndex = Math.max(addressAutocomplete.selectedIndex - 1, -1);
      updateHighlight();
      scrollToSelected();
      break;
      
    case 'Enter':
      e.preventDefault();
      if (addressAutocomplete.selectedIndex >= 0) {
        selectSuggestion(addressAutocomplete.selectedIndex);
      } else {
        geocodeAddress(elements.address.value);
      }
      break;
      
    case 'Escape':
      e.preventDefault();
      closeAutocomplete();
      break;
  }
}

function scrollToSelected() {
  const selected = elements.addressSuggestions.querySelector('.autocomplete-item.highlighted');
  if (selected) {
    selected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

// Route autocomplete functions (similar to address autocomplete but for route fields)
function searchRouteAddresses(query, autocompleteObj, inputElement, suggestionsContainer) {
  const storageKey = inputElement && inputElement.id === 'routeStart' ? RECENT_STORAGE_KEYS.routeStart : RECENT_STORAGE_KEYS.routeEnd;
  const context = inputElement && inputElement.id === 'routeStart' ? 'routeStart' : 'routeEnd';
  if (!query || query.length < 3) {
    if (!showRouteRecentsIfEligible(inputElement, suggestionsContainer, autocompleteObj, storageKey, context)) {
      closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement);
    }
    return;
  }
  clearRecentState(suggestionsContainer);
  
  if (autocompleteObj.abortController) {
    autocompleteObj.abortController.abort();
  }
  
  autocompleteObj.suggestions = [];
  autocompleteObj.selectedIndex = -1;
  suggestionsContainer.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
  suggestionsContainer.classList.add('active');
  autocompleteObj.isOpen = true;
  
  autocompleteObj.abortController = new AbortController();
  const sanitizedQuery = query.trim().substring(0, 200);
  
  fetch(`https://cold-bread-f865.cannahere2007.workers.dev/?input=${encodeURIComponent(sanitizedQuery)}`, {
    signal: autocompleteObj.abortController.signal
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (!data || !Array.isArray(data) || data.length === 0) {
        autocompleteObj.suggestions = [];
        renderRouteSuggestions(autocompleteObj, suggestionsContainer);
        return;
      }
      
      const results = data.slice(0, 5).map(item => ({
        description: item.description || '',
        place_id: item.place_id || ''
      }));
      
      autocompleteObj.suggestions = results;
      renderRouteSuggestions(autocompleteObj, suggestionsContainer, inputElement);
    })
    .catch(error => {
      if (error.name !== 'AbortError') {
        console.error('Route autocomplete error:', error);
        autocompleteObj.suggestions = [];
        if (suggestionsContainer) {
          suggestionsContainer.innerHTML = '<div class="autocomplete-empty" style="color:#d93025;">Unable to load suggestions. Please try again.</div>';
        }
      }
    });
}

function renderRouteSuggestions(autocompleteObj, suggestionsContainer, inputElement) {
  clearRecentState(suggestionsContainer);
  const fieldId = (inputElement && inputElement.id === 'routeEnd') ? 'routeEnd' :
                  (inputElement && inputElement.id === 'routeStart') ? 'routeStart' :
                  (suggestionsContainer && suggestionsContainer.dataset.field) || '';
  const queryValue = (inputElement?.value || '').trim();
  const unifiedSection = buildUnifiedRecentSection(getFallbackRecentsForField(fieldId), {
    query: queryValue,
    filterShared: true,
    filterFallback: true
  });
  if (autocompleteObj.suggestions.length === 0) {
    const emptyHtml = '<div class="autocomplete-empty" role="option">No suggestions found</div>';
    suggestionsContainer.innerHTML = unifiedSection ? unifiedSection + emptyHtml : emptyHtml;
    return;
  }
  
  // Get icon function (same as nearby autocomplete)
  const getAddressTypeIcon = (type) => {
    const icons = {
      place: '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>',
      default: '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>'
    };
    return icons[type] || icons.default;
  };
  
  const html = autocompleteObj.suggestions.map((item, index) => {
    const isSelected = index === autocompleteObj.selectedIndex;
    const formatted = formatAddressName(item.description, '');
    const iconPath = getAddressTypeIcon('place');
    
    return `
      <div class="autocomplete-item ${isSelected ? 'highlighted' : ''}" 
           role="option" 
           aria-selected="${isSelected}" 
           tabindex="${isSelected ? '0' : '-1'}"
           data-index="${index}">
        <div class="autocomplete-item-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            ${iconPath}
          </svg>
        </div>
        <div class="autocomplete-item-content">
          <div class="address-name">${formatted.primary}</div>
          ${formatted.secondary ? `<div class="address-details">${formatted.secondary}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  suggestionsContainer.innerHTML = unifiedSection + html;
  inputElement.setAttribute('aria-expanded', 'true');
  
  suggestionsContainer.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    item.style.pointerEvents = 'auto';
    item.style.cursor = 'pointer';
    
    const handleClick = (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      e.stopPropagation();
      selectRouteSuggestion(index, autocompleteObj, inputElement, suggestionsContainer);
      return false;
    };
    
    item.addEventListener('click', handleClick, true);
    item.addEventListener('mousedown', (e) => {
      e.preventDefault();
    });
    
    item.addEventListener('mouseenter', () => {
      autocompleteObj.selectedIndex = index;
      updateRouteHighlight(autocompleteObj, suggestionsContainer);
    });
    
    item.addEventListener('touchend', handleClick, { passive: false, capture: true });
  });
}

function selectRouteSuggestion(index, autocompleteObj, inputElement, suggestionsContainer) {
  if (!autocompleteObj.suggestions || !autocompleteObj.suggestions[index]) {
    return;
  }
  
  const suggestion = autocompleteObj.suggestions[index];
  const description = suggestion.description || '';
  
  if (!description) {
    return;
  }
  
  autocompleteObj.isSelecting = true;
  closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement);
  inputElement.value = description;
  notifyRouteInputsUpdated(true);
  if (inputElement.id === 'routeStart') {
    saveRecent(RECENT_STORAGE_KEYS.routeStart, description);
  } else if (inputElement.id === 'routeEnd') {
    saveRecent(RECENT_STORAGE_KEYS.routeEnd, description);
  }
  
  setTimeout(() => {
    autocompleteObj.isSelecting = false;
  }, 100);
  
  // Geocode and store in route state (but don't update map yet)
  geocodeAddress(description, 'route').then(result => {
    if (result) {
      if (inputElement.id === 'routeStart') {
        route.start = { description, lat: result.lat, lon: result.lon };
        console.log('Route start set:', route.start);
      } else if (inputElement.id === 'routeEnd') {
        route.end = { description, lat: result.lat, lon: result.lon };
        console.log('Route end set:', route.end);
      }
    } else {
      console.warn('Geocoding failed for route address:', description);
    }
  }).catch(error => {
    console.error('Error geocoding route address:', error);
  });
}

function closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement) {
  clearRecentState(suggestionsContainer);
  suggestionsContainer.classList.remove('active');
  inputElement.setAttribute('aria-expanded', 'false');
  autocompleteObj.isOpen = false;
  autocompleteObj.selectedIndex = -1;
}

function updateRouteHighlight(autocompleteObj, suggestionsContainer) {
  suggestionsContainer.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    if (index === autocompleteObj.selectedIndex) {
      item.classList.add('highlighted');
      item.setAttribute('aria-selected', 'true');
      item.setAttribute('tabindex', '0');
    } else {
      item.classList.remove('highlighted');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('tabindex', '-1');
    }
  });
}

/**
 * LAZY LOADED: Route calculation function - only executed when route mode is first used
 * Calculate perpendicular distance from a point to a line segment (using Haversine formula)
 * Returns the shortest distance from point P to line segment AB
 * 
 * Performance: This heavy computation is only executed when user interacts with route mode
 */
function distanceToLineSegment(pointLat, pointLon, lineStartLat, lineStartLon, lineEndLat, lineEndLon, units = 'mi') {
  // Calculate distances to endpoints
  const dAP = calculateDistance(lineStartLat, lineStartLon, pointLat, pointLon, units);
  const dBP = calculateDistance(lineEndLat, lineEndLon, pointLat, pointLon, units);
  const dAB = calculateDistance(lineStartLat, lineStartLon, lineEndLat, lineEndLon, units);
  
  // If the line segment is very short, return distance to nearest endpoint
  if (dAB < 0.01) {
    return Math.min(dAP, dBP);
  }
  
  // Use the law of cosines to find the angle at point A
  // cos(angle) = (a² + c² - b²) / (2ac)
  // where a = dAP, b = dBP, c = dAB
  const cosAngle = (dAP * dAP + dAB * dAB - dBP * dBP) / (2 * dAP * dAB);
  
  // Clamp cosAngle to [-1, 1] to avoid NaN from acos
  const clampedCos = Math.max(-1, Math.min(1, cosAngle));
  const angle = Math.acos(clampedCos);
  
  // Calculate perpendicular distance using sine
  // distance = dAP * sin(angle)
  const perpendicularDist = dAP * Math.sin(angle);
  
  // Check if the perpendicular point is within the segment
  // If angle > 90 degrees, the perpendicular is beyond point A
  // If the distance along AB from A is > dAB, it's beyond point B
  const distAlongAB = dAP * Math.cos(angle);
  
  if (distAlongAB < 0 || distAlongAB > dAB) {
    // Perpendicular point is outside the segment, return distance to nearest endpoint
    return Math.min(dAP, dBP);
  }
  
  return Math.abs(perpendicularDist);
}

/**
 * LAZY LOADED: Route search function - only executed when user clicks "Find" in route mode
 * Prevents infinite loops by checking if already processing
 * 
 * Performance: Heavy OSRM API calls and distance calculations only run when:
 * - User enters start/end addresses AND clicks "Find" button
 * - NOT on initial page load
 * - NOT when just switching to route mode
 */
let isProcessingRoute = false;

function findCollegesAlongRoute() {
  // Guard against infinite loops
  if (isProcessingRoute) {
    console.log('Route already processing, skipping...');
    return;
  }
  
  if (activeMode !== 'route') {
    console.log('Not in route mode, current mode:', activeMode);
    return;
  }
  
  if (!route.start || !route.end) {
    showError('Please enter both starting and destination addresses.');
    console.log('Route start or end missing:', { start: route.start, end: route.end });
    return;
  }
  
  console.log('Starting route search...', { start: route.start, end: route.end });
  isProcessingRoute = true;
  
  // Parse maxDistance - handle 0 correctly (don't use || operator as 0 is falsy)
  const maxDistanceInputStr = elements.routeMaxDistance?.value;
  let maxDistanceInput;
  if (maxDistanceInputStr === '' || maxDistanceInputStr === null || maxDistanceInputStr === undefined) {
    maxDistanceInput = 30;
  } else {
    maxDistanceInput = parseFloat(maxDistanceInputStr);
    if (isNaN(maxDistanceInput)) {
      maxDistanceInput = 30;
    }
  }
  // If maxDistance is 0, use 0.5 instead
  const maxDistance = maxDistanceInput === 0 ? 0.5 : maxDistanceInput;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  
  // Store route search state
  route.lastSearch = {
    start: route.start,
    end: route.end,
    maxDistance,
    units
  };
  
  if (elements.loading) elements.loading.classList.add('active');
  
  // Clear previous route visualization
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  homeLayer.clearLayers();
  radiusLayer.clearLayers();
  
  // Validate route coordinates
  if (isNaN(route.start.lat) || isNaN(route.start.lon) || isNaN(route.end.lat) || isNaN(route.end.lon)) {
    console.error('Invalid route coordinates:', { start: route.start, end: route.end });
    showError('Invalid route coordinates. Please check your addresses.');
    if (elements.loading) elements.loading.classList.remove('active');
    isProcessingRoute = false;
    return;
  }
  
  // Get actual driving route using OSRM (Open Source Routing Machine)
  // Format: lon,lat (OSRM uses lon,lat order)
  const startCoords = `${route.start.lon},${route.start.lat}`;
  const endCoords = `${route.end.lon},${route.end.lat}`;
  const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${startCoords};${endCoords}?overview=full&geometries=geojson`;
  
  // Add timeout to fetch request
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
  
  fetch(osrmUrl, { signal: controller.signal })
    .then(r => {
      clearTimeout(timeoutId);
      if (!r.ok) throw new Error(`Routing failed: ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (!data || data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
        throw new Error('No route found');
      }
      
      // Validate route geometry
      if (!data.routes[0].geometry || !data.routes[0].geometry.coordinates || data.routes[0].geometry.coordinates.length === 0) {
        throw new Error('Invalid route geometry');
      }
      
      const routeGeometry = data.routes[0].geometry.coordinates;
      // Convert from [lon, lat] to [lat, lon] for Leaflet
      const routeCoords = routeGeometry.map(coord => [coord[1], coord[0]]);
      
      // Draw the actual driving route with ribbon effect
      const zoom = map ? map.getZoom() : 5;
      const routeWeights = calculateRouteLineWeights(zoom);
      
      // First draw the deep navy outline (thin line for ribbon effect)
      routeOutlinePolyline = L.polyline(routeCoords, {
        color: '#0A2CA5',
        weight: routeWeights.outlineWeight,
        opacity: routeWeights.outlineOpacity
      }).addTo(routeLayer);
      // Then draw the vivid royal blue main route line on top
      routeMainPolyline = L.polyline(routeCoords, {
        color: '#1A4CFF',
        weight: routeWeights.mainWeight,
        opacity: routeWeights.mainOpacity
      }).addTo(routeLayer);
      
      // Track route search completion
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_route_used');
      }
      
      // Draw start and destination markers (map pins - smaller size)
      // Start pin (white circle with black border)
      L.marker([route.start.lat, route.start.lon], {
        icon: L.icon({
          iconUrl: ROUTE_START_PIN_ICON,
          iconSize: [18, 18],
          iconAnchor: [9, 9],
          popupAnchor: [0, -9]
        })
      }).addTo(routeLayer).bindPopup('From');
      
      // Destination pin (red teardrop)
      L.marker([route.end.lat, route.end.lon], {
        icon: L.icon({
          iconUrl: ROUTE_END_PIN_ICON,
          iconSize: [24, 30],
          iconAnchor: [12, 30],
          popupAnchor: [0, -30]
        })
      }).addTo(routeLayer).bindPopup('To');
      
      // Calculate route bounds and fit map
      const polylineBounds = L.latLngBounds(routeCoords);
      let routeBounds = L.latLngBounds(routeCoords);
      
      // Filter colleges along the route using perpendicular distance
      // Sample route points to improve performance (check every 10th point for long routes)
      const sampleRate = routeCoords.length > 100 ? 10 : 1;
      const sampledRoute = [];
      for (let i = 0; i < routeCoords.length; i += sampleRate) {
        sampledRoute.push(routeCoords[i]);
      }
      // Always include the last point
      if (sampledRoute[sampledRoute.length - 1] !== routeCoords[routeCoords.length - 1]) {
        sampledRoute.push(routeCoords[routeCoords.length - 1]);
      }
      
      const filtered = colleges.filter(c => {
        // Check distance to each segment of the sampled route
        let minDistance = Infinity;
        
        for (let i = 0; i < sampledRoute.length - 1; i++) {
          const segmentStart = sampledRoute[i];
          const segmentEnd = sampledRoute[i + 1];
          
          const dist = distanceToLineSegment(
            c.lat, c.lon,
            segmentStart[0], segmentStart[1],
            segmentEnd[0], segmentEnd[1],
            units
          );
          
          minDistance = Math.min(minDistance, dist);
          
          // Early exit if we're already within range
          if (minDistance <= maxDistance) {
            break;
          }
        }
        
        return minDistance <= maxDistance;
      });
      
      // Apply other filters (type, region, state, ranking, search)
      const typeVal = elements.type ? elements.type.value.trim() : '';
      const regionVal = elements.region ? elements.region.value.trim() : '';
      const stateVal = elements.state ? elements.state.value.trim() : '';
      const rankingVal = elements.ranking ? elements.ranking.value.trim() : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      const filtersSnapshot = { typeVal, regionVal, stateVal, rankingVal, searchVal, maxDistance, units };
      const finalFiltered = filtered.filter(c => {
        // Type filter - check both type and tier fields
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        // Region filter - use REGION_MAP to check if state is in region
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        // Ranking filter
        if (rankingVal) {
          if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
          if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
          if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
          if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
        }
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        return true;
      });
      
      const allRouteColleges = finalFiltered.map(c => {
        let distanceText = '';
        let minRouteDist = Infinity;
        for (let i = 0; i < sampledRoute.length - 1; i++) {
          const dist = distanceToLineSegment(
            c.lat, c.lon,
            sampledRoute[i][0], sampledRoute[i][1],
            sampledRoute[i + 1][0], sampledRoute[i + 1][1],
            units
          );
          minRouteDist = Math.min(minRouteDist, dist);
        }
        if (minRouteDist < Infinity) {
          distanceText = `<br>Distance from route: ${minRouteDist.toFixed(1)} ${units}`;
        }
        return { college: c, distanceText };
      });
      allRouteColleges.forEach(item => {
        routeBounds.extend([item.college.lat, item.college.lon]);
      });
      
      const visibleRouteColleges = savedOnlyMode
        ? allRouteColleges.filter(item => SavedStore.isSaved(item.college.college_id))
        : allRouteColleges;
      
      if (visibleRouteColleges.length === 0 && savedOnlyMode) {
        const savedCount = SavedStore.getAll().length;
        if (savedCount === 0) {
          console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
        } else {
          console.log("No saved colleges match your current filters or route.");
        }
      }
      
      // Clear and render markers (using same style as nearby mode - blue circle dots)
      markersLayer.clearLayers();
      // Clear marker registry
      Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      visibleRouteColleges.forEach(item => {
        addRouteCollegeMarker(item.college, item.distanceText, units);
      });
      
      if (elements.count) elements.count.textContent = visibleRouteColleges.length;
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Update map hints for route mode
      updateMapHints(visibleRouteColleges.length, typeVal, regionVal, stateVal, searchVal);
      
      // Store route visualization for restoration
      if (routeBounds.isValid()) {
        if (visibleRouteColleges.length > 0) {
          map.fitBounds(routeBounds.pad(0.15));
        } else {
          map.fitBounds(polylineBounds.pad(0.15));
        }
      }

      route.lastResult = {
        bounds: routeBounds.isValid() ? routeBounds : polylineBounds,
        routeCoords,
        colleges: allRouteColleges,
        filters: filtersSnapshot,
        start: route.start ? { ...route.start } : null,
        end: route.end ? { ...route.end } : null
      };
      
      isProcessingRoute = false;
    })
    .catch(error => {
      clearTimeout(timeoutId);
      console.error('Route calculation error:', error);
      
      // Ensure loading indicator is hidden
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Reset processing flag (will be set again at end of fallback)
      
      // If it's an abort error (timeout), show specific message but still use fallback
      if (error.name === 'AbortError') {
        showError('Route calculation timed out. Showing approximate results.');
      }
      // Fallback to straight line if routing fails
      const fallbackRouteCoords = [
        [route.start.lat, route.start.lon],
        [route.end.lat, route.end.lon]
      ];
      // Draw fallback route with ribbon effect
      const zoom = map ? map.getZoom() : 5;
      const routeWeights = calculateRouteLineWeights(zoom);
      
      // First draw the deep navy outline (thin line for ribbon effect)
      routeOutlinePolyline = L.polyline(
        fallbackRouteCoords,
        { 
          color: '#0A2CA5', 
          weight: routeWeights.outlineWeight, 
          opacity: routeWeights.outlineOpacity 
        }
      ).addTo(routeLayer);
      // Then draw the vivid royal blue main route line on top
      routeMainPolyline = L.polyline(
        fallbackRouteCoords,
        { 
          color: '#1A4CFF', 
          weight: routeWeights.mainWeight, 
          opacity: routeWeights.mainOpacity 
        }
      ).addTo(routeLayer);
      
      // Track route search completion (fallback route)
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_route_used');
      }
      
      const fallbackBounds = L.latLngBounds(fallbackRouteCoords);
      
      // Use simple distance calculation as fallback
      const filtered = colleges.filter(c => {
        const distToStart = calculateDistance(route.start.lat, route.start.lon, c.lat, c.lon, units);
        const distToEnd = calculateDistance(route.end.lat, route.end.lon, c.lat, c.lon, units);
        const routeLength = calculateDistance(route.start.lat, route.start.lon, route.end.lat, route.end.lon, units);
        
        // Simple approximation: if within maxDistance of the straight line
        const minDist = Math.min(distToStart, distToEnd);
        if (minDist <= maxDistance) return true;
        
        // Check if point is within corridor (rough approximation)
        const midLat = (route.start.lat + route.end.lat) / 2;
        const midLon = (route.start.lon + route.end.lon) / 2;
        const distToMid = calculateDistance(midLat, midLon, c.lat, c.lon, units);
        return distToMid <= maxDistance * 1.5; // Slightly more lenient for fallback
      });
      
      // Apply other filters
      const typeVal = elements.type ? elements.type.value.trim() : '';
      const regionVal = elements.region ? elements.region.value.trim() : '';
      const stateVal = elements.state ? elements.state.value.trim() : '';
      const rankingVal = elements.ranking ? elements.ranking.value.trim() : '';
      const searchVal = (elements.search ? elements.search.value.trim().toLowerCase() : '') || 
                        (document.getElementById('search-mobile') ? document.getElementById('search-mobile').value.trim().toLowerCase() : '');
      
      const filtersSnapshot = { typeVal, regionVal, stateVal, rankingVal, searchVal, maxDistance, units };
      const finalFiltered = filtered.filter(c => {
        // Type filter - check both type and tier fields
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        // Region filter - use REGION_MAP to check if state is in region
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        // Ranking filter
        if (rankingVal) {
          if (rankingVal === 'Top 25 national universities' && c.top25_univ !== '1') return false;
          if (rankingVal === 'Top 50 national universities' && c.top50_univ !== '1') return false;
          if (rankingVal === 'Top 10 liberal arts colleges' && c.top10_lac !== '1') return false;
          if (rankingVal === 'Top 20 liberal arts colleges' && c.top20_lac !== '1') return false;
        }
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        return true;
      });
      
      const fallbackRouteEntries = finalFiltered.map(c => {
        const distToStart = calculateDistance(route.start.lat, route.start.lon, c.lat, c.lon, units);
        const distToEnd = calculateDistance(route.end.lat, route.end.lon, c.lat, c.lon, units);
        const minDist = Math.min(distToStart, distToEnd);
        const distanceText = `<br>Approx. distance from route: ${minDist.toFixed(1)} ${units}`;
        return { college: c, distanceText };
      });
      const fallbackCollegeBounds = L.latLngBounds(fallbackRouteCoords);
      fallbackRouteEntries.forEach(entry => {
        fallbackCollegeBounds.extend([entry.college.lat, entry.college.lon]);
      });
      
      const visibleFallbackEntries = savedOnlyMode
        ? fallbackRouteEntries.filter(item => SavedStore.isSaved(item.college.college_id))
        : fallbackRouteEntries;
      
      if (visibleFallbackEntries.length === 0 && savedOnlyMode) {
        const savedCount = SavedStore.getAll().length;
        if (savedCount === 0) {
          console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
        } else {
          console.log("No saved colleges match your current filters or route.");
        }
      }
      
      // Clear and render markers (using same style as nearby mode)
      markersLayer.clearLayers();
      // Clear marker registry
      Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      visibleFallbackEntries.forEach(item => {
        addRouteCollegeMarker(item.college, item.distanceText, units);
      });
      
      if (elements.count) elements.count.textContent = visibleFallbackEntries.length;
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Update map hints for route mode (fallback)
      updateMapHints(visibleFallbackEntries.length, typeVal, regionVal, stateVal, searchVal);
      if (fallbackCollegeBounds.isValid()) {
        map.fitBounds(fallbackCollegeBounds.pad(0.15));
      } else if (fallbackBounds.isValid()) {
        map.fitBounds(fallbackBounds.pad(0.15));
      }

      route.lastResult = {
        bounds: fallbackCollegeBounds.isValid() ? fallbackCollegeBounds : fallbackBounds,
        routeCoords: fallbackRouteCoords,
        colleges: fallbackRouteEntries,
        filters: filtersSnapshot,
        start: route.start ? { ...route.start } : null,
        end: route.end ? { ...route.end } : null
      };
      
      // Only show general error if it wasn't a timeout (timeout message already shown)
      if (error.name !== 'AbortError') {
        showError('Could not calculate driving route. Showing approximate results.');
      }
      
      isProcessingRoute = false;
    });
}

// Initialize dropdowns immediately
// Region dropdown (doesn't depend on CSV)
refreshDropdown('region', ['Northeast', 'Midwest', 'South', 'West', 'Territories'], 'All regions');

// Update dropdown placeholder text based on screen size
function updateDropdownPlaceholders() {
  const width = window.innerWidth || document.documentElement.clientWidth;
  const isMobile = width <= 700;
  const isTablet = width >= 701 && width <= 1024;
  
  // Debug: log when mobile mode is detected
  if (isMobile) {
    console.log('[updateDropdownPlaceholders] Mobile mode - width:', width);
  }
  
  // List of filter dropdown IDs
  const filterDropdowns = ['type', 'region', 'state', 'ranking'];
  
  // Explicitly enforce font-size for mobile/tablet to ensure consistency
  const ua = navigator.userAgent || '';
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  if (isMobile) {
    // Mobile (≤700px): 14px for all devices, 16px for iOS
    const fontSize = isIOS ? '16px' : '14px';
    filterDropdowns.forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        select.style.fontSize = fontSize;
        select.style.setProperty('font-size', fontSize, 'important');
      }
    });
    // Also apply to ranking dropdown
    const rankingSelect = document.getElementById('ranking');
    if (rankingSelect) {
      rankingSelect.style.fontSize = fontSize;
      rankingSelect.style.setProperty('font-size', fontSize, 'important');
    }
  } else if (isTablet) {
    // Tablet (701px-1024px): 16px for all devices
    filterDropdowns.forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        select.style.fontSize = '16px';
        select.style.setProperty('font-size', '16px', 'important');
      }
    });
  } else {
    // Remove inline font-size on desktop to let CSS handle it
    filterDropdowns.forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        select.style.fontSize = '';
      }
    });
  }
  
  // Update Type dropdown
  const typeSelect = document.getElementById('type');
  if (typeSelect) {
    const typeOption = typeSelect.querySelector('option[value=""]');
    if (typeOption) {
      typeOption.textContent = isMobile ? 'All types' : 'All college types';
    }
  }
  
  // Update Region dropdown
  const regionSelect = document.getElementById('region');
  if (regionSelect) {
    const regionOption = regionSelect.querySelector('option[value=""]');
    if (regionOption) {
      regionOption.textContent = isMobile ? 'All regions' : 'All regions';
    }
  }
  
  // Update State dropdown
  const stateSelect = document.getElementById('state');
  if (stateSelect) {
    const stateOption = stateSelect.querySelector('option[value=""]');
    if (stateOption) {
      stateOption.textContent = isMobile ? 'All states' : 'All states';
    }
  }
  
  // Update Ranking dropdown
  const rankingSelect = document.getElementById('ranking');
  if (rankingSelect) {
    const rankingOption = rankingSelect.querySelector('option[value=""]');
    if (rankingOption) {
      rankingOption.textContent = 'School Ranking | No Selection';
    }
  }
}

// Ranking dropdown (static options)
refreshDropdown('ranking', ['Top 25 national universities', 'Top 50 national universities', 'Top 10 liberal arts colleges', 'Top 20 liberal arts colleges'], 'School Ranking | No Selection');
updateDropdownPlaceholders();

// Handle ranking dropdown: show "School Ranking" in field when closed, "School Ranking | No Selection" in dropdown
const rankingSelect = document.getElementById('ranking');
if (rankingSelect) {
  // Store original option text
  const rankingOption = rankingSelect.querySelector('option[value=""]');
  if (rankingOption) {
    rankingOption.setAttribute('data-dropdown-text', 'School Ranking | No Selection');
    
    // When dropdown opens (mousedown/focus), show full text in option
    rankingSelect.addEventListener('mousedown', () => {
      if (rankingOption && rankingSelect.value === '') {
        rankingOption.textContent = rankingOption.getAttribute('data-dropdown-text');
      }
    });
    
    // When dropdown closes (blur), if no selection, show shortened text in field
    // Note: We can't change what shows in the closed field without custom select,
    // but we ensure the dropdown option has the full text
    rankingSelect.addEventListener('change', () => {
      if (rankingSelect.value === '' && rankingOption) {
        rankingOption.textContent = rankingOption.getAttribute('data-dropdown-text');
      }
    });
  }
}

// Type dropdown (initialize with common types, will be updated when CSV loads)
try {
  refreshDropdown('type', TYPE_ORDER.filter(Boolean), 'Any college type');
  // Update placeholders after initial type dropdown setup
  updateDropdownPlaceholders();
} catch (e) {
  console.error('Error initializing type dropdown:', e);
  // Fallback: ensure dropdown at least exists
  const typeSelect = document.getElementById('type');
  if (typeSelect) {
    typeSelect.innerHTML = '<option value="">All college types</option>';
  }
  updateDropdownPlaceholders();
}

// Event listeners
if (elements.geocodeBtn) {
  elements.geocodeBtn.onclick = () => {
    if (activeMode === 'nearby' && elements.address) {
      hasUsedSearchControls = true; // User actively clicked Locate button
      geocodeAddress(elements.address.value, 'nearby');
    }
  };
}

// Address autocomplete
if (elements.address) {
  elements.address.addEventListener('input', debounce((e) => {
    // Don't trigger search if we're programmatically setting the value
    if (addressAutocomplete.isSelecting) {
      return;
    }
    searchAddresses(e.target.value);
  }, 400));

  elements.address.addEventListener('keydown', handleAutocompleteKeydown);
  elements.address.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.address, true);
    showAddressRecentsIfEligible();
  });
  elements.address.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.address, false);
      closeAutocomplete();
    }, 120);
  });
}

// Event delegation as backup (items have direct handlers, but this catches edge cases)
if (elements.addressSuggestions) {
  elements.addressSuggestions.addEventListener('click', (e) => {
    const item = e.target.closest('.autocomplete-item');
    if (item) {
      if (item.dataset.recent === 'true') {
        e.preventDefault();
        e.stopPropagation();
        const decodedValue = item.dataset.value ? decodeURIComponent(item.dataset.value) : '';
        handleRecentAddressSelection(decodedValue);
        return;
      }
      if (item.classList.contains('shared-location')) {
        e.preventDefault();
        e.stopPropagation();
        const field = elements.addressSuggestions?.dataset.field || 'address';
        const description = item.dataset.description ? decodeURIComponent(item.dataset.description) : '';
        handleSharedLocationSelection(field, description);
        return;
      }
      const index = parseInt(item.dataset.index, 10);
      if (!isNaN(index) && index >= 0) {
        e.preventDefault();
        e.stopPropagation();
        selectSuggestion(index);
      }
    }
  }, true);
  elements.addressSuggestions.addEventListener('mousedown', (e) => {
    if (e.target.closest('.recent-suggestion') || e.target.closest('.shared-location')) {
      e.preventDefault();
    }
  }, true);
}

// Handle route recents in suggestion containers
[elements.routeStartSuggestions, elements.routeEndSuggestions].forEach(container => {
  if (!container) return;
  container.addEventListener('click', (e) => {
    const recentItem = e.target.closest('.recent-suggestion');
    if (recentItem) {
      e.preventDefault();
      e.stopPropagation();
      const decodedValue = recentItem.dataset.value ? decodeURIComponent(recentItem.dataset.value) : '';
      handleRecentRouteSelection(decodedValue, container.dataset.recentContext || '');
      return;
    }
    const sharedItem = e.target.closest('.shared-location');
    if (sharedItem) {
      e.preventDefault();
      e.stopPropagation();
      const description = sharedItem.dataset.description ? decodeURIComponent(sharedItem.dataset.description) : '';
      const field = container.dataset.field || '';
      handleSharedLocationSelection(field, description);
    }
  }, true);
  container.addEventListener('mousedown', (e) => {
    if (e.target.closest('.recent-suggestion') || e.target.closest('.shared-location')) {
      e.preventDefault();
    }
  }, true);
});

// Close autocomplete when clicking outside
document.addEventListener('click', (e) => {
  // Only close if click is truly outside
  if (elements.address && elements.addressSuggestions && 
      !elements.address.contains(e.target) && 
      !elements.addressSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeAutocomplete();
  }
  // Close route autocompletes
  if (elements.routeStart && elements.routeStartSuggestions && 
      !elements.routeStart.contains(e.target) && 
      !elements.routeStartSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
  }
  if (elements.routeEnd && elements.routeEndSuggestions && 
      !elements.routeEnd.contains(e.target) && 
      !elements.routeEndSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
  }
}, true);

// Route autocomplete event listeners
if (elements.routeStart) {
  elements.routeStart.addEventListener('input', debounce((e) => {
    if (routeStartAutocomplete.isSelecting) {
      return;
    }
    searchRouteAddresses(e.target.value, routeStartAutocomplete, elements.routeStart, elements.routeStartSuggestions);
  }, 400));
  elements.routeStart.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.routeStart, true);
    showRouteRecentsIfEligible(elements.routeStart, elements.routeStartSuggestions, routeStartAutocomplete, RECENT_STORAGE_KEYS.routeStart, 'routeStart');
  });
  elements.routeStart.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.routeStart, false);
      if (elements.routeStartSuggestions) {
        closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
      }
    }, 120);
  });
}

if (elements.routeEnd) {
  elements.routeEnd.addEventListener('input', debounce((e) => {
    if (routeEndAutocomplete.isSelecting) {
      return;
    }
    searchRouteAddresses(e.target.value, routeEndAutocomplete, elements.routeEnd, elements.routeEndSuggestions);
  }, 400));
  elements.routeEnd.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.routeEnd, true);
    showRouteRecentsIfEligible(elements.routeEnd, elements.routeEndSuggestions, routeEndAutocomplete, RECENT_STORAGE_KEYS.routeEnd, 'routeEnd');
  });
  elements.routeEnd.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.routeEnd, false);
      if (elements.routeEndSuggestions) {
        closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
      }
    }, 120);
  });
}

// Route search button
if (elements.findRouteBtn) {
  elements.findRouteBtn.onclick = async () => {
    // If addresses are entered but not geocoded yet, geocode them first
    if (elements.routeStart && elements.routeStart.value && !route.start) {
      const startAddress = elements.routeStart.value;
      const startResult = await geocodeAddress(startAddress, 'route');
      if (startResult) {
        route.start = { description: startAddress, lat: startResult.lat, lon: startResult.lon };
        saveRecent(RECENT_STORAGE_KEYS.routeStart, startAddress);
      }
    }
    
    if (elements.routeEnd && elements.routeEnd.value && !route.end) {
      const endAddress = elements.routeEnd.value;
      const endResult = await geocodeAddress(endAddress, 'route');
      if (endResult) {
        route.end = { description: endAddress, lat: endResult.lat, lon: endResult.lon };
        saveRecent(RECENT_STORAGE_KEYS.routeEnd, endAddress);
      }
    }
    
    hasUsedSearchControls = true; // User actively clicked Find Route button
    // Now call the route search function
    findCollegesAlongRoute();
  };
}

// Route clear button
if (elements.clearRoute) {
  elements.clearRoute.onclick = () => {
    if (elements.routeStart) elements.routeStart.value = '';
    if (elements.routeEnd) elements.routeEnd.value = '';
    if (elements.routeMaxDistance) elements.routeMaxDistance.value = '30';
    if (elements.routeUnits) elements.routeUnits.value = 'mi';
    route.start = null;
    route.end = null;
    route.lastSearch = null;
     route.lastResult = null;
    routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
    if (elements.routeStartSuggestions && elements.routeStart) {
      closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
    }
    if (elements.routeEndSuggestions && elements.routeEnd) {
      closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
    }
    // When clearing route, show colleges based on current filter settings
    if (activeMode === 'route') {
      // Clear route visualization
      routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
      // Show all colleges filtered by type, region, state, and search
      markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      
      // Apply filters from dropdowns
      const stateVal = elements.state ? elements.state.value : '';
      const regionVal = elements.region ? elements.region.value : '';
      const typeVal = elements.type ? elements.type.value : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      
      let filtered = colleges.filter(c => {
        // Region filter
        const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
        if (!regionMatch) return false;
        
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        
        // Type filter
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        return true;
      });
      
      // Render filtered colleges
      filtered.forEach(c => {
        try {
          if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
            return;
          }
          
          const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
          const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
          
          const saveButtonHtml = c.college_id ? `
            <div class="popup-save-row">
              <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
                <span class="popup-save-icon" aria-hidden="true">☆</span>
                <span class="popup-save-label">Save</span>
              </button>
            </div>` : '';

          const popupContent = `
            <div style="font-size:12px;line-height:1.4">
              <b>${c.name}</b><br>
              ${c.state} · ${(c.type||'Unknown')}<br>
              ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
              Enrollment: ${c.enrollment || 'N/A'}<br>
              Tuition: ${tuition}<br>
              ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
              ${saveButtonHtml}
            </div>`;
          
          const marker = createCollegeMarker(c, popupContent, c.college_id);
          marker.addTo(markersLayer);
        } catch (e) {
          console.error(`Error creating marker for ${c.name}:`, e);
        }
      });
      
      if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
      
      // Update map hints after clearing route
      updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
      
      map.setView([39.5, -98.35], 4);
    }
  };
}

if (elements.clearRadius) {
  elements.clearRadius.onclick = () => {
    if (elements.radius) elements.radius.value = '30';
    if (elements.address) elements.address.value = '';
    // Clear both desktop and mobile search fields
    if (elements.search) elements.search.value = '';
    const mobileSearch = document.getElementById('search-mobile');
    if (mobileSearch) mobileSearch.value = '';
    // Clear ranking filter
    if (elements.ranking) elements.ranking.value = '';
    home = null;
    homeLayer.clearLayers();
    radiusLayer.clearLayers();
    closeAutocomplete();
    map.setView([39.5, -98.35], 4);
    render();
  };
}

// Accordion behavior for filter sections - when one opens, close the other
const filterSections = document.querySelectorAll('.filter-section');
if (filterSections.length) {
  const isMobileViewport = window.innerWidth <= 700;
  if (!isMobileViewport) {
    filterSections[0].setAttribute('open', '');
  } else {
    filterSections[0].removeAttribute('open');
  }
}
filterSections.forEach(section => {
  section.addEventListener('toggle', (e) => {
    // Remove active class from all sections first
    filterSections.forEach(s => s.classList.remove('active'));
    
    // Find the currently open section and mark it as active
    const openSection = Array.from(filterSections).find(s => s.open);
    if (openSection) {
      openSection.classList.add('active');
    }
    
    // Only act if this section is now open (was just opened)
    if (section.open) {
      // Determine which section opened
      const summary = section.querySelector('summary');
      const isNearby = summary && summary.textContent.trim().includes('Find Colleges Nearby');
      const isRoute = summary && summary.textContent.trim().includes('Find Colleges Along a Route');
      
      // Set active mode
      if (isNearby) {
        activeMode = 'nearby';
        // Clear route visualization when switching to nearby mode
        routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
        // Restore nearby state if available
        if (nearbyState.home) {
          home = nearbyState.home;
          if (elements.address && nearbyState.address) {
            elements.address.value = nearbyState.address;
          }
          if (elements.radius && nearbyState.radius) {
            elements.radius.value = nearbyState.radius;
          }
          if (elements.units && nearbyState.units) {
            elements.units.value = nearbyState.units;
          }
          // Re-apply the search and recreate the pin marker
          if (home) {
            // Clear and recreate the pin marker
        homeLayer.clearLayers();
            radiusLayer.clearLayers();
            
            // Recreate "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([home.lat, home.lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
            
            render();
          }
        } else {
          // If no nearby state, rely on render to determine framing
          render();
        }
      } else if (isRoute) {
        activeMode = 'route';
        // Clear nearby visualization when switching to route mode
        homeLayer.clearLayers();
        radiusLayer.clearLayers();
        // Restore route state if available
        if (route.lastSearch && route.start && route.end) {
          // Restore input values
          if (elements.routeStart && route.start.description) {
            elements.routeStart.value = route.start.description;
          }
          if (elements.routeEnd && route.end.description) {
            elements.routeEnd.value = route.end.description;
          }
          if (elements.routeMaxDistance && route.lastSearch.maxDistance) {
            elements.routeMaxDistance.value = route.lastSearch.maxDistance;
          }
          if (elements.routeUnits && route.lastSearch.units) {
            elements.routeUnits.value = route.lastSearch.units;
          }
          const currentFilters = getRouteFilterSignature();
          if (route.lastResult && isRouteCacheValid(route.lastResult, currentFilters, route.start, route.end)) {
            restoreRouteFromCache(route.lastResult, { preserveView: true });
            if (!applySavedMapView('route')) {
              if (route.lastResult.bounds && route.lastResult.bounds.isValid()) {
                map.fitBounds(route.lastResult.bounds.pad(0.15));
              } else if (route.lastResult.routeCoords && route.lastResult.routeCoords.length) {
                map.fitBounds(L.latLngBounds(route.lastResult.routeCoords), { padding: [50, 50] });
              }
            }
          } else {
            // Redraw the route
            findCollegesAlongRoute();
          }
        } else {
          // If no route state, show colleges based on current filters (type, region, state, search)
          // Clear only route visualization layers, keep markers showing filtered colleges
          routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
          render();
        }
      }
      
      // This section just opened, close all other sections
      filterSections.forEach(otherSection => {
        if (otherSection !== section && otherSection.open) {
          otherSection.open = false;
      }
    });
}
  });
});

// Set initial active state for the default open section
const openSection = document.querySelector('.filter-section[open]');
if (openSection) {
  openSection.classList.add('active');
}

// Store the last user-selected state value to prevent autofill from changing it
let lastUserSelectedState = '';
let isUserChangingState = false;
let autofillWatchInterval = null;
let stateProtectionActive = true; // Always active by default

// Strong protection function to restore state value
function protectStateValue() {
  if (!elements.state || isUserChangingState) {
    return;
  }
  if (elements.state.value !== lastUserSelectedState) {
    // Autofill tried to change it - restore immediately
    elements.state.value = lastUserSelectedState;
    // Force a reflow to ensure the change is applied
    void elements.state.offsetHeight;
  }
}

// Prevent autofill from changing the state dropdown
if (elements.state) {
  // Store initial value
  lastUserSelectedState = elements.state.value;
  
  // Track when any address field is being filled (autofill detection)
  const addressFields = [elements.address, elements.routeStart, elements.routeEnd].filter(Boolean);
  
  addressFields.forEach(addressField => {
    // Store state value before address field changes
    addressField.addEventListener('focus', () => {
      lastUserSelectedState = elements.state.value;
      stateProtectionActive = true;
      // Start watching for autofill changes to state dropdown - more frequent checks
      if (autofillWatchInterval) {
        clearInterval(autofillWatchInterval);
      }
      autofillWatchInterval = setInterval(() => {
        protectStateValue();
      }, 25); // Check every 25ms during autofill window (more frequent)
    });
    
    // Handle browser autofill event (some browsers fire this)
    addressField.addEventListener('change', () => {
      protectStateValue();
    });
    
    // Handle input event (autofill can trigger this)
    addressField.addEventListener('input', () => {
      protectStateValue();
    });
    
    // Stop watching when address field loses focus, but keep protection active longer
    addressField.addEventListener('blur', () => {
      // Keep protection active for a bit longer in case autofill happens after blur
      setTimeout(() => {
        if (autofillWatchInterval) {
          clearInterval(autofillWatchInterval);
          autofillWatchInterval = null;
        }
        // Final check and restore if needed
        protectStateValue();
        // Keep protection active for 3 more seconds after blur
        setTimeout(() => {
          // Protection stays active, just stop the interval
        }, 3000);
      }, 200);
    });
  });
  
  // Continuous protection - always watch for unauthorized changes
  setInterval(() => {
    if (stateProtectionActive && !isUserChangingState) {
      protectStateValue();
    }
  }, 100); // Check every 100ms continuously
  
  // Listen for user-initiated changes to state dropdown
  elements.state.addEventListener('mousedown', () => {
    isUserChangingState = true;
    lastUserSelectedState = elements.state.value;
  });
  
  elements.state.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter' || e.key === ' ') {
      isUserChangingState = true;
      lastUserSelectedState = elements.state.value;
    }
  });
  
  elements.state.addEventListener('change', function(e) {
    const currentValue = e.target.value;
    
    // If this change was initiated by user, update stored value
    if (isUserChangingState) {
      lastUserSelectedState = currentValue;
      isUserChangingState = false;
      
      // Track state filter usage
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_filter_state_used');
      }
      
      // Update filter chips
      updateFilterChips();
      
      // Continue with normal change handling
      if (activeMode === 'route' && route.lastSearch) {
        // Re-run route search with updated filters
        findCollegesAlongRoute();
      } else {
        render();
      }
    } else {
      // This change was NOT from user - likely autofill - restore previous value
      elements.state.value = lastUserSelectedState;
      // Don't trigger render since this wasn't a real change
      return; // Prevent further processing of this change
    }
  });
  
  // Reset flag after a short delay (only if change event didn't fire)
  elements.state.addEventListener('blur', () => {
    setTimeout(() => {
      // Only reset if change event hasn't already processed it
      // Check if value changed - if it did, change event should have handled it
      if (elements.state.value === lastUserSelectedState) {
        // Value didn't change, so user didn't select anything - safe to reset
        isUserChangingState = false;
      }
    }, 200);
  });
}

// Update mobile pill text format - labels are hidden on mobile, so this function is not needed
function updateMobilePillText() {
  // Labels are hidden on mobile (≤700px), so no text update needed
  // The select dropdown itself will show the selected value or placeholder
  return;
}

['region', 'type', 'ranking', 'radius', 'units'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    // Track filter usage
    if (typeof gtag !== 'undefined') {
      if (id === 'type') {
        gtag('event', 'feature_filter_type_used');
      } else if (id === 'region') {
        gtag('event', 'feature_filter_region_used');
      } else if (id === 'ranking') {
        gtag('event', 'feature_filter_ranking_used');
      }
    }
    
    // Update mobile pill text
    updateMobilePillText();
    
    // Update filter chips
    updateFilterChips();
    
    if (activeMode === 'route' && route.lastSearch) {
      // Re-run route search with updated filters
      findCollegesAlongRoute();
    } else {
      render();
    }
  });
});

// Function to shorten filter values for display in chips
function shortenFilterValue(value, filterType) {
  const shortenMap = {
    'type': {
      'Elite Private Universities': 'Elite Pri',
      'Public Flagship Universities': 'Pub Flagship',
      'Private Liberal Arts Colleges': 'Liberal Arts',
      'STEM / Technology Institutes': 'STEM / Tech',
      'Business / Arts / Specialty Schools': 'Biz/ Arts/Spec',
      'Health & Medical Colleges': 'Health/Med',
      'Public Regional Universities': 'Pub Reg',
      'Community Colleges': 'Community Coll',
      'Online / For-Profit': 'Online/FP'
    },
    'ranking': {
      'Top 25 national universities': 'Top25Nat',
      'Top 50 national universities': 'Top50 Nat',
      'Top 10 liberal arts colleges': 'Top10LAC',
      'Top 20 liberal arts colleges': 'Top20LAC'
    }
  };
  
  if (shortenMap[filterType] && shortenMap[filterType][value]) {
    return shortenMap[filterType][value];
  }
  return value;
}

// Function to update filter chips
function updateFilterChips() {
  const chipsContainer = document.getElementById('filter-chips');
  if (!chipsContainer) return;
  
  // Use event delegation for close buttons and clear all (handles both new and existing chips)
  if (!chipsContainer.dataset.delegationSetup) {
    chipsContainer.addEventListener('click', (e) => {
      if (e.target.classList.contains('filter-chip-close')) {
        e.stopPropagation();
        const chip = e.target.closest('.filter-chip');
        const filterType = e.target.dataset.filterType || chip?.dataset.filterType;
        if (chip && filterType) {
          chip.classList.add('slide-out');
          setTimeout(() => {
            clearFilter(filterType);
          }, 300);
        }
      } else {
        const clearAllTarget = e.target.closest('.filter-chip-clear-all');
        if (clearAllTarget) {
          e.stopPropagation();
          clearAllFilters();
        }
      }
    });
    chipsContainer.dataset.delegationSetup = 'true';
  }
  
  // Get current filter values
  const typeSelect = document.getElementById('type');
  const regionSelect = document.getElementById('region');
  const stateSelect = document.getElementById('state');
  const rankingSelect = document.getElementById('ranking');
  
  const chips = [];
  
  // Type filter
  if (typeSelect && typeSelect.value && typeSelect.value !== '') {
    const typeValue = typeSelect.options[typeSelect.selectedIndex]?.textContent || typeSelect.value;
    const shortened = shortenFilterValue(typeValue, 'type');
    chips.push({ type: 'type', label: shortened, value: typeSelect.value });
  }
  
  // Region filter
  if (regionSelect && regionSelect.value && regionSelect.value !== '') {
    const regionValue = regionSelect.options[regionSelect.selectedIndex]?.textContent || regionSelect.value;
    chips.push({ type: 'region', label: regionValue, value: regionSelect.value });
  }
  
  // State filter
  if (stateSelect && stateSelect.value && stateSelect.value !== '') {
    const stateValue = stateSelect.options[stateSelect.selectedIndex]?.textContent || stateSelect.value;
    chips.push({ type: 'state', label: stateValue, value: stateSelect.value });
  }
  
  // Ranking filter
  if (rankingSelect && rankingSelect.value && rankingSelect.value !== '') {
    const rankingValue = rankingSelect.options[rankingSelect.selectedIndex]?.textContent || rankingSelect.value;
    const shortened = shortenFilterValue(rankingValue, 'ranking');
    chips.push({ type: 'ranking', label: shortened, value: rankingSelect.value });
  }
  
  // Track existing chips to preserve animations
  const existingChips = Array.from(chipsContainer.children);
  const existingChipTypes = new Set(existingChips.map(chip => chip.dataset.filterType));
  const newChipTypes = new Set(chips.map(chip => chip.type));
  
  // Remove chips that are no longer needed (with slide-out animation)
  // Exclude "Clear All" pill from this logic - it's handled separately below
  existingChips.forEach(existingChip => {
    // Skip the "Clear All" pill - it doesn't have dataset.filterType
    if (existingChip.classList.contains('filter-chip-clear-all')) {
      return;
    }
    const chipType = existingChip.dataset.filterType;
    if (!newChipTypes.has(chipType)) {
      // Chip should be removed - animate out first
      existingChip.classList.add('slide-out');
      setTimeout(() => {
        if (existingChip.parentNode) {
          existingChip.remove();
        }
      }, 300); // Match animation duration
    }
  });
  
  // Add new chips (with slide-in animation)
  chips.forEach(chip => {
    // Check if chip already exists
    const existingChip = Array.from(chipsContainer.children).find(
      el => el.dataset.filterType === chip.type
    );
    
    if (!existingChip) {
      // New chip - create and animate in
      const chipElement = document.createElement('div');
      chipElement.className = 'filter-chip';
      chipElement.dataset.filterType = chip.type;
      chipElement.innerHTML = `
        <span class="filter-chip-label">${chip.label}</span>
        <button class="filter-chip-close" data-filter-type="${chip.type}" aria-label="Clear ${chip.type} filter" type="button">×</button>
      `;
      
      // Event delegation handles the close button click (set up above)
      chipsContainer.appendChild(chipElement);
    } else {
      // Update existing chip label if it changed
      const labelEl = existingChip.querySelector('.filter-chip-label');
      if (labelEl && labelEl.textContent !== chip.label) {
        labelEl.textContent = chip.label;
      }
      
      // Ensure existing chip doesn't have slide-out class (in case it was being removed)
      existingChip.classList.remove('slide-out');
    }
  });
  
  // Add or update "Clear All" pill when 2+ filters are active
  // Always ensure it's at the bottom of all chips
  // Don't remove/re-add it when filters change - just keep it visible and move it
  const activeFilterCount = chips.length;
  const existingClearAll = chipsContainer.querySelector('.filter-chip-clear-all');
  
  if (activeFilterCount >= 2) {
    // Show or update "Clear All" pill - keep it visible, just ensure it's at bottom
    if (!existingClearAll) {
      const clearAllElement = document.createElement('div');
      clearAllElement.className = 'filter-chip-clear-all filter-chip-new';
      clearAllElement.innerHTML = '<span>Clear all</span><span class="filter-chip-clear-all-icon">↺</span>';
      clearAllElement.setAttribute('role', 'button');
      clearAllElement.setAttribute('tabindex', '0');
      clearAllElement.setAttribute('aria-label', 'Clear all filters');
      // Event delegation handles the click (set up above)
      // Always append to end to ensure it's at the bottom
      chipsContainer.appendChild(clearAllElement);
      // Remove the animation class after animation completes
      setTimeout(() => {
        clearAllElement.classList.remove('filter-chip-new');
      }, 300);
    } else {
      // Pill already exists - just ensure it's at the bottom and visible
      // Remove any slide-out or animation classes
      existingClearAll.classList.remove('slide-out', 'filter-chip-new');
      // Move to bottom if it's not already there (this will smoothly move it down)
      // Only move if it's not already the last child to avoid unnecessary DOM manipulation
      if (existingClearAll.nextSibling || existingClearAll !== chipsContainer.lastElementChild) {
        chipsContainer.appendChild(existingClearAll);
      }
    }
  } else {
    // Only remove "Clear All" pill when there are less than 2 filters
    if (existingClearAll) {
      existingClearAll.classList.add('slide-out');
      setTimeout(() => {
        if (existingClearAll.parentNode) {
          existingClearAll.remove();
        }
      }, 300); // Match animation duration
    }
  }
}

// Function to clear all filters
function clearAllFilters() {
  const filterTypes = ['type', 'region', 'state', 'ranking'];
  
  // Clear each filter
  filterTypes.forEach(filterType => {
    const select = document.getElementById(filterType);
    if (select) {
      // Special handling for state filter due to autofill protection
      if (filterType === 'state' && elements.state) {
        // Temporarily disable autofill protection
        const wasProtectionActive = stateProtectionActive;
        stateProtectionActive = false;
        
        // Mark as user-initiated change to bypass autofill protection
        isUserChangingState = true;
        lastUserSelectedState = '';
        elements.state.value = '';
        
        // Trigger change event to update map
        const changeEvent = new Event('change', { bubbles: true });
        elements.state.dispatchEvent(changeEvent);
        
        // Reset flags after a short delay to allow change handler to process
        setTimeout(() => {
          isUserChangingState = false;
          stateProtectionActive = wasProtectionActive;
        }, 100);
      } else {
        // For other filters, just clear and trigger change
        select.value = '';
        const changeEvent = new Event('change', { bubbles: true });
        select.dispatchEvent(changeEvent);
      }
    }
  });
  
  // Update filter chips after all filters are cleared
  updateFilterChips();
  
  // Trigger render to update map
  if (activeMode === 'route' && route.lastSearch) {
    findCollegesAlongRoute();
  } else {
    render();
  }
}

// Function to clear a specific filter
function clearFilter(filterType) {
  const select = document.getElementById(filterType);
  if (select) {
    // Special handling for state filter due to autofill protection
    if (filterType === 'state' && elements.state) {
      // Temporarily disable autofill protection
      const wasProtectionActive = stateProtectionActive;
      stateProtectionActive = false;
      
      // Mark as user-initiated change to bypass autofill protection
      isUserChangingState = true;
      lastUserSelectedState = '';
      elements.state.value = '';
      
      // Update filter chips immediately
      updateFilterChips();
      
      // Trigger change event to update map
      const changeEvent = new Event('change', { bubbles: true });
      elements.state.dispatchEvent(changeEvent);
      
      // Reset flags after a short delay to allow change handler to process
      setTimeout(() => {
        isUserChangingState = false;
        stateProtectionActive = wasProtectionActive;
      }, 100);
    } else {
      // For other filters, just clear and trigger change
      select.value = '';
      
      // Update filter chips immediately
      updateFilterChips();
      
      // Trigger change event to update map
      const changeEvent = new Event('change', { bubbles: true });
      select.dispatchEvent(changeEvent);
    }
  }
}

// Function to move ranking between row-filters and row-ranking based on screen size
function positionRankingDropdown() {
  // Try to find ranking pill in either location
  let rankingPill = document.querySelector('.row-filters .pill-ranking');
  if (!rankingPill) {
    rankingPill = document.querySelector('.row-ranking .pill-ranking');
  }
  const rowRanking = document.querySelector('.row-ranking');
  const rowFilters = document.querySelector('.row-filters');
  
  if (!rankingPill || !rowRanking || !rowFilters) {
    // If elements don't exist yet, try again after a short delay
    if (document.readyState === 'loading') {
      setTimeout(positionRankingDropdown, 100);
    }
    return;
  }
  
  const isMobile = window.innerWidth <= 700;
  
  if (isMobile) {
    // Move ranking to row-ranking on mobile
    // First ensure row-ranking is visible
    rowRanking.style.display = 'flex';
    rowRanking.style.setProperty('display', 'flex', 'important');
    
    if (rankingPill.parentElement !== rowRanking) {
      // Remove display:none before moving
      rankingPill.style.display = '';
      rankingPill.style.removeProperty('display');
      rowRanking.appendChild(rankingPill);
    }
    
    // Ensure it's visible after moving
    rankingPill.style.display = 'flex';
    rankingPill.style.setProperty('display', 'flex', 'important');
  } else {
    // Move ranking back to row-filters on desktop/tablet
    if (rankingPill.parentElement !== rowFilters) {
      // Insert after state pill
      const statePill = document.querySelector('.row-filters .pill:has(#state)');
      if (statePill && statePill.nextSibling) {
        rowFilters.insertBefore(rankingPill, statePill.nextSibling);
      } else {
        rowFilters.appendChild(rankingPill);
      }
    }
  }
}

// Update mobile pill text and dropdown placeholders on initial load and window resize
updateDropdownPlaceholders();
positionRankingDropdown();
updateFilterChips();
if (window.innerWidth <= 700) {
  updateMobilePillText();
}
window.addEventListener('resize', () => {
  // Update dropdown placeholder text based on screen size
  updateDropdownPlaceholders();
  
  // Reposition ranking dropdown based on screen size
  positionRankingDropdown();
  
  if (window.innerWidth <= 700) {
    updateMobilePillText();
  } else {
    // Reset to default on desktop
    ['type', 'region', 'state', 'ranking'].forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        const labelEl = select.closest('.pill')?.querySelector('label');
        if (labelEl) {
          const labels = { type: 'Type', region: 'Region', state: 'State', ranking: 'Ranking' };
          labelEl.textContent = labels[id];
        }
      }
    });
  }
});

// Debounced search input - use event delegation to handle both desktop and mobile search fields
// Performance: Debounced to 300ms to avoid heavy re-renders on every keystroke
// Dropdown changes (Type, Region, State) are NOT debounced - they update immediately for better UX
document.querySelector('.controls').addEventListener('input', debounce((e) => {
  if (e.target.id === 'search' || e.target.id === 'search-mobile') {
    // Sync values between both search fields if they exist
    // Respect activeMode - only render in nearby mode, or re-run route search in route mode
    if (activeMode === 'route' && route.lastSearch) {
      findCollegesAlongRoute();
      return;
    }
    const desktopSearch = document.getElementById('search');
    const mobileSearch = document.getElementById('search-mobile');
    if (e.target.id === 'search' && mobileSearch) {
      mobileSearch.value = e.target.value;
    } else if (e.target.id === 'search-mobile' && desktopSearch) {
      desktopSearch.value = e.target.value;
    }
    render();
  }
}, 300));

// Check if running from file:// protocol (won't work due to CORS)
if (window.location.protocol === 'file:') {
  showError('Please use a web server to test this page. CSV files cannot load from file:// protocol. Use: python3 -m http.server 8000');
  console.error('Cannot load CSV from file:// protocol due to CORS restrictions');
} else {
loadCSV(DATA_URL);
}
</script>

<!-- Feedback Widget -->
<div class="feedback-button" id="feedbackButton">Feedback</div>
<div class="feedback-popup" id="feedbackPopup">
  <div class="feedback-popup-header">
    <div></div>
    <button class="feedback-popup-close" id="feedbackClose" aria-label="Close">×</button>
  </div>
  <div class="feedback-popup-message">We're improving U.S. College Map. Got 30 seconds to tell us what to fix next?</div>
  <div class="feedback-popup-button-wrapper">
    <a href="https://forms.gle/tGNzJr9THUYKfUPZ8" target="_blank" rel="noopener noreferrer" class="feedback-popup-button" style="text-decoration:none">Open feedback form</a>
  </div>
  <a href="#" class="feedback-popup-dismiss" id="feedbackDismiss">Don't show again</a>
</div>

<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E2KP0JHTMC"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-E2KP0JHTMC');
</script>

<script>
// Feedback Widget
(function() {
  'use strict';
  
  const feedbackButton = document.getElementById('feedbackButton');
  const feedbackPopup = document.getElementById('feedbackPopup');
  
  // Check if user has dismissed the feedback widget
  if (localStorage.getItem('uscm_feedback_dismissed') === 'true') {
    if (feedbackButton) feedbackButton.style.display = 'none';
    if (feedbackPopup) feedbackPopup.style.display = 'none';
    return; // Don't set up event listeners
  }
  
  const feedbackClose = document.getElementById('feedbackClose');
  const feedbackDismiss = document.getElementById('feedbackDismiss');
  
  // Open popup
  feedbackButton.addEventListener('click', function(e) {
    e.stopPropagation();
    feedbackPopup.classList.add('active');
  });
  
  // Close popup
  feedbackClose.addEventListener('click', function() {
    feedbackPopup.classList.remove('active');
  });
  
  // Dismiss permanently
  feedbackDismiss.addEventListener('click', function(e) {
    e.preventDefault();
    localStorage.setItem('uscm_feedback_dismissed', 'true');
    feedbackButton.classList.add('hidden');
    feedbackPopup.classList.remove('active');
  });
  
  // Close popup when clicking outside
  document.addEventListener('click', function(e) {
    if (feedbackPopup.classList.contains('active') && 
        !feedbackPopup.contains(e.target) && 
        !feedbackButton.contains(e.target)) {
      feedbackPopup.classList.remove('active');
    }
  });
})();

// Ranking info tooltip functionality
(function() {
  const rankingInfoBtn = document.getElementById('ranking-info-btn');
  const rankingTooltip = document.getElementById('ranking-tooltip');
  const rankingTooltipClose = document.getElementById('ranking-tooltip-close');
  
  if (rankingInfoBtn && rankingTooltip) {
    let isTooltipOpen = false;
    
    function toggleTooltip(e) {
      e.stopPropagation();
      isTooltipOpen = !isTooltipOpen;
      if (isTooltipOpen) {
        rankingTooltip.classList.add('active');
      } else {
        rankingTooltip.classList.remove('active');
      }
    }
    
    function closeTooltip(e) {
      if (e) e.stopPropagation();
      isTooltipOpen = false;
      rankingTooltip.classList.remove('active');
    }
    
    // Close button functionality
    if (rankingTooltipClose) {
      rankingTooltipClose.addEventListener('click', closeTooltip);
    }
    
    // Desktop: hover and click
    rankingInfoBtn.addEventListener('mouseenter', () => {
      if (!isTooltipOpen) {
        rankingTooltip.classList.add('active');
      }
    });
    
    rankingInfoBtn.addEventListener('mouseleave', () => {
      if (!isTooltipOpen) {
        rankingTooltip.classList.remove('active');
      }
    });
    
    rankingInfoBtn.addEventListener('click', toggleTooltip);
    
    // Close on click outside
    document.addEventListener('click', function(e) {
      if (isTooltipOpen && 
          !rankingTooltip.contains(e.target) && 
          !rankingInfoBtn.contains(e.target)) {
        closeTooltip();
      }
    });
    
    // Mobile: tap to toggle
    rankingInfoBtn.addEventListener('touchend', function(e) {
      e.preventDefault();
      toggleTooltip(e);
    });
  }
})();

// Show "NEW!" chat bubble for ranking filter for return users who haven't seen it
(function() {
  const RANKING_NEW_BUBBLE_KEY = 'ucm_rankingNewBubbleSeen';
  
  function showRankingNewBubble() {
    // Check if user has seen it before
    const hasSeen = localStorage.getItem(RANKING_NEW_BUBBLE_KEY) === '1';
    if (hasSeen) {
      return; // Don't show if already seen
    }
    
    // Find the ranking pill and chat bubble
    const rankingPill = document.querySelector('.pill-ranking');
    const chatBubble = document.getElementById('ranking-new-chat-bubble');
    
    if (!rankingPill || !chatBubble) {
      // Retry after a short delay if elements aren't ready
      setTimeout(showRankingNewBubble, 200);
      return;
    }
    
    // Position the bubble above the ranking dropdown using fixed positioning
    // On desktop/tablet, the label is hidden, so use the select element
    const rankingSelect = rankingPill.querySelector('select#ranking');
    const label = rankingPill.querySelector('label[for="ranking"]');
    
    let targetElement = label;
    // Check if label is visible (not display:none)
    if (!label || label.offsetParent === null) {
      // Label is hidden, use select element instead
      targetElement = rankingSelect;
    }
    
    if (targetElement) {
      const rect = targetElement.getBoundingClientRect();
      // Use viewport coordinates for fixed positioning
      chatBubble.style.left = rect.left + 'px';
      chatBubble.style.top = (rect.top - 28) + 'px'; // 28px above the element
    } else {
      // Final fallback: position relative to the pill
      const pillRect = rankingPill.getBoundingClientRect();
      chatBubble.style.left = pillRect.left + 'px';
      chatBubble.style.top = (pillRect.top - 28) + 'px';
    }
    
    // Ensure bubble is visible and log for debugging
    chatBubble.style.display = 'block';
    chatBubble.style.visibility = 'visible';
    console.log('Ranking bubble positioned:', {
      left: chatBubble.style.left,
      top: chatBubble.style.top,
      visible: chatBubble.classList.contains('visible'),
      computedDisplay: window.getComputedStyle(chatBubble).display,
      computedZIndex: window.getComputedStyle(chatBubble).zIndex
    });
    
    // Show the bubble
    chatBubble.classList.add('visible');
    
    // Hide after 5 seconds
    setTimeout(() => {
      chatBubble.classList.remove('visible');
      // Mark as seen
      localStorage.setItem(RANKING_NEW_BUBBLE_KEY, '1');
    }, 5000);
  }
  
  // Show bubble after page loads and ranking dropdown is positioned
  function initRankingBubble() {
    // Wait for elements to be ready
    setTimeout(() => {
      const rankingPill = document.querySelector('.pill-ranking');
      if (rankingPill) {
        showRankingNewBubble();
      } else {
        // Retry if not ready yet
        setTimeout(initRankingBubble, 200);
      }
    }, 800);
  }
  
  document.addEventListener('DOMContentLoaded', initRankingBubble);
  
  // Also try after window load
  if (document.readyState === 'complete') {
    initRankingBubble();
  } else {
    window.addEventListener('load', initRankingBubble);
  }
  
  // Expose function for testing (can be called from console)
  window.testRankingBubble = function() {
    localStorage.removeItem(RANKING_NEW_BUBBLE_KEY);
    showRankingNewBubble();
  };
  
  // Expose function to check status
  window.checkRankingBubbleStatus = function() {
    const hasSeen = localStorage.getItem(RANKING_NEW_BUBBLE_KEY) === '1';
    console.log('Ranking bubble seen:', hasSeen);
    return hasSeen;
  };
})();
</script>

</body>
</html>
