<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="google-site-verification" content="XLI_3QT03lSkcCEmteQWtQeDviYsA07lmIbGu_5GKCc" />
  <meta name="msvalidate.01" content="CA49DC12684491A5E489D6BA5BD08ED5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Branding and Icons -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="manifest" href="site.webmanifest">

  <!-- SEO Meta Tags -->
  <title>U.S. College Map | Find Colleges Near You & Along Any Route</title>
  <link rel="canonical" href="https://uscollegemap.org/">
  <meta name="description" content="U.S. College Map helps students and families explore U.S. colleges on an interactive map. Find colleges near you or along a driving route, filter by type, region, or state, and save favorite schools to a list for early research and campus visit planning.">
  <meta name="keywords" content="college map, university map, US colleges, college finder, college search tool, find colleges near me, colleges along a route, interactive college map, college visit planning, campus visit planner, college route planner, save colleges, college list builder">
  <meta name="author" content="U.S. College Map">

  <!-- Open Graph (Social Media Preview) -->
  <meta property="og:title" content="U.S. College Map — Find Colleges Near You & Along Any Route">
  <meta property="og:description" content="Explore U.S. colleges on an interactive map. Find schools near you or along your route, filter by type or state, and save favorite colleges to your list for easy trip planning.">
  <meta property="og:image" content="https://uscollegemap.org/us-college-map-logo.png">
<meta property="og:url" content="https://uscollegemap.org/">
<meta property="og:type" content="website">
<meta property="og:site_name" content="U.S. College Map">

  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="U.S. College Map — Find Colleges Near You & Along Any Route">
  <meta name="twitter:description" content="Explore U.S. colleges on an interactive map. Find schools near you or along a route, filter by type or state, and save favorites for easy visit planning.">
  <meta name="twitter:image" content="https://uscollegemap.org/us-college-map-logo.png">

  <!-- Schema Markup (Structured Data) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "U.S. College Map",
    "url": "https://uscollegemap.org/",
    "description": "Explore U.S. colleges on an interactive map. Find schools near you or along a driving route, filter by type or state, and save favorite colleges to build your list for campus visit planning.",
    "applicationCategory": "Education",
    "operatingSystem": "All",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "creator": {
      "@type": "Organization",
      "name": "U.S. College Map"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "ratingCount": "150"
    },
    "featureList": [
      "Interactive map of all U.S. colleges",
      "Filter colleges by state, region, or school type",
      "Search by college name",
      "Find colleges near your location",
      "See colleges along any driving route",
      "Save favorite colleges to your personal list",
      "View only your saved schools on the map",
      "Plan early college visits efficiently"
    ]
  }
  </script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "url": "https://uscollegemap.org/",
    "name": "U.S. College Map",
    "alternateName": "US College Map",
    "description": "Interactive map of U.S. colleges where you can filter, search, save favorite schools, and explore colleges near you or along any route."
  }
  </script>
  
  <!-- BreadcrumbList Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [{
      "@type": "ListItem",
      "position": 1,
      "name": "Home",
      "item": "https://uscollegemap.org/"
    }]
  }
  </script>

  <!-- Resource Hints for Performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://nominatim.openstreetmap.org">

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body {margin:0;font-family:Inter,system-ui,sans-serif;background:#fff;color:#0f172a}
    .main-container {display:flex;flex-direction:column;min-height:100vh}
    .container {max-width:1100px;margin:0 auto;padding:16px}
    header.app-header {position:sticky;top:0;background:#fff;z-index:5000;border-bottom:1px solid #e2e8f0;box-shadow:0 10px 25px rgba(15,23,42,.08)}
    .app-header {display:flex;align-items:flex-start;justify-content:flex-start;padding:16px 40px;background:#fff;border-bottom:1px solid #e5e7eb;box-shadow:0 4px 10px rgba(0,0,0,0.05);transition:padding 0.25s ease, min-height 0.25s ease, box-shadow 0.25s ease}
    .header-logo-tagline {display:flex;flex-direction:column;align-items:flex-start;gap:0}
    .site-logo {height:70px;width:auto;object-fit:contain;transition:all 0.3s ease;margin-bottom:0}
    .tagline {font-family:Inter,sans-serif;font-size:14px;color:#6b7280;line-height:1.5;text-align:left;margin:0;margin-top:4px;margin-bottom:3px;margin-left:10px;font-weight:400;max-width:calc(100% - 10px)}
    .sr-only {position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}
    @media (max-width:700px){
      .app-header{flex-direction:row;align-items:flex-start;text-align:left;padding:12px 16px;min-height:90px;}
      .app-header.collapsed{padding:6px 14px;min-height:64px;box-shadow:0 2px 6px rgba(15,23,42,0.12);}
      .header-logo-tagline{align-items:flex-start;text-align:left}
      .tagline{text-align:left;margin-left:0;max-width:100%;font-size:12px;color:#94A3B8;line-height:1.4;margin-top:4px;margin-bottom:6px;transition:opacity 0.25s ease,max-height 0.25s ease}
      .app-header.collapsed .tagline{opacity:0;max-height:0;margin:0;overflow:hidden}
      .site-logo{height:56px;width:auto;object-fit:contain;margin-bottom:0;transition:height 0.25s ease}
      .container{padding:6px;}
      .controls{padding:8px 8px;gap:2px;}
      .row-filters{flex-direction:row;gap:6px;flex-wrap:nowrap;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);min-width:0;}
      .row-filters .pill label{display:none}
      .row-filters .pill select{width:100%;font-size:14px;padding:6px 8px;}
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .row-nearby .pill.address-autocomplete{flex:1 1 100%;}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:14px;}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:6px 10px;margin-left:4px;}
      .row-nearby .pill:not(.address-autocomplete){flex:1 1 100%;flex-direction:row;align-items:center;flex-wrap:wrap;padding:6px;}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:12px !important;font-weight:600;color:#475569;}
      .row-nearby #radius{width:80px;flex:0 0 auto;max-width:80px;}
      .row-nearby #units{width:60px;flex:0 0 auto;max-width:60px;}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:8px;}
      .pill{flex-direction:row;align-items:center;padding:6px;}
      .pill label{min-width:60px;margin-bottom:0;width:auto;font-size:11px;}
      .pill input,.pill select,.pill button{width:auto;flex:1;}
      .legend{position:relative;bottom:auto;left:auto;margin:6px;width:calc(100% - 12px);text-align:center;}
    }
    .controls {display:flex;flex-direction:column;gap:3px;padding:10px 12px 6px;border-top:1px solid #e5e7eb;background:#fff}
    .row {display:flex;gap:8px;justify-content:space-between}
    .row>.pill {flex:1}
    .row-filters{display:flex;gap:8px;justify-content:space-between}
    .row-filters .pill{flex:1}
    .row-search{display:none}
    .row-filters .pill-search{display:none !important}
    @media (min-width:1025px) {
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .controls{flex-direction:row;flex-wrap:wrap;align-items:flex-start}
      .row-filters{flex:1 1 100%;margin-bottom:3px;gap:8px}
      .row-filters .pill{flex:1 1 0}
      .row-filters .pill-search{flex:1 1 auto;min-width:200px}
      .row-filters .pill-search input{font-size:14px}
      .row-nearby{display:flex;flex-direction:row;gap:8px;flex-wrap:nowrap;margin-bottom:0;align-items:center}
      .row-nearby .pill.address-autocomplete{flex:1 1 auto;min-width:0}
      .row-nearby .pill.address-autocomplete label{min-width:60px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{font-size:14px}
      .row-nearby .pill.address-autocomplete button{font-size:14px}
      .row-nearby .pill:not(.address-autocomplete){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:60px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-nearby #radius{width:70px;flex:0 0 auto;font-size:14px}
      .row-nearby #units{width:55px;flex:0 0 auto;font-size:14px}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
      .row-route{display:flex;flex-direction:row;gap:8px;flex-wrap:nowrap;margin-bottom:0;align-items:center}
      .row-route .pill{flex:1 1 auto;min-width:0}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex:1 1 auto;min-width:0}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:45px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:14px}
      .row-route .pill:has(#routeMaxDistance){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-route .pill:has(#routeMaxDistance) label{min-width:75px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:70px;flex:0 0 auto;font-size:14px}
      .row-route #routeUnits{width:55px;flex:0 0 auto;font-size:14px}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
      .row-route #clearRoute{width:auto;flex:0 0 auto;padding:6px 12px;margin-left:6px;font-size:14px}
    }
    .pill {display:flex;align-items:center;gap:6px;background:#f1f5f9;border:1px solid #e2e8f0;padding:4px 8px;border-radius:12px;font-size:12px}
    .pill label {color:#475569;font-weight:600;font-size:12px;min-width:60px}
    .pill input,.pill select,.pill button {border:1px solid #e2e8f0;border-radius:10px;padding:6px 8px;background:#fff;color:#0f172a;font-size:14px;flex:1;transition:border-color 0.2s,box-shadow 0.2s}
    .pill input:focus {outline:none;border-color:#4285f4;box-shadow:0 0 0 1px #4285f4}
    .pill button {background:#2563eb;color:#fff;border:none;font-weight:600;cursor:pointer;flex:0}
    #map {height:calc(100vh - 280px);background:#e5e7eb;border-top:1px solid #e2e8f0;position:relative;z-index:1;min-height:500px}
    .legend {position:absolute;bottom:14px;left:14px;padding:0;border:none;font-size:11px;font-weight:500;color:#0f172a;text-shadow:none;z-index:1800;background:none;border-radius:0;line-height:1;text-align:left;transform:none}
    .map-hint-bubble {position:absolute;top:16px;left:16px;background:rgba(255,255,255,0.98);padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(15,23,42,0.18);font-size:0.75rem;max-width:260px;width:clamp(180px, calc(100vw - 32px), 260px);display:none;z-index:2000;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(226,232,240,0.8)}
    .map-hint-bubble.active {display:block;animation:fadeIn 0.2s ease-out}
    .map-hint-bubble-header {display:flex;align-items:center;gap:8px;margin-bottom:6px}
    .map-hint-bubble-icon {font-size:16px;line-height:1;flex-shrink:0}
    .map-hint-bubble-close {background:none;border:none;color:#94a3b8;cursor:pointer;font-size:18px;line-height:1;padding:0;width:18px;height:18px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:color 0.2s;margin-left:auto;margin-top:-2px;margin-right:-4px}
    .map-hint-bubble-close:hover {color:#64748b}
    .map-hint-bubble-title {font-weight:600;font-size:0.875rem;line-height:1.4;color:#0f172a;flex:1}
    .map-hint-bubble-body {font-size:0.8125rem;line-height:1.5;color:#64748b}
    @media (max-width:700px) {
      .map-hint-bubble {top:16px;left:12px;right:12px;width:clamp(160px, calc(100vw - 24px), 260px);max-width:calc(100vw - 24px);box-sizing:border-box}
    }
    .map-tip-bubble {position:absolute;top:16px;left:16px;background:rgba(255,255,255,0.98);padding:10px 12px;border-radius:12px;box-shadow:0 8px 20px rgba(15,23,42,0.18);font-size:0.8125rem;max-width:280px;width:clamp(200px, calc(100vw - 32px), 280px);display:none;z-index:2001;pointer-events:auto;font-family:Inter,sans-serif;border:1px solid rgba(226,232,240,0.8)}
    .map-tip-bubble.active {display:block;animation:fadeIn 0.2s ease-out}
    .map-tip-bubble-content {display:flex;align-items:center;gap:8px}
    .map-tip-bubble-icon {font-size:14px;line-height:1;flex-shrink:0}
    .map-tip-bubble-text {font-size:0.8125rem;line-height:1.4;color:#0f172a;flex:1}
    .map-tip-bubble-close {background:none;border:none;color:#94a3b8;cursor:pointer;font-size:16px;line-height:1;padding:0;width:16px;height:16px;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:color 0.2s;margin-left:4px}
    .map-tip-bubble-close:hover {color:#64748b}
    @media (max-width:700px) {
      .map-tip-bubble {top:12px;left:12px;right:12px;max-width:calc(100vw - 24px);width:clamp(180px, calc(100vw - 24px), 280px);font-size:0.75rem;padding:8px 10px;box-sizing:border-box}
      .map-tip-bubble-icon {font-size:12px}
    }
    .leaflet-tooltip {background:#fff;color:#0f172a;border:1px solid #e2e8f0;border-radius:6px;font-size:12px;font-weight:500;padding:4px 8px;box-shadow:0 2px 6px rgba(0,0,0,.1)}
    /* Override Leaflet's default orange tap highlight on mobile/iPad - match desktop (white/no highlight) */
    .leaflet-interactive:active,
    .leaflet-interactive:focus,
    .leaflet-interactive.leaflet-touch-active {
      outline: none !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    /* Remove orange tap highlight and use white styling (matching desktop behavior) */
    /* Target both SVG circle elements and path elements used by Leaflet circleMarker */
    .leaflet-interactive.leaflet-touch-active circle,
    .leaflet-interactive:active circle,
    .leaflet-interactive:focus circle,
    .leaflet-interactive.leaflet-touch-active path,
    .leaflet-interactive:active path,
    .leaflet-interactive:focus path {
      /* Use white stroke instead of orange (matching desktop tap behavior) */
      stroke: #ffffff !important;
      stroke-width: 2 !important;
      /* Keep original blue fill */
      fill: #2563eb !important;
      fill-opacity: 0.7 !important;
      /* Remove any orange filter or effects */
      filter: none !important;
    }
    .route-hint-bubble {position:fixed;background:linear-gradient(180deg,rgba(255,249,219,0.98),rgba(255,243,191,0.98));padding:8px 12px;border-radius:12px;box-shadow:0 8px 18px rgba(15,23,42,0.18);font-size:12px;max-width:210px;display:none;z-index:6500;border:1px solid rgba(234,179,8,0.5);pointer-events:auto;opacity:0;transform:translateY(6px);transition:opacity 0.2s ease,transform 0.2s ease}
    .route-hint-bubble.visible {opacity:1;transform:translateY(0)}
    .route-hint-bubble-content {display:flex;align-items:center;font-weight:500;color:#0f172a}
    .route-hint-bubble::after {content:'';position:absolute;bottom:-8px;left:50%;transform:translateX(-50%);border-width:8px 8px 0 8px;border-style:solid;border-color:rgba(255,243,191,0.98) transparent transparent transparent;filter:drop-shadow(0 2px 4px rgba(15,23,42,0.15))}
    .route-hint-bubble::before {content:'';position:absolute;bottom:-9px;left:50%;transform:translateX(-50%);border-width:9px 9px 0 9px;border-style:solid;border-color:rgba(234,179,8,0.5) transparent transparent transparent}
    .route-hint-bubble.below::after {top:-8px;bottom:auto;border-width:0 8px 8px 8px;border-color:transparent transparent rgba(255,243,191,0.98) transparent}
    .route-hint-bubble.below::before {top:-9px;bottom:auto;border-width:0 9px 9px 9px;border-color:transparent transparent rgba(234,179,8,0.5) transparent}
    .route-hint-bubble-text {line-height:1.3;display:block;white-space:nowrap}
    .loading {display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;padding:20px;border-radius:12px;box-shadow:0 10px 25px rgba(15,23,42,.15);z-index:1000}
    .loading.active {display:block}
    .error {display:none;background:#fee;color:#c33;padding:12px;border-radius:8px;margin:12px;border:1px solid #fcc}
    .error.active {display:block}
    .site-footer {background:#fff;border-top:1px solid #e2e8f0;padding:10px 16px;font-size:12px;color:#94A3B8;text-align:center}
    .feedback-button {position:fixed;bottom:18px;right:18px;background:#2563eb;color:#fff;border:none;padding:10px 16px;border-radius:8px;font-family:Inter,sans-serif;font-size:14px;font-weight:500;cursor:pointer;box-shadow:0 4px 12px rgba(37,99,235,0.3);z-index:1000;transition:all 0.2s ease}
    .feedback-button:hover {background:#1d4ed8;box-shadow:0 6px 16px rgba(37,99,235,0.4);transform:translateY(-2px)}
    .feedback-button.hidden {display:none}
    .feedback-popup {position:fixed;bottom:70px;right:18px;width:280px;background:#fff;border-radius:12px;box-shadow:0 10px 25px rgba(15,23,42,.15);border:1px solid #e2e8f0;z-index:1001;padding:20px;display:none;animation:fadeIn 0.2s ease-out}
    .feedback-popup.active {display:block}
    .feedback-popup-header {display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px;margin-top:-2px}
    .feedback-popup-close {background:none;border:none;font-size:24px;color:#94a3b8;cursor:pointer;line-height:1;padding:0;width:24px;height:24px;display:flex;align-items:center;justify-content:center;transition:color 0.2s}
    .feedback-popup-close:hover {color:#64748b}
    .feedback-popup-message {font-size:14px;color:#0f172a;line-height:1.5;margin-bottom:16px}
    .feedback-popup-button {display:inline-block;background:#2563eb;color:#fff;border:none;padding:10px 28px;border-radius:8px;font-family:Inter,sans-serif;font-size:14px;font-weight:500;cursor:pointer;transition:background 0.2s}
    .feedback-popup-button-wrapper {text-align:center;margin-bottom:12px}
    .feedback-popup-button:hover {background:#1d4ed8}
    .feedback-popup-dismiss {display:block;text-align:center;font-size:12px;color:#94a3b8;text-decoration:none;cursor:pointer;transition:color 0.2s}
    .feedback-popup-dismiss:hover {color:#64748b}
    @media (max-width:700px){
      .feedback-popup {width:calc(100% - 36px);max-width:280px;right:18px;left:auto}
    }
    .radius-circle {stroke:#2563eb;stroke-width:2;stroke-dasharray:5,5;fill:none;opacity:0.5;pointer-events:none}
    .address-autocomplete {position:relative;z-index:10;isolation:isolate}
    .address-autocomplete.autocomplete-active {z-index:3000}
    .autocomplete-suggestions {display:none;position:absolute;top:calc(100% + 4px);left:0;right:0;background:#fff;border:none;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.1),0 8px 24px rgba(0,0,0,0.12);max-height:400px;overflow-y:auto;overflow-x:hidden;z-index:1001;margin-top:0;pointer-events:auto;transform:translateZ(0);will-change:transform}
    .autocomplete-suggestions.active {display:block;animation:fadeIn 0.15s ease-out}
    @keyframes fadeIn {from{opacity:0;transform:translateY(-4px)} to{opacity:1;transform:translateY(0)}}
    .autocomplete-item {padding:0;cursor:pointer;border-bottom:none;font-size:14px;transition:background-color 0.1s;min-height:48px;display:flex;flex-direction:row;align-items:center;position:relative;width:100%;pointer-events:auto;user-select:none;-webkit-user-select:none}
    .autocomplete-item:not(:last-child)::after {content:'';position:absolute;bottom:0;left:56px;right:0;height:1px;background:#f1f5f9}
    .autocomplete-item:hover,.autocomplete-item.highlighted {background-color:#f8f9fa}
    .autocomplete-item:focus {outline:2px solid #4285f4;outline-offset:-2px;background-color:#f8f9fa}
    .autocomplete-item-icon {width:40px;height:40px;display:flex;align-items:center;justify-content:center;flex-shrink:0;margin-left:8px}
    .autocomplete-item-icon svg {width:20px;height:20px;fill:#5f6368;display:block}
    .autocomplete-item.highlighted .autocomplete-item-icon svg,.autocomplete-item:hover .autocomplete-item-icon svg {fill:#4285f4}
    .autocomplete-item-content {flex:1;padding:12px 8px 12px 0;min-width:0;display:flex;flex-direction:column;justify-content:center}
    .autocomplete-item .address-name {font-weight:400;color:#202124;margin-bottom:2px;font-size:15px;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .autocomplete-item .address-name strong {font-weight:500;color:#202124}
    .autocomplete-item.highlighted .address-name,.autocomplete-item:hover .address-name {color:#1a73e8}
    .autocomplete-item.highlighted .address-name strong,.autocomplete-item:hover .address-name strong {color:#1a73e8;font-weight:500}
    .autocomplete-item .address-details {font-size:13px;color:#5f6368;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .autocomplete-loading {padding:16px;text-align:center;color:#5f6368;font-size:14px;display:flex;align-items:center;justify-content:center;gap:8px}
    .autocomplete-loading::before {content:'';width:16px;height:16px;border:2px solid #e0e0e0;border-top-color:#4285f4;border-radius:50%;animation:spin 0.8s linear infinite}
    @keyframes spin {to{transform:rotate(360deg)}}
    .autocomplete-empty {padding:24px;text-align:center;color:#5f6368;font-size:14px}
    .autocomplete-section-title{padding:10px 16px;font-size:12px;letter-spacing:0.08em;text-transform:uppercase;color:#94a3b8;font-weight:600}
    .autocomplete-divider{height:1px;background:#e2e8f0;margin:4px 0}
    @media (max-width: 700px) {
      .autocomplete-item {min-height:52px}
      .autocomplete-item-icon {width:44px;height:44px;margin-left:12px}
      .autocomplete-item-content {padding:14px 12px 14px 0}
      .row-nearby{flex-direction:column;gap:6px}
      .row-nearby .pill.address-autocomplete{flex-direction:row;align-items:center;flex-wrap:wrap}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:11px !important;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:12px !important}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-nearby .pill:not(.address-autocomplete){flex-direction:row;align-items:center;flex-wrap:wrap}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px !important;margin-bottom:0;width:auto;margin-right:8px;font-size:11px !important;font-weight:600;color:#475569}
      .row-nearby #radius{width:50px !important;flex:0 0 auto;max-width:50px;font-size:12px !important}
      .row-nearby #units{width:48px !important;flex:0 0 auto;max-width:48px;font-size:12px !important}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-route{flex-direction:column;gap:6px}
      .row-route .pill:has(#routeStart),.row-route .pill:has(#routeEnd){flex-direction:row;align-items:center}
      .row-route .pill:has(#routeStart) label,.row-route .pill:has(#routeEnd) label{min-width:40px !important;margin-bottom:0;width:auto;margin-right:5px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route .pill:has(#routeStart) input,.row-route .pill:has(#routeEnd) input{font-size:12px !important}
      .row-route .pill:has(#routeMaxDistance){flex-direction:row;align-items:center;flex-wrap:nowrap}
      .row-route .pill:has(#routeMaxDistance) label{min-width:60px !important;margin-bottom:0;width:auto;margin-right:4px;font-size:11px !important;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:50px !important;flex:0 0 auto;max-width:50px;padding:4px 5px !important;font-size:12px !important}
      .row-route #routeUnits{width:48px !important;flex:0 0 auto;max-width:48px;font-size:12px !important;padding:4px 3px !important}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
      .row-route #clearRoute{width:auto;flex:0 0 auto;margin-top:0;padding:5px 8px;margin-left:4px;font-size:12px !important}
    }
    @media (max-width: 700px) {
      html.ios-device .row-nearby #units {
        width:60px !important;
        max-width:60px !important;
      }
      html.ios-device .row-route .pill:has(#routeStart) label,
      html.ios-device .row-route .pill:has(#routeEnd) label,
      html.ios-device .row-route .pill:has(#routeMaxDistance) label {
        font-size:16px !important;
      }
    }
    @media (max-width: 480px) {
      .container{padding:4px;}
      .controls{padding:8px 4px;}
      .row{gap:6px;}
      .pill{padding:8px;}
    }
    @media (min-width: 701px) and (max-width: 1024px) {
      .row-filters{flex-direction:row;gap:6px;flex-wrap:nowrap;}
      .row-filters .pill{flex:1 1 calc(33.333% - 4px);min-width:0;}
      .row-filters .pill label{display:none}
      .row-filters .pill select{width:100%;font-size:12px;padding:6px 8px;}
      .row-filters .pill-search{display:none !important}
      .row-search{display:none !important}
      .row-search .pill{flex:1 1 100%;}
      .row-search .pill label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569;}
      .row-search .pill input{flex:1;width:auto;font-size:12px;}
      .controls{flex-direction:row;flex-wrap:wrap;align-items:flex-start}
      .row-filters{flex:1 1 100%;margin-bottom:3px}
      .row-search{flex:1 1 100%;margin-bottom:3px}
      .row-nearby{display:flex;flex-direction:row;gap:6px;flex-wrap:nowrap;margin-bottom:0}
      .row-nearby .pill.address-autocomplete{flex:1 1 auto;min-width:0}
      .row-nearby .pill.address-autocomplete label{min-width:70px;margin-bottom:0;width:auto;font-size:12px;font-weight:600;color:#475569}
      .row-nearby .pill.address-autocomplete input{flex:1;min-width:120px;font-size:12px}
      .row-nearby .pill.address-autocomplete button{flex:0 0 auto;padding:6px 10px;margin-left:4px;font-size:12px}
      .row-nearby .pill:not(.address-autocomplete){flex:0 1 auto;min-width:0;flex-direction:row;align-items:center}
      .row-nearby .pill:not(.address-autocomplete) label{min-width:70px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-nearby #radius{width:65px;flex:0 0 auto;max-width:65px;font-size:12px}
      .row-nearby #units{width:50px;flex:0 0 auto;max-width:50px;font-size:12px}
      .row-nearby #clearRadius{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .row-route{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:0}
      .row-route .pill:first-child,.row-route .pill:nth-child(2){width:100%;box-sizing:border-box;padding:4px 6px}
      .row-route .pill:first-child label,.row-route .pill:nth-child(2) label{min-width:40px;max-width:40px;margin-bottom:0;width:40px;margin-right:5px;font-size:12px;font-weight:600;color:#475569;flex-shrink:0}
      .row-route .pill:first-child input,.row-route .pill:nth-child(2) input{min-width:0;flex:1 1 0;padding:5px 6px;font-size:12px;box-sizing:border-box}
      .row-route .pill:last-child{grid-column:1 / -1;flex-direction:row;align-items:center;margin-top:0;padding:4px 6px}
      .row-route .pill:last-child label{min-width:70px;margin-bottom:0;width:auto;margin-right:6px;font-size:12px;font-weight:600;color:#475569}
      .row-route #routeMaxDistance{width:65px;flex:0 0 auto;max-width:65px;padding:5px 6px;font-size:12px}
      .row-route #routeUnits{width:50px;flex:0 0 auto;max-width:50px;padding:5px 4px;font-size:12px}
      .row-route #findRouteBtn{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .row-route #clearRoute{width:auto;flex:0 0 auto;padding:6px 10px;margin-left:6px;font-size:12px}
      .filter-section {margin-top:3px}
      .filter-section summary {padding:8px 10px;font-size:13px}
      .filter-section-content {padding:0 10px 8px}
    }
    .filter-section {background:#f8fafc;border-radius:12px;border:1px solid #e2e8f0;margin-top:4px;overflow:visible;width:100%;flex:1 1 100%;position:relative;transition:box-shadow 0.2s ease}
    .filter-section-content {overflow:visible}
    .filter-section summary {font-weight:600;color:#0f172a;font-size:14px;padding:8px 12px;cursor:pointer;list-style:none;user-select:none;display:flex;align-items:center;gap:8px}
    .filter-section summary::-webkit-details-marker {display:none}
    .filter-section summary::before {content:'▼';font-size:10px;transition:transform 0.2s;display:inline-block}
    .filter-section[open] summary::before {transform:rotate(-90deg)}
    .filter-section summary:hover {background:#f1f5f9}
    .filter-section-content {padding:0 12px 8px;display:flex;flex-direction:column;gap:3px}
    .filter-section.active {box-shadow:0 4px 12px rgba(37,99,235,0.15),0 2px 4px rgba(0,0,0,0.1);border-left:4px solid #2563eb}
    .filter-section.active summary {background:#f0f7ff}
    .about-map {max-width:1100px;margin:16px auto 24px;font-size:13px;color:#475569;background:#f8fafc;border-radius:12px;padding:10px 16px 14px;border:1px solid #e2e8f0}
    .about-map-title {font-weight:600;color:#0f172a;font-size:15px;margin:0 0 12px 0;text-align:center;padding-bottom:12px;border-bottom:2px solid #fff}
    .info-snippets {display:grid;grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));gap:14px;padding-top:8px}
    .snippet h2 {font-size:14px;font-weight:600;margin-bottom:4px;color:#1e293b;display:flex;align-items:center;gap:4px}
    .snippet h2 .star-icon {font-size:0.85em;line-height:1;display:inline-flex;align-items:center;margin-top:0}
    .snippet p {font-size:13px;color:#64748b;line-height:1.5}
    @media (max-width:700px) {
      .info-snippets {grid-template-columns:1fr}
      .filter-section {margin-top:3px}
      .filter-section summary {padding:10px 12px;font-size:13px}
      .filter-section-content {padding:0 12px 10px}
    }
    @media (max-width:768px) {
      html.ios-device .row-search .pill,
      html.ios-device .row-search .pill input,
      html.ios-device .row-search .pill button,
      html.ios-device .row-nearby,
      html.ios-device .row-nearby .pill,
      html.ios-device .row-nearby .pill input,
      html.ios-device .row-nearby .pill select,
      html.ios-device .row-nearby .pill button,
      html.ios-device .row-route,
      html.ios-device .row-route .pill,
      html.ios-device .row-route .pill label,
      html.ios-device .row-route .pill input,
      html.ios-device .row-route .pill select,
      html.ios-device .row-route .pill button,
      html.ios-device #radius,
      html.ios-device #units,
      html.ios-device #geocodeBtn,
      html.ios-device #clearRadius,
      html.ios-device #routeMaxDistance,
      html.ios-device #routeUnits,
      html.ios-device #findRouteBtn,
      html.ios-device #clearRoute,
      html.ios-device details.filter-section summary {
        font-size:16px !important;
      }
      html.ios-device .row-route .pill input::placeholder,
      html.ios-device .row-nearby .pill input::placeholder {
        font-size:16px !important;
      }
      html.ios-device label[for="type"],
      html.ios-device label[for="region"],
      html.ios-device label[for="state"],
      html.ios-device #type,
      html.ios-device #region,
      html.ios-device #state {
        font-size:16px !important;
      }
    }
    html.ios-device .row-search .pill label,
    html.ios-device .row-nearby .pill label,
    html.ios-device .row-route .pill label,
    html.ios-device .row-filters .pill-search label {
      font-size:16px !important;
    }
    html.ios-device .row-route .pill label {
      font-size:16px !important;
    }
    /* Force 16px inputs on iOS — MUST BE AT BOTTOM OF FILE */
    html.ios-device input,
    html.ios-device textarea,
    html.ios-device select {
      font-size:16px !important;
    }
    /* iOS: keep route inputs at 16px so Safari doesn't zoom */
    html.ios-device #routeStart,
    html.ios-device #routeEnd {
      font-size: 16px !important;
    }
    html.ios-device .row-route .pill input,
    html.ios-device .row-nearby .pill input {
      font-size:16px !important;
    }
    @media (max-width:768px) {
      /* iOS-only: fix Safari zoom issue */
      html.ios-device .row-route .pill:has(#routeStart) input,
      html.ios-device .row-route .pill:has(#routeEnd) input {
        font-size: 16px !important;
      }
    }
    /* Popup save button styling */
    .popup-save-row {
      display: flex;
      justify-content: flex-end;
      margin-top: 8px;
      padding-top: 4px;
    }
    .popup-save-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      font-weight: 500;
      font-family: Inter, sans-serif;
      color: #64748b;
      background: #f1f5f9;
      border: 1px solid #e2e8f0;
      border-radius: 9999px;
      padding: 4px 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      line-height: 1.4;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .popup-save-btn .popup-save-label {
      min-width: 40px;
      text-align: center;
      display: inline-block;
    }
    .popup-save-btn:hover {
      background: #e2e8f0;
      color: #475569;
    }
    .popup-save-btn .popup-save-icon {
      font-size: 12px;
      line-height: 1;
      color: #64748b;
    }
    .popup-save-btn.saved {
      color: #15803d;
      background: #dcfce7;
      border-color: #86efac;
    }
    .popup-save-btn.saved .popup-save-icon {
      color: #16a34a;
    }
    .popup-save-btn.saved:hover {
      background: #bbf7d0;
      color: #15803d;
    }
    /* Ensure Leaflet popups appear above saved controls */
    .leaflet-popup-pane {
      z-index: 1600 !important;
    }
    .leaflet-popup {
      z-index: 1600 !important;
    }
    /* Saved controls overlay */
    .saved-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #E5E7EB;
      border-radius: 9999px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      height: 38px;
      padding: 0 6px;
      z-index: 1500;
      font-family: Inter, sans-serif;
      font-weight: 500;
      color: #374151;
      font-size: 12px;
      pointer-events: auto;
      gap: 4px;
    }
    .saved-list-section,
    .saved-only-section {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 0 4px;
      cursor: pointer;
      transition: opacity 0.2s, color 0.2s;
      user-select: none;
    }
    .saved-list-section {
      color: #1d4ed8;
      text-decoration: none;
      gap: 6px;
    }
    .saved-pill {
      display: inline-flex;
      align-items: center;
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      border-radius: 9999px;
      padding: 3px 10px;
      box-shadow: 0 6px 16px rgba(37, 99, 235, 0.12);
      transition: background 0.2s, border-color 0.2s, color 0.2s;
      font-weight: 600;
    }
    .saved-list-section:hover .saved-pill {
      color: #1e40af;
      background: #e0e7ff;
      border-color: #a5b4fc;
    }
    .saved-list-section:focus-visible .saved-pill {
      outline: 2px solid #1d4ed8;
      outline-offset: 2px;
    }
    .saved-icon {
      width: 22px;
      height: 22px;
      flex-shrink: 0;
    }
    .saved-text {
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    }
    .saved-controls-divider {
      width: 1px;
      height: 20px;
      background: #E5E7EB;
      margin: 0 2px;
      flex-shrink: 0;
    }
    .saved-toggle {
      flex-shrink: 0;
      margin-right: 3px;
    }
    .saved-toggle-track {
      width: 30px;
      height: 16px;
      background: #D1D5DB;
      border-radius: 9999px;
      position: relative;
      transition: background-color 0.2s;
      cursor: pointer;
    }
    .saved-toggle-thumb {
      width: 12px;
      height: 12px;
      background: white;
      border-radius: 50%;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    .saved-controls.saved-only-active .saved-toggle-track {
      background: #64D85B;
    }
    .saved-controls.saved-only-active .saved-toggle-thumb {
      transform: translateX(12px);
    }
    @media (max-width: 1024px) {
      .saved-controls {
        padding: 0 5px;
      }
      .saved-list-section,
      .saved-only-section {
        padding: 0 3px;
        gap: 4px;
      }
      .saved-pill {
        padding: 3px 9px;
      }
      .saved-icon {
        width: 20px;
        height: 20px;
      }
      .saved-toggle-track {
        width: 28px;
        height: 16px;
      }
      .saved-toggle-thumb {
        width: 12px;
        height: 12px;
      }
      .saved-controls.saved-only-active .saved-toggle-thumb {
        transform: translateX(12px);
      }
    }
    @media (max-width: 700px) {
      .saved-controls {
        height: 36px;
        top: 10px;
        right: 10px;
      }
      .saved-toggle-track {
        width: 24px;
        height: 14px;
      }
      .saved-toggle-thumb {
        width: 10px;
        height: 10px;
        top: 2px;
        left: 2px;
      }
      .saved-controls.saved-only-active .saved-toggle-thumb {
        transform: translateX(10px);
      }
    }
    /* Saved Colleges Overlay */
    .saved-colleges-overlay {
      position: absolute;
      top: 0;
      right: 0;
      width: 400px;
      height: 100%;
      background: linear-gradient(180deg,#ffffff 0%,#fefefe 120px,#f3f6ff 100%);
      box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
      z-index: 3000;
      display: none;
      flex-direction: column;
      font-family: Inter, sans-serif;
    }
    .saved-colleges-overlay.active {
      display: flex;
    }
    .saved-overlay-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px;
      border-bottom: 1px solid #E5E7EB;
      flex-shrink: 0;
      background: #f8fafc;
    }
    .saved-overlay-title-section {
      flex: 1;
    }
    .saved-overlay-title {
      font-size: 20px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 4px 0;
    }
    .saved-overlay-subtitle {
      font-size: 13px;
      color: #64748b;
      margin: 0;
    }
    .saved-overlay-close {
      background: none;
      border: none;
      font-size: 28px;
      color: #94a3b8;
      cursor: pointer;
      line-height: 1;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
      flex-shrink: 0;
    }
    .saved-overlay-close:hover {
      color: #64748b;
    }
    .saved-overlay-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    .saved-overlay-section {
      margin-bottom: 32px;
    }
    .saved-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .saved-section-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin: 0 0 12px 0;
    }
    .saved-section-header .saved-section-title {
      margin: 0;
      flex: 1;
    }
    .saved-search-wrapper {
      position: relative;
    }
    .saved-search-wrapper::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: -12px;
      height: 20px;
      background: linear-gradient(180deg, rgba(255,255,255,0), rgba(15,23,42,0.12));
      pointer-events: none;
      z-index: 2;
      border-bottom-left-radius: 12px;
      border-bottom-right-radius: 12px;
    }
    .saved-search-input {
      width: 100%;
      padding: 12px 16px 12px 44px;
      border: 2px solid #E5E7EB;
      border-radius: 12px;
      font-size: 14px;
      font-family: Inter, sans-serif;
      color: #0f172a;
      background: #fff;
      box-sizing: border-box;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.06);
    }
    .saved-search-wrapper::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: -8px;
      height: 12px;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(15,23,42,0.08), rgba(15,23,42,0));
      opacity: 0.8;
    }
    .saved-search-input:hover {
      border-color: #CBD5E1;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
    }
    .saved-search-input:focus {
      outline: none;
      border-color: #2563eb;
      background: #fff;
      box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.1), 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
      transform: translateY(-1px);
    }
    .saved-search-input::placeholder {
      color: #94a3b8;
    }
    .saved-search-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      color: #94a3b8;
      pointer-events: none;
      z-index: 1;
    }
    .saved-search-results {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      max-height: 300px;
      overflow-y: auto;
      padding-bottom: 12px;
      z-index: 10;
      display: none;
    }
    .saved-search-results.active {
      display: block;
    }
    .saved-search-result-item {
      padding: 12px;
      border-bottom: 1px solid #F3F4F6;
      cursor: pointer;
      transition: background 0.15s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .saved-search-result-item:hover {
      background: #F9FAFB;
    }
    .saved-search-result-item:last-child {
      border-bottom: none;
    }
    .saved-search-result-info {
      flex: 1;
      min-width: 0;
    }
    .saved-search-result-name {
      font-weight: 600;
      font-size: 13px;
      color: #0f172a;
      margin-bottom: 2px;
    }
    .saved-search-result-details {
      font-size: 12px;
      color: #64748b;
    }
    .saved-search-result-save-btn {
      flex-shrink: 0;
      margin-left: 12px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 9999px;
      border: 1px solid #E5E7EB;
      background: #f1f5f9;
      color: #64748b;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
      white-space: nowrap;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .saved-search-result-save-btn span {
      display: inline-block;
      width: 12px;
      text-align: center;
      line-height: 1;
    }
    .saved-search-result-save-btn:hover {
      background: #e2e8f0;
      color: #475569;
    }
    .saved-search-result-save-btn.saved {
      background: #dcfce7;
      border-color: #86efac;
      color: #15803d;
    }
    .saved-search-result-save-btn.saved:hover {
      background: #bbf7d0;
    }
    .saved-colleges-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .saved-college-item {
      padding: 12px;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      background: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: box-shadow 0.2s, opacity 0.25s ease, transform 0.25s ease, max-height 0.25s ease, margin 0.25s ease, padding 0.25s ease;
      max-height: 200px;
    }
    .saved-college-item:hover {
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    .saved-college-item.removing {
      opacity: 0;
      transform: translateX(12px);
      max-height: 0;
      margin-top: 0;
      margin-bottom: 0;
      padding-top: 0;
      padding-bottom: 0;
    }
    .saved-college-info {
      flex: 1;
      min-width: 0;
    }
    .saved-college-name {
      font-weight: 600;
      font-size: 14px;
      color: #0f172a;
      margin-bottom: 2px;
    }
    .saved-college-details {
      font-size: 12px;
      color: #64748b;
    }
    .saved-college-unsave-btn {
      flex-shrink: 0;
      margin-left: 12px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 9999px;
      border: 1px solid #86efac;
      background: #dcfce7;
      color: #15803d;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
      white-space: nowrap;
      width: 70px;
      justify-content: center;
      box-sizing: border-box;
    }
    .saved-college-unsave-btn:hover {
      background: #bbf7d0;
    }
    .saved-empty-state {
      padding: 40px 20px;
      text-align: center;
      color: #64748b;
    }
    .saved-empty-state-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 8px;
    }
    .saved-empty-state-text {
      font-size: 13px;
      line-height: 1.5;
    }
    .unsave-all-btn {
      padding: 6px 12px;
      font-size: 14px;
      font-weight: 500;
      color: #dc2626;
      background: transparent;
      border: 1px solid #E5E7EB;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .unsave-all-btn:hover {
      background: #FEF2F2;
      border-color: #FCA5A5;
    }
    .saved-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 4000;
      display: none;
      align-items: center;
      justify-content: center;
    }
    .saved-modal-overlay.active {
      display: flex;
    }
    .saved-modal {
      background: #fff;
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: calc(100% - 40px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }
    .saved-modal-title {
      font-size: 16px;
      font-weight: 600;
      color: #0f172a;
      margin: 0 0 20px 0;
    }
    .saved-modal-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    .saved-modal-btn {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid #E5E7EB;
    }
    .saved-modal-cancel {
      background: #fff;
      color: #374151;
    }
    .saved-modal-cancel:hover {
      background: #F9FAFB;
    }
    .saved-modal-confirm {
      background: #dc2626;
      color: #fff;
      border-color: #dc2626;
    }
    .saved-modal-confirm:hover {
      background: #b91c1c;
      border-color: #b91c1c;
    }
    @media (max-width: 700px) {
      .saved-colleges-overlay {
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      .saved-modal {
        margin: 20px;
      }
    }
  </style>
</head>
<body>
<div class="main-container">
<header class="app-header">
    <div class="header-logo-tagline">
  <!-- Logo optimization: Ideal source image size ≈ 280×70px (4:1 ratio) for header usage at 70px height on desktop, 56px on mobile -->
  <!-- Using width/height attributes for layout stability and to prevent layout shift during load -->
  <img src="us-college-map-logo.png" alt="U.S. College Map interactive tool for exploring colleges by type, region, and location" class="site-logo" width="280" height="70">
      <h1 class="sr-only">U.S. College Map — Find Colleges Near You, Along Your Route, and Save Your List</h1>
      <p class="tagline">Planning campus visits? U.S. College Map helps you explore schools by type, region, or name — and easily find colleges near any location or along any trip.</p>
    </div>
</header>

  <main>
  <nav class="container controls" aria-label="College search filters">
    <div class="row row-filters">
      <div class="pill"><label for="type">Type</label><select id="type"><option value="">All college types</option></select></div>
      <div class="pill"><label for="region">Region</label><select id="region"><option value="">All regions</option></select></div>
      <div class="pill"><label for="state">State</label><select id="state" autocomplete="one-time-code" data-prevent-autofill="true"><option value="">All states</option></select></div>
      <!-- College name search temporarily hidden - functionality preserved for future use -->
      <div class="pill pill-search" style="display: none !important;"><label for="search">Search</label><input id="search" placeholder="Enter college name" /></div>
  </div>
    <div class="row row-search" style="display: none !important;">
      <div class="pill"><label for="search-mobile">Search</label><input id="search-mobile" placeholder="Enter college name" /></div>
  </div>
    
    <details class="filter-section">
      <summary>Find Colleges Nearby</summary>
      <div class="filter-section-content">
        <div class="row row-nearby">
          <div class="pill address-autocomplete"><label for="address">Address</label><input id="address" placeholder="Enter a location or home address" autocomplete="new-password" name="search-address" readonly data-autofill-guard="true" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="none" aria-autocomplete="list" aria-expanded="false" aria-controls="addressSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="addressSuggestions" role="listbox" aria-label="Address suggestions"></div></div>
    <div class="pill"><label for="radius">Radius</label><input id="radius" type="number" min="0" step="10" value="30" style="width:90px"><select id="units"><option value="mi" selected>mi</option><option value="km">km</option></select><button id="geocodeBtn">Locate</button><button id="clearRadius" style="background:transparent;color:#0f172a;border:1px solid #e2e8f0;">Clear</button></div>
</div>
</div>
    </details>
    
    <details class="filter-section">
      <summary>Find Colleges Along a Route</summary>
      <div class="filter-section-content">
        <div class="row row-route">
          <div class="pill address-autocomplete"><label for="routeStart">From</label><input id="routeStart" placeholder="Enter starting address" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-autocomplete="list" aria-expanded="false" aria-controls="routeStartSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="routeStartSuggestions" role="listbox" aria-label="From address suggestions"></div></div>
          <div class="pill address-autocomplete"><label for="routeEnd">To</label><input id="routeEnd" placeholder="Enter destination address" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-autocomplete="list" aria-expanded="false" aria-controls="routeEndSuggestions" aria-haspopup="listbox" role="combobox" /><div class="autocomplete-suggestions" id="routeEndSuggestions" role="listbox" aria-label="To address suggestions"></div></div>
          <div class="pill"><label for="routeMaxDistance">Within</label><input id="routeMaxDistance" type="number" min="0" step="10" value="30" style="width:90px"><select id="routeUnits"><option value="mi" selected>mi</option><option value="km">km</option></select><button id="findRouteBtn">Explore</button><button id="clearRoute" style="background:transparent;color:#0f172a;border:1px solid #e2e8f0;">Clear</button></div>
        </div>
      </div>
    </details>
  </nav>
  <div class="route-hint-bubble" id="route-hint-bubble">
      <div class="route-hint-bubble-content">
        <span class="route-hint-bubble-text">Tap to explore</span>
      </div>
    </div>
  <section id="map" aria-label="Interactive college map">
    <!-- Smart map hint popups -->
    <div class="map-hint-bubble" id="hint-too-many-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">🎯</span>
        <div class="map-hint-bubble-title">Too many colleges shown?</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('tooMany')">×</button>
      </div>
      <div class="map-hint-bubble-body">Filter by Type above or save your favorite schools to your list to focus your map.</div>
    </div>
    <div class="map-hint-bubble" id="hint-no-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">🔍</span>
        <div class="map-hint-bubble-title">No colleges found?</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('noResults')">×</button>
      </div>
      <div class="map-hint-bubble-body">Your current filters may be too narrow, or none of your saved colleges fall within this location or route.</div>
    </div>
    <!-- No saved colleges notice - appears when Saved Only is toggled on with zero saved colleges -->
    <div class="map-hint-bubble" id="hint-no-saved-colleges" role="alert">
      <div class="map-hint-bubble-header">
        <span class="map-hint-bubble-icon">📌</span>
        <div class="map-hint-bubble-title">No saved colleges yet.</div>
        <button class="map-hint-bubble-close" aria-label="Dismiss notice" onclick="dismissMapHint('noSavedColleges')">×</button>
      </div>
      <div class="map-hint-bubble-body">Go to "My Saved List" or tap a college on the map and press "Save" to add a school.</div>
    </div>
    <!-- Helper tip bubble - appears once per session -->
    <div class="map-tip-bubble" id="map-tip-bubble" role="alert">
      <div class="map-tip-bubble-content">
        <span class="map-tip-bubble-icon">💡</span>
        <span class="map-tip-bubble-text">Tap a blue dot on the map to see college details or save to your list.</span>
        <button class="map-tip-bubble-close" aria-label="Dismiss tip" onclick="dismissMapTip()">×</button>
      </div>
    </div>
    <div class="legend" id="legend">Found <span id="count">0</span> schools</div>
    <!-- Saved controls overlay -->
    <div id="saved-controls" class="saved-controls">
      <div class="saved-list-section" onclick="openSavedListPanel()" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();openSavedListPanel();}" role="button" tabindex="0">
        <svg class="saved-icon" width="22" height="22" viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path fill="#64D85B" d="M128 0C74 0 32 42 32 96C32 166 128 256 128 256C128 256 224 166 224 96C224 42 182 0 128 0Z"/>
          <path fill="#FFFFFF" d="M128 32L147 86H200L159 118L175 170L128 139L81 170L97 118L56 86H109L128 32Z"/>
        </svg>
        <span class="saved-pill"><span class="saved-text">My Saved List</span></span>
      </div>
      <div class="saved-controls-divider"></div>
      <div class="saved-only-section" onclick="toggleSavedOnly()">
        <div class="saved-toggle" id="saved-toggle">
          <div class="saved-toggle-track">
            <div class="saved-toggle-thumb"></div>
          </div>
        </div>
        <span class="saved-text">Map Saved Only</span>
      </div>
    </div>
    <!-- Saved Colleges Overlay -->
    <div id="saved-colleges-overlay" class="saved-colleges-overlay">
      <div class="saved-overlay-header">
        <div class="saved-overlay-title-section">
          <h2 class="saved-overlay-title">My Saved Colleges</h2>
        </div>
        <button class="saved-overlay-close" onclick="closeSavedListPanel()" aria-label="Close saved colleges panel">×</button>
      </div>
      <div class="saved-overlay-content">
        <!-- Search & Add Section -->
        <div class="saved-overlay-section">
          <h3 class="saved-section-title">Add a college to my saved list</h3>
          <div class="saved-search-wrapper">
            <svg class="saved-search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
            </svg>
            <input 
              type="text" 
              id="saved-search-input" 
              class="saved-search-input" 
              placeholder="Search by college name…"
              autocomplete="off"
            />
            <div id="saved-search-results" class="saved-search-results"></div>
          </div>
        </div>
        <!-- Saved List Section -->
        <div class="saved-overlay-section">
          <div class="saved-section-header">
            <h3 class="saved-section-title" id="saved-overlay-count">0 Colleges Saved</h3>
            <button id="unsave-all-btn" class="unsave-all-btn" onclick="confirmUnsaveAll()" style="display: none;">Unsave all</button>
          </div>
          <div id="saved-colleges-list" class="saved-colleges-list">
            <!-- Will be populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>
    <!-- Unsave All Confirmation Modal -->
    <div id="unsave-all-modal" class="saved-modal-overlay">
      <div class="saved-modal">
        <h3 class="saved-modal-title">Remove all saved colleges?</h3>
        <div class="saved-modal-actions">
          <button class="saved-modal-btn saved-modal-cancel" onclick="closeUnsaveAllModal()">Cancel</button>
          <button class="saved-modal-btn saved-modal-confirm" onclick="unsaveAllColleges()">Unsave all</button>
        </div>
      </div>
    </div>
  </section>
<div aria-label="College map powered by OpenStreetMap data" class="sr-only"></div>
  <div class="loading" id="loading">Loading colleges data...</div>
  <div class="error" id="error"></div>
  
  <section class="about-map">
    <h2 class="about-map-title">About This Map</h2>
    <div class="info-snippets" aria-label="College visit planning resources">
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Explore and find colleges by region</h2>
        <p>When you're just starting out, it helps to see the big picture. U.S. College Map lets you explore every college across the country — by state, region, or school type — so you can spot patterns, compare areas, and learn what kinds of campuses appeal to you. Tap any school to check out basic details and start building a sense of what's out there.</p>
      </div>
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Visit colleges near you or along your route</h2>
        <p>Heading out for a family trip, tournament, or vacation? Enter any address or route to see colleges nearby or along the way. You might discover schools you've never heard of but end up loving. This makes campus visits easy, low-stress, and part of the travel you're already doing — no extra planning required.</p>
      </div>
      <div class="snippet">
        <h2><span class="star-icon">⭐</span> Save colleges and plan focused visit trips</h2>
        <p>After exploring and visiting a few campuses, save your favorite schools to your list. Then switch to Saved-Only mode to see just those colleges on the map. It's perfect for planning intentional visit trips to groups of schools that are close together — whether you're flying out for a weekend or mapping out a bigger college-visit road trip.</p>
      </div>
    </div>
  </section>
  </main>
</div>
<footer class="site-footer">© 2025 U.S. College Map</footer>

<script>
const localMode = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
const DATA_URL = localMode ? 'colleges_usa_2024.csv' : 'https://uscollegemap.org/colleges_usa_2024.csv';
const COLLEGE_CACHE_KEY = 'ucm_colleges_csv_v1';
const ROUTE_HINT_KEY = 'ucm_routeExploreHint';

// Cache DOM references for performance
const elements = {
  state: document.getElementById('state'),
  region: document.getElementById('region'),
  type: document.getElementById('type'),
  search: document.getElementById('search'),
  address: document.getElementById('address'),
  radius: document.getElementById('radius'),
  units: document.getElementById('units'),
  count: document.getElementById('count'),
  loading: document.getElementById('loading'),
  error: document.getElementById('error'),
  geocodeBtn: document.getElementById('geocodeBtn'),
  clearRadius: document.getElementById('clearRadius'),
  addressSuggestions: document.getElementById('addressSuggestions'),
  routeStart: document.getElementById('routeStart'),
  routeEnd: document.getElementById('routeEnd'),
  routeMaxDistance: document.getElementById('routeMaxDistance'),
  routeUnits: document.getElementById('routeUnits'),
  clearRoute: document.getElementById('clearRoute'),
  routeStartSuggestions: document.getElementById('routeStartSuggestions'),
  routeEndSuggestions: document.getElementById('routeEndSuggestions'),
  findRouteBtn: document.getElementById('findRouteBtn')
};

function guardIOSAutofill(input) {
  if (!input || input.dataset.iosAutofillGuarded === 'true') {
    return;
  }
  input.dataset.iosAutofillGuarded = 'true';
  const originalInputMode = input.getAttribute('inputmode') || '';
  if (originalInputMode) {
    input.dataset.originalInputMode = originalInputMode;
  }
  // Set readonly and inputmode immediately to prevent autofill
  input.setAttribute('readonly', 'readonly');
  input.setAttribute('inputmode', 'none');
  // Use autocomplete values that iOS respects better
  if (!input.getAttribute('autocomplete') || input.getAttribute('autocomplete') === 'off') {
    input.setAttribute('autocomplete', 'new-password');
  }
  input.setAttribute('data-lpignore', 'true'); // LastPass ignore
  input.setAttribute('data-form-type', 'other'); // Prevent form autofill
  input.dataset.iosGuardState = 'pending';
  
  const releaseGuard = (event) => {
    if (input.dataset.iosGuardState !== 'pending') {
      return;
    }
    input.dataset.iosGuardState = 'released';
    if (event && typeof event.preventDefault === 'function') {
      event.preventDefault();
    }
    // Remove readonly immediately and synchronously
    input.removeAttribute('readonly');
    const restoredMode = input.dataset.originalInputMode || 'search';
    input.setAttribute('inputmode', restoredMode);
    // Force a reflow to ensure readonly is removed
    void input.offsetHeight;
    // Small delay to ensure readonly is fully removed before focusing
    setTimeout(() => {
      requestAnimationFrame(() => {
        if (document.activeElement !== input) {
          input.focus({ preventScroll: true });
        }
        const len = input.value.length;
        if (typeof input.setSelectionRange === 'function') {
          input.setSelectionRange(len, len);
        }
      });
    }, 20);
  };
  
  const touchUnlock = (event) => {
    input.removeEventListener('touchstart', touchUnlock);
    input.removeEventListener('pointerdown', pointerUnlock);
    input.removeEventListener('focus', focusUnlock);
    input.removeEventListener('click', clickUnlock);
    releaseGuard(event);
  };
  
  const pointerUnlock = (event) => {
    if (event.pointerType && event.pointerType !== 'touch') {
      return;
    }
    input.removeEventListener('touchstart', touchUnlock);
    input.removeEventListener('pointerdown', pointerUnlock);
    input.removeEventListener('focus', focusUnlock);
    input.removeEventListener('click', clickUnlock);
    releaseGuard(event);
  };
  
  const focusUnlock = () => {
    input.removeEventListener('touchstart', touchUnlock);
    input.removeEventListener('pointerdown', pointerUnlock);
    input.removeEventListener('focus', focusUnlock);
    input.removeEventListener('click', clickUnlock);
    releaseGuard();
  };
  
  const clickUnlock = (event) => {
    input.removeEventListener('touchstart', touchUnlock);
    input.removeEventListener('pointerdown', pointerUnlock);
    input.removeEventListener('focus', focusUnlock);
    input.removeEventListener('click', clickUnlock);
    releaseGuard(event);
  };
  
  input.addEventListener('touchstart', touchUnlock, { once: true, passive: false });
  input.addEventListener('pointerdown', pointerUnlock, { once: true });
  input.addEventListener('focus', focusUnlock, { once: true });
  input.addEventListener('click', clickUnlock, { once: true });
}

// Apply autofill guard immediately if elements exist, or wait for DOMContentLoaded
function applyAutofillGuards() {
  const ua = navigator.userAgent || '';
  const isIOS =
    /iPad|iPhone|iPod/.test(ua) ||
    (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  if (isIOS) {
    document.documentElement.classList.add('ios-device');
  }
  
  // Apply guards to all address inputs on all devices to prevent autofill
  const inputsToGuard = [elements.address, elements.routeStart, elements.routeEnd].filter(Boolean);
  inputsToGuard.forEach(guardIOSAutofill);
}

// Try to apply guards immediately if elements are available
if (elements.address || elements.routeStart || elements.routeEnd) {
  applyAutofillGuards();
}

document.addEventListener('DOMContentLoaded', () => {
  // Initialize saved search
  initSavedSearch();
  
  // Apply autofill guards again in case elements weren't ready before
  applyAutofillGuards();
  
  const ua = navigator.userAgent || '';
  const isIOS =
    /iPad|iPhone|iPod/.test(ua) ||
    (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  if (isIOS) {
    const isSmallScreen = window.innerWidth <= 768;
    if (isSmallScreen && elements.type) {
      const defaultTypeOption = elements.type.querySelector('option[value=""]');
      if (defaultTypeOption) {
        defaultTypeOption.textContent = 'All types';
      }
    }
  }
  if (window.innerWidth <= 700) {
    addHeaderInteractionListeners();
  }
  setupRouteHint();
});

if (elements.addressSuggestions) elements.addressSuggestions.dataset.field = 'address';
if (elements.routeStartSuggestions) elements.routeStartSuggestions.dataset.field = 'routeStart';
if (elements.routeEndSuggestions) elements.routeEndSuggestions.dataset.field = 'routeEnd';

let addressAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

// Route autocomplete objects
let routeStartAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

let routeEndAutocomplete = {
  suggestions: [],
  selectedIndex: -1,
  isOpen: false,
  abortController: null,
  isSelecting: false
};

let mobileHeaderCollapsed = false;
let headerListenersAttached = false;
const headerInteractionEvents = ['pointerdown','touchstart','keydown'];

function getHeaderElement() {
  return document.querySelector('.app-header');
}

function collapseMobileHeader() {
  const header = getHeaderElement();
  if (!header || window.innerWidth > 700 || mobileHeaderCollapsed) return;
  header.classList.add('collapsed');
  mobileHeaderCollapsed = true;
  removeHeaderInteractionListeners();
}

function handleHeaderFirstInteraction(event) {
  if (mobileHeaderCollapsed || window.innerWidth > 700) return;
  const header = getHeaderElement();
  if (!header) return;
  if (header.contains(event.target)) return;
  collapseMobileHeader();
}

function addHeaderInteractionListeners() {
  if (headerListenersAttached || window.innerWidth > 700 || mobileHeaderCollapsed) return;
  headerInteractionEvents.forEach(evt => document.addEventListener(evt, handleHeaderFirstInteraction, true));
  headerListenersAttached = true;
}

function removeHeaderInteractionListeners() {
  if (!headerListenersAttached) return;
  headerInteractionEvents.forEach(evt => document.removeEventListener(evt, handleHeaderFirstInteraction, true));
  headerListenersAttached = false;
}

function resetHeaderForDesktop() {
  const header = getHeaderElement();
  if (header) header.classList.remove('collapsed');
  mobileHeaderCollapsed = false;
  removeHeaderInteractionListeners();
  if (window.innerWidth <= 700) {
    addHeaderInteractionListeners();
  }
}

const americasBounds = L.latLngBounds([[-60,-180],[85,-30]]);
const US_MAINLAND_VIEW = L.latLngBounds([[18,-130],[55,-60]]);
const INITIAL_DESKTOP_VIEW = { center: { lat: 39.5, lng: -98.35 }, zoom: 4 };
const INITIAL_MOBILE_VIEW = { center: { lat: 39.5, lng: -98.35 }, zoom: 3.5 };
function getInitialNearbyView() {
  return window.innerWidth <= 700 ? INITIAL_MOBILE_VIEW : INITIAL_DESKTOP_VIEW;
}
const mapViewState = {
  nearby: { ...getInitialNearbyView() },
  route: null
};
const map = L.map('map',{maxBounds:americasBounds,maxBoundsViscosity:1}).setView(
  [mapViewState.nearby.center.lat, mapViewState.nearby.center.lng],
  mapViewState.nearby.zoom
);
map.whenReady(() => {
  setTimeout(() => {
    map.invalidateSize();
    if (!home && !lastNearbyFilters && mapViewState.nearby) {
      map.setView([mapViewState.nearby.center.lat, mapViewState.nearby.center.lng], mapViewState.nearby.zoom);
      captureMapView('nearby');
    }
  }, 150);
});
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap contributors',attributionControl:true}).addTo(map);

const mapInteractionLock = {
  locked: false,
  state: {}
};

function freezeMapInteractions() {
  if (!map || mapInteractionLock.locked) return;
  const state = mapInteractionLock.state = {};
  if (map.dragging) {
    state.dragging = map.dragging.enabled();
    map.dragging.disable();
  }
  if (map.scrollWheelZoom) {
    state.scrollWheelZoom = map.scrollWheelZoom.enabled();
    map.scrollWheelZoom.disable();
  }
  if (map.doubleClickZoom) {
    state.doubleClickZoom = map.doubleClickZoom.enabled();
    map.doubleClickZoom.disable();
  }
  if (map.boxZoom) {
    state.boxZoom = map.boxZoom.enabled();
    map.boxZoom.disable();
  }
  if (map.keyboard) {
    state.keyboard = map.keyboard.enabled();
    map.keyboard.disable();
  }
  if (map.touchZoom) {
    state.touchZoom = map.touchZoom.enabled();
    map.touchZoom.disable();
  }
  if (map.tap && typeof map.tap.enabled === 'function') {
    state.tap = map.tap.enabled();
    map.tap.disable();
  }
  mapInteractionLock.locked = true;
}

function resumeMapInteractions() {
  if (!map || !mapInteractionLock.locked) return;
  const state = mapInteractionLock.state || {};
  if (state.dragging && map.dragging) map.dragging.enable();
  if (state.scrollWheelZoom && map.scrollWheelZoom) map.scrollWheelZoom.enable();
  if (state.doubleClickZoom && map.doubleClickZoom) map.doubleClickZoom.enable();
  if (state.boxZoom && map.boxZoom) map.boxZoom.enable();
  if (state.keyboard && map.keyboard) map.keyboard.enable();
  if (state.touchZoom && map.touchZoom) map.touchZoom.enable();
  if (state.tap && map.tap && typeof map.tap.enable === 'function') map.tap.enable();
  mapInteractionLock.locked = false;
  mapInteractionLock.state = {};
}

function clampBoundsToMainland(bounds) {
  if (!bounds || !bounds.isValid()) return US_MAINLAND_VIEW;
  const south = bounds.getSouth();
  const west = bounds.getWest();
  const north = bounds.getNorth();
  const east = bounds.getEast();
  const needsClamp =
    south < US_MAINLAND_VIEW.getSouth() ||
    west < US_MAINLAND_VIEW.getWest() ||
    north > US_MAINLAND_VIEW.getNorth() ||
    east > US_MAINLAND_VIEW.getEast();
  if (!needsClamp) {
    return bounds;
  }
  const clampedSouth = Math.max(south, US_MAINLAND_VIEW.getSouth());
  const clampedWest = Math.max(west, US_MAINLAND_VIEW.getWest());
  const clampedNorth = Math.min(north, US_MAINLAND_VIEW.getNorth());
  const clampedEast = Math.min(east, US_MAINLAND_VIEW.getEast());
  const clamped = L.latLngBounds(
    L.latLng(clampedSouth, clampedWest),
    L.latLng(clampedNorth, clampedEast)
  );
  return clamped.isValid() ? clamped : US_MAINLAND_VIEW;
}

const markersLayer = L.layerGroup().addTo(map);

const homeLayer = L.layerGroup().addTo(map);
const radiusLayer = L.layerGroup().addTo(map);
const routeLayer = L.layerGroup().addTo(map);

// Store references to route polylines for dynamic styling
let routeOutlinePolyline = null; // Navy outline
let routeMainPolyline = null; // Royal blue main line

// Device detection for dynamic marker sizing
function detectDeviceType() {
  const width = window.innerWidth;
  const ua = navigator.userAgent || '';
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  
  // iPad detection (including iPad Pro)
  const isIPad = /iPad/.test(ua) || (ua.includes('Mac') && navigator.maxTouchPoints > 1);
  
  // Mobile phones (small screens with touch)
  if (isTouchDevice && width <= 768 && !isIPad) {
    return 'mobile';
  }
  
  // Tablets/iPad (medium screens with touch)
  if (isTouchDevice && (width <= 1024 || isIPad)) {
    return 'tablet';
  }
  
  // Desktop (everything else)
  return 'desktop';
}

// Calculate marker radius based on zoom level and device type
function calculateMarkerRadius(zoom, deviceType) {
  if (deviceType === 'desktop') {
    return 5; // Always radius 5 for desktop
  }
  
  if (deviceType === 'mobile') {
    // Mobile: Low zoom (0-5) → 4-5, Medium (6-9) → 6-8, High (10+) → 9-10, cap at 10
    if (zoom <= 5) {
      return 4 + (zoom / 5); // 4 to 5 (linear interpolation)
    } else if (zoom <= 9) {
      return 6 + ((zoom - 5) / 4) * 2; // 6 to 8 (linear interpolation)
    } else {
      // High zoom: 9 to 10 (capped), reaching 10 around zoom 11-12
      return Math.min(9 + (zoom - 9) * 0.5, 10); // 9 to 10 (capped at 10)
    }
  }
  
  if (deviceType === 'tablet') {
    // iPad: Same sizing as mobile for better visibility - Low zoom (0-5) → 4-5, Medium (6-9) → 6-8, High (10+) → 9-10, cap at 10
    if (zoom <= 5) {
      return 4 + (zoom / 5); // 4 to 5 (linear interpolation)
    } else if (zoom <= 9) {
      return 6 + ((zoom - 5) / 4) * 2; // 6 to 8 (linear interpolation)
    } else {
      // High zoom: 9 to 10 (capped), reaching 10 around zoom 11-12
      return Math.min(9 + (zoom - 9) * 0.5, 10); // 9 to 10 (capped at 10)
    }
  }
  
  return 5; // Fallback to desktop size
}

// Calculate route line weights and opacity based on zoom level
// Low zoom: thinner (2-3), Medium: default (4), High: slightly thicker (4-5)
// Opacity: lighter at low zoom, stronger at high zoom
function calculateRouteLineWeights(zoom) {
  let mainOpacity, outlineOpacity;
  
  // Opacity mapping: lighter at low zoom, stronger at high zoom
  if (zoom <= 5) {
    mainOpacity = 0.6;
    outlineOpacity = 0.7; // Slightly higher for ribbon effect
  } else if (zoom <= 7) {
    mainOpacity = 0.75;
    outlineOpacity = 0.85; // Slightly higher for ribbon effect
  } else if (zoom <= 10) {
    mainOpacity = 0.9;
    outlineOpacity = 0.95; // Slightly higher for ribbon effect
  } else {
    mainOpacity = 1.0;
    outlineOpacity = 1.0; // Full opacity at high zoom
  }
  
  // Weight mapping: thinner at low zoom, thicker at high zoom
  if (zoom <= 5) {
    // Low zoom (far out): thinner and lighter
    return {
      outlineWeight: 3,
      mainWeight: 2,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  } else if (zoom <= 9) {
    // Medium zoom (normal trip-planning view): default
    return {
      outlineWeight: 5,
      mainWeight: 4,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  } else {
    // High zoom (zoomed in close): slightly thicker but subtle
    return {
      outlineWeight: 6,
      mainWeight: 5,
      outlineOpacity: outlineOpacity,
      mainOpacity: mainOpacity
    };
  }
}

// Get current marker radius based on current zoom and device
function getCurrentMarkerRadius() {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  return calculateMarkerRadius(zoom, deviceType);
}

// Calculate saved icon size based on zoom level and device type
// Maintains desktop ratio (2.4×) to blue dot diameter, with specific caps for mobile/iPad
function calculateSavedIconSize(zoom, deviceType) {
  if (deviceType === 'desktop') {
    return { width: 24, height: 30 }; // Desktop: unchanged
  }
  
  // Get current blue dot radius to maintain proportional ratio
  const blueDotRadius = calculateMarkerRadius(zoom, deviceType);
  const blueDotDiameter = blueDotRadius * 2;
  
  // Calculate proportional size using desktop ratio (24px icon / 10px blue dot diameter = 2.4×)
  // This ensures saved icons are proportionally the same size relative to blue dots on all devices
  let targetWidth = blueDotDiameter * 2.4;
  
  if (deviceType === 'mobile') {
    // Mobile: scale from ~20px (low zoom) to max 28px (high zoom cap)
    const minWidth = 20;
    const maxWidth = 28;
    targetWidth = Math.max(minWidth, Math.min(targetWidth, maxWidth));
  } else if (deviceType === 'tablet') {
    // iPad: same sizing as mobile - scale from ~20px (low zoom) to max 28px (high zoom cap)
    const minWidth = 20;
    const maxWidth = 28;
    targetWidth = Math.max(minWidth, Math.min(targetWidth, maxWidth));
  }
  
  // Maintain aspect ratio (24:30 = 0.8)
  const height = targetWidth * (30 / 24);
  
  return { width: Math.round(targetWidth), height: Math.round(height) };
}

// Get current saved icon size based on current zoom and device
function getCurrentSavedIconSize() {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  return calculateSavedIconSize(zoom, deviceType);
}

// Create a green saved icon with dynamic sizing
function createGreenSavedIcon(size) {
  const { width, height } = size || getCurrentSavedIconSize();
  return L.icon({
    iconUrl: 'data:image/svg+xml;base64,' + btoa(greenSavedPinSvg),
    iconSize: [width, height],
    iconAnchor: [width / 2, height],
    popupAnchor: [0, -height]
  });
}
const ROUTE_START_PIN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><circle cx="9" cy="9" r="4" fill="#ffffff" stroke="#111827" stroke-width="2"/></svg>';
const ROUTE_END_PIN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
const ROUTE_START_PIN_ICON = 'data:image/svg+xml;base64,' + btoa(ROUTE_START_PIN_SVG);
const ROUTE_END_PIN_ICON = 'data:image/svg+xml;base64,' + btoa(ROUTE_END_PIN_SVG);
let colleges = [], home = null;
function captureMapView(mode) {
  if (!mode) return;
  const center = map.getCenter();
  mapViewState[mode] = {
    center: { lat: center.lat, lng: center.lng },
    zoom: map.getZoom()
  };
}
function applySavedMapView(mode) {
  const view = mode ? mapViewState[mode] : null;
  if (view && view.center && typeof view.zoom === 'number') {
    map.setView([view.center.lat, view.center.lng], view.zoom, { animate: false });
    return true;
  }
  return false;
}
map.on('moveend', () => {
  if (activeMode === 'nearby' || activeMode === 'route') {
    captureMapView(activeMode);
  }
});

// Update marker sizes dynamically on zoom for touch devices (performance optimization)
map.on('zoomend', () => {
  const deviceType = detectDeviceType();
  const zoom = map ? map.getZoom() : 5;
  
  // Update route line weights based on zoom (all devices)
  if (routeOutlinePolyline && routeMainPolyline) {
    const routeWeights = calculateRouteLineWeights(zoom);
    routeOutlinePolyline.setStyle({
      weight: routeWeights.outlineWeight,
      opacity: routeWeights.outlineOpacity
    });
    routeMainPolyline.setStyle({
      weight: routeWeights.mainWeight,
      opacity: routeWeights.mainOpacity
    });
  }
  
  // Only update marker sizes on touch devices (mobile/tablet), desktop always uses radius 5 and icon size 24x30
  if (deviceType === 'desktop') return;
  
  const newRadius = getCurrentMarkerRadius();
  const newIconSize = getCurrentSavedIconSize();
  const newSavedIcon = createGreenSavedIcon(newIconSize);
  
  // Update all marker instances without recreating them
  markersLayer.eachLayer((layer) => {
    // Update circleMarker types (blue dots)
    if (layer.setRadius && typeof layer.setRadius === 'function') {
      layer.setRadius(newRadius);
    }
    // Update saved icon markers (green pins)
    else if (layer.setIcon && typeof layer.setIcon === 'function' && layer.options && layer.options.icon) {
      // Check if this is a saved marker by checking if it has the green saved icon
      const currentIcon = layer.options.icon;
      if (currentIcon && currentIcon.options && currentIcon.options.iconUrl && 
          currentIcon.options.iconUrl.includes('data:image/svg+xml') &&
          currentIcon.options.iconUrl.includes('64D85B')) {
        // This is a saved icon marker (green pin), update its size
        layer.setIcon(newSavedIcon);
      }
    }
  });
});

window.addEventListener('resize', () => {
  if (window.innerWidth > 700) {
    resetHeaderForDesktop();
  } else if (!mobileHeaderCollapsed) {
    addHeaderInteractionListeners();
  }
});

// SavedStore: Manages saved college IDs in localStorage
const SAVED_STORAGE_KEY = 'uscm_saved_v1';
const SavedStore = (() => {
  const STORAGE_KEY = SAVED_STORAGE_KEY;
  let savedIds = new Set();
  
  // Load from localStorage on init
  function load() {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed)) {
          savedIds = new Set(parsed);
        } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.saved)) {
          savedIds = new Set(parsed.saved);
        }
      }
    } catch (err) {
      console.warn('SavedStore: failed to load saved state', err);
      savedIds = new Set();
    }
  }
  
  // Save to localStorage
  function save() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(Array.from(savedIds)));
    } catch (err) {
      console.warn('SavedStore: failed to persist state', err);
    }
  }
  
  // Initialize on load
  load();
  
  return {
    isSaved(collegeId) {
      return savedIds.has(collegeId);
    },
    toggle(collegeId) {
      if (!collegeId) return;
      if (savedIds.has(collegeId)) {
        savedIds.delete(collegeId);
      } else {
        savedIds.add(collegeId);
      }
      save();
      // Track save/unsave action
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_saved_used');
      }
    },
    getAll() {
      return Array.from(savedIds);
    }
  };
})();

// Active mode state: 'nearby' or 'route'
let activeMode = 'nearby';

// Track if user has actively used search controls (Locate or Find Route buttons)
let hasUsedSearchControls = false;

// Marker registry: maps college_id to Leaflet marker instance
const markersByCollegeId = {};

// Create green saved icon (pin with white star)
const greenSavedPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 256 256"><path d="M128 0C74 0 32 42 32 96C32 166 128 256 128 256C128 256 224 166 224 96C224 42 182 0 128 0Z" fill="#64D85B"/><path d="M128 32L147 86H200L159 118L175 170L128 139L81 170L97 118L56 86H109L128 32Z" fill="#FFFFFF"/></svg>';
// Default green saved icon (desktop size, used as fallback)
// Note: For dynamic sizing, use createGreenSavedIcon() instead
const greenSavedIcon = createGreenSavedIcon({ width: 24, height: 30 });

// Create blue circle icon for unsaved colleges
const blueCircleSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="4" fill="#2563eb" fill-opacity="0.7" stroke="#2563eb" stroke-width="2"/></svg>';
const blueDotIcon = L.divIcon({
  html: blueCircleSvg,
  className: 'blue-dot-marker',
  iconSize: [10, 10],
  iconAnchor: [5, 5]
});

// Helper function to create a marker with appropriate icon based on saved state
function createCollegeMarker(college, popupContent, collegeId) {
  const isSaved = collegeId && SavedStore.isSaved(collegeId);
  
  let marker;
  if (isSaved) {
    // Use green pin icon for saved colleges with dynamic sizing
    const iconSize = getCurrentSavedIconSize();
    marker = L.marker([college.lat, college.lon], {
      icon: createGreenSavedIcon(iconSize)
    });
  } else {
    // Use blue circle marker for unsaved colleges with dynamic sizing for touch devices
    const radius = getCurrentMarkerRadius();
    marker = L.circleMarker([college.lat, college.lon], {
      radius: radius,
      color: '#2563eb',
      weight: 2,
      fillOpacity: 0.7
    });
  }
  
  marker
    .bindTooltip(college.name, {permanent: false, direction: 'top'})
    .bindPopup(popupContent);
  marker.on('click', () => {
    if (marker.closeTooltip) {
      marker.closeTooltip();
    }
  });
  
  // Register marker in registry
  if (collegeId) {
    markersByCollegeId[collegeId] = marker;
  }
  
  return marker;
}

// Update popup save button visual state
// Cached references to avoid repeated DOM queries
const buttonCache = new WeakMap();

function updatePopupSaveButton(button, collegeId) {
  if (!button || !collegeId) return;
  
  // Cache DOM references to avoid repeated querySelector calls
  let cached = buttonCache.get(button);
  if (!cached) {
    cached = {
      icon: button.querySelector('.popup-save-icon'),
      label: button.querySelector('.popup-save-label')
    };
    buttonCache.set(button, cached);
  }
  
  const icon = cached.icon;
  const label = cached.label;
  const isSaved = SavedStore.isSaved(collegeId);
  
  // Update button class
  if (isSaved) {
    button.classList.add('saved');
  } else {
    button.classList.remove('saved');
  }
  
  // Update icon and label
  if (icon) {
    icon.textContent = isSaved ? '★' : '☆';
  }
  if (label) {
    label.textContent = isSaved ? 'Saved' : 'Save';
  }
}

// Track tooltip states to restore them when popup closes
const tooltipStates = new WeakMap();

// Handle popup open: disable all tooltips and update save button state
map.on('popupopen', (event) => {
  const popupEl = event.popup && event.popup.getElement ? event.popup.getElement() : null;
  if (!popupEl) return;
  const sourceMarker = event.popup && event.popup._source;
  if (sourceMarker && sourceMarker.closeTooltip) {
    sourceMarker.closeTooltip();
  }
  
  // Disable tooltips on all markers when popup is open
  markersLayer.eachLayer((layer) => {
    if (layer.getTooltip && layer.getTooltip()) {
      const tooltip = layer.getTooltip();
      const tooltipContent = tooltip.getContent();
      // Store tooltip content to restore later
      tooltipStates.set(layer, tooltipContent);
      // Unbind tooltip to prevent it from showing on hover
      layer.unbindTooltip();
    }
  });
  
  const button = popupEl.querySelector('.popup-save-btn');
  if (!button) return;
  
  const collegeId = button.dataset.collegeId || '';
  if (!collegeId) {
    button.style.display = 'none';
    return;
  }
  
  // Defer button state update to allow popup to appear first (performance optimization)
  // This makes taps feel instant on mobile by not blocking popup appearance
  requestAnimationFrame(() => {
    // Update button state based on saved status
    updatePopupSaveButton(button, collegeId);
  });
  
  // Attach click handler if not already attached
  if (!button.dataset.listenerAttached) {
    button.addEventListener('click', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      
      // Toggle saved state
      SavedStore.toggle(collegeId);
      
      // Immediately update button visual state (user action, so update synchronously)
      updatePopupSaveButton(button, collegeId);
      
      // Update marker icon
      const marker = markersByCollegeId[collegeId];
      if (marker) {
        const isSaved = SavedStore.isSaved(collegeId);
        const latlng = marker.getLatLng();
        const popup = marker.getPopup();
        const tooltip = marker.getTooltip();
        const popupContent = popup ? popup.getContent() : '';
        const tooltipContent = tooltip ? tooltip.getContent() : '';
        const wasPopupOpen = popup && marker.isPopupOpen();
        
        // Remove old marker
        marker.remove();
        
        // Create new marker with appropriate icon
        let newMarker;
        if (isSaved) {
          // Use green pin icon for saved colleges with dynamic sizing
          const iconSize = getCurrentSavedIconSize();
          newMarker = L.marker(latlng, {
            icon: createGreenSavedIcon(iconSize)
          });
        } else {
          // Use blue circle marker for unsaved colleges with dynamic sizing
          const radius = getCurrentMarkerRadius();
          newMarker = L.circleMarker(latlng, {
            radius: radius,
            color: '#2563eb',
            weight: 2,
            fillOpacity: 0.7
          });
        }
        
        if (popupContent) newMarker.bindPopup(popupContent);
        if (tooltipContent) newMarker.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
        newMarker.addTo(markersLayer);
        markersByCollegeId[collegeId] = newMarker;
        
        // Reopen popup if it was open before
        if (wasPopupOpen) {
          newMarker.openPopup();
        }
      }
    });
    button.dataset.listenerAttached = '1';
  }
});

// Handle popup close: re-enable tooltips on all markers
map.on('popupclose', () => {
  // Re-enable tooltips on all markers when popup closes
  markersLayer.eachLayer((layer) => {
    const tooltipContent = tooltipStates.get(layer);
    if (tooltipContent) {
      // Rebind tooltip with stored content
      layer.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
      tooltipStates.delete(layer);
    }
  });
});

// Route state
let route = {
  start: null, // { description, lat, lon }
  end: null,
  lastSearch: null, // { start, end, maxDistance, units }
  lastResult: null // Cached visualization data for restoring route view quickly
};

// Nearby state (for restoration)
let nearbyState = {
  address: null,
  home: null,
  radius: null,
  units: null
};
let lastNearbyFilters = null;

const TYPE_ORDER = ["Ivy League","Elite Private Universities","Public Flagship Universities","Private Liberal Arts Colleges","STEM / Technology Institutes","Business / Arts / Specialty Schools","Health & Medical Colleges","Faith-Based","Public Regional Universities","Community Colleges","Online / For-Profit"];

// Region mapping for better performance
const REGION_MAP = {
  'Northeast': ['ME','NH','VT','MA','RI','CT','NY','NJ','PA'],
  'Midwest': ['OH','MI','IN','IL','WI','MN','IA','MO','ND','SD','NE','KS'],
  'South': ['DE','MD','DC','VA','WV','NC','SC','GA','FL','KY','TN','AL','MS','AR','LA','TX','OK'],
  'West': ['MT','ID','WY','CO','NM','AZ','UT','NV','CA','OR','WA','HI','AK'],
  'Territories': ['PR','GU','VI','AS','MP']
};

// Calculate distance between two coordinates (Haversine formula)
function calculateDistance(lat1, lon1, lat2, lon2, unit = 'mi') {
  const R = unit === 'mi' ? 3959 : 6371; // Earth radius in miles or km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Debounce function for search input
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function showError(message) {
  if (elements.error) {
    elements.error.textContent = message;
    elements.error.classList.add('active');
    setTimeout(() => {
      if (elements.error) {
        elements.error.classList.remove('active');
      }
    }, 5000);
  }
}

const RECENT_STORAGE_KEYS = {
  nearby: 'ucm_recentAddresses',
  routeStart: 'ucm_routeRecentStart',
  routeEnd: 'ucm_routeRecentEnd'
};
const MAX_RECENT_ITEMS = 5;
const SHARED_RECENT_KEY = 'ucm_recentLocations';
const MAX_SHARED_RECENT_ITEMS = 10;

function escapeHtml(text = '') {
  return text.replace(/&/g, '&amp;')
             .replace(/</g, '&lt;')
             .replace(/>/g, '&gt;')
             .replace(/"/g, '&quot;')
             .replace(/'/g, '&#39;');
}

function loadRecents(storageKey) {
  try {
    const stored = localStorage.getItem(storageKey);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(item => typeof item === 'string' && item.trim().length);
  } catch (error) {
    console.warn('Unable to load recents for key', storageKey, error);
    return [];
  }
}

function loadSharedLocations() {
  try {
    const stored = localStorage.getItem(SHARED_RECENT_KEY);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter(item => {
      return item && typeof item.description === 'string' &&
             typeof item.lat === 'number' && !isNaN(item.lat) &&
             typeof item.lon === 'number' && !isNaN(item.lon);
    });
  } catch (error) {
    console.warn('Unable to load shared locations', error);
    return [];
  }
}

function saveSharedLocation(description, lat, lon) {
  if (!description || typeof description !== 'string') return;
  const trimmed = description.trim();
  const latNum = typeof lat === 'number' ? lat : parseFloat(lat);
  const lonNum = typeof lon === 'number' ? lon : parseFloat(lon);
  if (!trimmed || isNaN(latNum) || isNaN(lonNum)) return;
  const normalizedKey = `${trimmed.toLowerCase()}|${latNum.toFixed(6)}|${lonNum.toFixed(6)}`;
  const existing = loadSharedLocations().filter(item => {
    const itemKey = `${(item.description || '').toLowerCase()}|${item.lat.toFixed(6)}|${item.lon.toFixed(6)}`;
    return itemKey !== normalizedKey;
  });
  existing.unshift({ description: trimmed, lat: latNum, lon: lonNum });
  try {
    localStorage.setItem(SHARED_RECENT_KEY, JSON.stringify(existing.slice(0, MAX_SHARED_RECENT_ITEMS)));
  } catch (error) {
    console.warn('Unable to persist shared locations', error);
  }
}

function saveRecent(storageKey, value) {
  if (!storageKey || typeof value !== 'string') return;
  const trimmed = value.trim();
  if (!trimmed.length) return;
  const existing = loadRecents(storageKey).filter(item => item.toLowerCase() !== trimmed.toLowerCase());
  existing.unshift(trimmed);
  try {
    localStorage.setItem(storageKey, JSON.stringify(existing.slice(0, MAX_RECENT_ITEMS)));
  } catch (error) {
    console.warn('Unable to persist recents for key', storageKey, error);
  }
}

function getFallbackRecentsForField(field) {
  if (!field) return [];
  if (field === 'address') return loadRecents(RECENT_STORAGE_KEYS.nearby);
  if (field === 'routeStart') return loadRecents(RECENT_STORAGE_KEYS.routeStart);
  if (field === 'routeEnd') return loadRecents(RECENT_STORAGE_KEYS.routeEnd);
  return [];
}

function clearRecentState(container) {
  if (!container) return;
  delete container.dataset.showingRecents;
  delete container.dataset.recentContext;
}

function shouldShowRecentsForInput(inputElement) {
  if (!inputElement) return false;
  if (document.activeElement !== inputElement) return false;
  return (inputElement.value || '').trim().length < 3;
}

function buildUnifiedRecentSection(fallbackRecents = [], options = {}) {
  const query = (options.query || '').trim().toLowerCase();
  const shouldFilterShared = options.filterShared && query.length > 0;
  const shouldFilterFallback = options.filterFallback && query.length > 0;
  const sharedLocations = loadSharedLocations();
  let sharedItems = sharedLocations;
  if (shouldFilterShared) {
    sharedItems = sharedLocations.filter(loc => (loc.description || '').toLowerCase().startsWith(query));
  }
  let sectionItems = '';
  if (sharedItems.length) {
    sectionItems = sharedItems.map(loc => {
      const encodedDescription = encodeURIComponent(loc.description || '');
      const safeDescription = escapeHtml(loc.description || '');
      const safeDetails = `${loc.lat.toFixed(3)}, ${loc.lon.toFixed(3)}`;
      return `
        <div class="autocomplete-item shared-location" role="option" tabindex="0"
             data-shared="true"
             data-description="${encodedDescription}"
             data-lat="${loc.lat}"
             data-lon="${loc.lon}">
          <div class="autocomplete-item-icon">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
            </svg>
          </div>
          <div class="autocomplete-item-content">
            <div class="address-name">${safeDescription}</div>
            <div class="address-details">${safeDetails}</div>
          </div>
        </div>`;
    }).join('');
  } else {
    let fallbackItems = fallbackRecents;
    if (shouldFilterFallback) {
      fallbackItems = fallbackRecents.filter(value => value.toLowerCase().startsWith(query));
    }
    if (fallbackItems.length) {
      sectionItems = fallbackItems.map(value => {
        const encodedValue = encodeURIComponent(value);
        const safeValue = escapeHtml(value);
        return `
          <div class="autocomplete-item recent-suggestion" role="option" tabindex="0" data-recent="true" data-value="${encodedValue}">
            <div class="autocomplete-item-icon">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2a10 10 0 1 0 10 10A10.011 10.011 0 0 0 12 2zm0 18a8 8 0 1 1 8-8a8.009 8.009 0 0 1-8 8zm.75-12h-1.5v5l4.25 2.55l.75-1.23l-3.5-2.07z"/>
              </svg>
            </div>
            <div class="autocomplete-item-content">
              <div class="address-name">${safeValue}</div>
            </div>
          </div>`;
      }).join('');
    }
  }
  if (!sectionItems) {
    return '';
  }
  return `
    <div class="autocomplete-section-title">Recent locations</div>
    ${sectionItems}
    <div class="autocomplete-divider" role="separator"></div>`;
}

function toggleAutocompleteLayer(inputElement, isActive) {
  const wrapper = inputElement ? inputElement.closest('.address-autocomplete') : null;
  if (!wrapper) return;
  if (isActive) {
    wrapper.classList.add('autocomplete-active');
  } else {
    wrapper.classList.remove('autocomplete-active');
  }
}

function showRecentSuggestions(container, recents, inputElement, context, options = {}) {
  if (!container || !inputElement) return false;
  const unifiedSection = buildUnifiedRecentSection(recents, options);
  if (!unifiedSection) {
    clearRecentState(container);
    return false;
  }
  container.innerHTML = unifiedSection;
  container.classList.add('active');
  container.dataset.showingRecents = 'true';
  container.dataset.recentContext = context || '';
  inputElement.setAttribute('aria-expanded', 'true');
  return true;
}

function showAddressRecentsIfEligible() {
  if (!elements.address || !elements.addressSuggestions) return false;
  const queryValue = (elements.address.value || '').trim();
  if (!shouldShowRecentsForInput(elements.address)) {
    return false;
  }
  const recents = loadRecents(RECENT_STORAGE_KEYS.nearby);
  const shown = showRecentSuggestions(
    elements.addressSuggestions,
    recents,
    elements.address,
    'address',
    {
      query: queryValue,
      filterShared: true,
      filterFallback: true
    }
  );
  if (shown) {
    addressAutocomplete.suggestions = [];
    addressAutocomplete.selectedIndex = -1;
  }
  return shown;
}

function showRouteRecentsIfEligible(inputElement, suggestionsContainer, autocompleteObj, storageKey, context) {
  if (!inputElement || !suggestionsContainer) return false;
  const queryValue = (inputElement.value || '').trim();
  if (!shouldShowRecentsForInput(inputElement)) {
    return false;
  }
  const recents = loadRecents(storageKey);
  const shown = showRecentSuggestions(
    suggestionsContainer,
    recents,
    inputElement,
    context,
    {
      query: queryValue,
      filterShared: true,
      filterFallback: true
    }
  );
  if (shown && autocompleteObj) {
    autocompleteObj.suggestions = [];
    autocompleteObj.selectedIndex = -1;
  }
  return shown;
}

function handleRecentAddressSelection(value) {
  if (!value) return;
  addressAutocomplete.suggestions = [{ description: value }];
  selectSuggestion(0);
}

function handleRecentRouteSelection(value, context) {
  if (!value) return;
  if (context === 'routeStart' && elements.routeStart && elements.routeStartSuggestions) {
    routeStartAutocomplete.suggestions = [{ description: value }];
    selectRouteSuggestion(0, routeStartAutocomplete, elements.routeStart, elements.routeStartSuggestions);
  } else if (context === 'routeEnd' && elements.routeEnd && elements.routeEndSuggestions) {
    routeEndAutocomplete.suggestions = [{ description: value }];
    selectRouteSuggestion(0, routeEndAutocomplete, elements.routeEnd, elements.routeEndSuggestions);
  }
}

function handleSharedLocationSelection(field, description) {
  if (!field || !description) return;
  if (field === 'address') {
    handleRecentAddressSelection(description);
  } else if (field === 'routeStart') {
    handleRecentRouteSelection(description, 'routeStart');
  } else if (field === 'routeEnd') {
    handleRecentRouteSelection(description, 'routeEnd');
  }
}

function getRouteFilterSignature() {
  const typeVal = elements.type ? elements.type.value.trim() : '';
  const regionVal = elements.region ? elements.region.value.trim() : '';
  const stateVal = elements.state ? elements.state.value.trim() : '';
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  const maxDistance = parseFloat(elements.routeMaxDistance?.value || '30') || 30;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  return { typeVal, regionVal, stateVal, searchVal, maxDistance, units };
}

function addRouteCollegeMarker(college, distanceText, units) {
  try {
    if (isNaN(college.lat) || isNaN(college.lon) || college.lat === 0 || college.lon === 0) {
      console.warn(`Invalid coordinates for ${college.name}:`, college.lat, college.lon);
      return;
    }

    const tuition = college.tuition ? (college.tuition.toString().includes('$') ? college.tuition : `$${Number(college.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = college.acceptance ? (college.acceptance.toString().includes('%') ? college.acceptance : `${parseFloat(college.acceptance).toFixed(1)}%`) : 'N/A';

    const saveButtonHtml = college.college_id ? `
      <div class="popup-save-row">
        <button type="button" class="popup-save-btn" data-college-id="${college.college_id}">
          <span class="popup-save-icon" aria-hidden="true">☆</span>
          <span class="popup-save-label">Save</span>
        </button>
      </div>` : '';

    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${college.name}</b><br>
        ${college.state} · ${(college.type||'Unknown')}${distanceText || ''}<br>
        ${college.control ? college.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${college.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${college.url ? `<a href="https://${college.url.replace(/^https?:\/\//,'')}" target="_blank">${college.url}</a>` : ''}
        ${saveButtonHtml}
      </div>`;

    const marker = createCollegeMarker(college, popupContent, college.college_id);
    marker.addTo(markersLayer);
  } catch (e) {
    console.error(`Error creating marker for ${college.name}:`, e);
  }
}

function areNearbySignaturesEqual(a, b) {
  if (!a || !b) return false;
  const keys = ['typeVal', 'regionVal', 'stateVal', 'searchVal', 'radiusVal', 'unitsVal', 'homeLat', 'homeLon'];
  return keys.every(key => (a[key] ?? '') === (b[key] ?? ''));
}

function isRouteCacheValid(cache, filters, currentStart, currentEnd) {
  if (!cache || !cache.filters || !filters) return false;
  const keys = ['typeVal', 'regionVal', 'stateVal', 'searchVal', 'maxDistance', 'units'];
  const filtersMatch = keys.every(key => (cache.filters[key] || '') === (filters[key] || ''));
  const sameStart = cache.start && currentStart &&
    cache.start.lat === currentStart.lat &&
    cache.start.lon === currentStart.lon &&
    (cache.start.description || '') === (currentStart.description || '');
  const sameEnd = cache.end && currentEnd &&
    cache.end.lat === currentEnd.lat &&
    cache.end.lon === currentEnd.lon &&
    (cache.end.description || '') === (currentEnd.description || '');
  return filtersMatch && sameStart && sameEnd && Array.isArray(cache.routeCoords) && cache.routeCoords.length > 0;
}

function restoreRouteFromCache(cache, options = {}) {
  if (!cache) return false;
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;

  // Draw route with ribbon effect
  const zoom = map ? map.getZoom() : 5;
  const routeWeights = calculateRouteLineWeights(zoom);
  
  // First draw the deep navy outline (thin line for ribbon effect)
  routeOutlinePolyline = L.polyline(cache.routeCoords, {
    color: '#0A2CA5',
    weight: routeWeights.outlineWeight,
    opacity: routeWeights.outlineOpacity
  }).addTo(routeLayer);
  // Then draw the vivid royal blue main route line on top
  routeMainPolyline = L.polyline(cache.routeCoords, {
    color: '#1A4CFF',
    weight: routeWeights.mainWeight,
    opacity: routeWeights.mainOpacity
  }).addTo(routeLayer);

  const startData = cache.start;
  if (startData) {
    L.marker([startData.lat, startData.lon], {
      icon: L.icon({
        iconUrl: ROUTE_START_PIN_ICON,
        iconSize: [18, 18],
        iconAnchor: [9, 9],
        popupAnchor: [0, -9]
      })
    }).addTo(routeLayer).bindPopup('From');
  }

  const endData = cache.end;
  if (endData) {
    L.marker([endData.lat, endData.lon], {
      icon: L.icon({
        iconUrl: ROUTE_END_PIN_ICON,
        iconSize: [24, 30],
        iconAnchor: [12, 30],
        popupAnchor: [0, -30]
      })
    }).addTo(routeLayer).bindPopup('To');
  }

  const units = cache.filters?.units || 'mi';
  let collegesToRender = cache.colleges || [];
  
  // Apply saved-only filter if enabled
  if (savedOnlyMode) {
    collegesToRender = collegesToRender.filter(item => SavedStore.isSaved(item.college.college_id));
  }
  
  collegesToRender.forEach(item => {
    addRouteCollegeMarker(item.college, item.distanceText || '', units);
  });

  if (elements.count) elements.count.textContent = collegesToRender.length;
  updateMapHints(
    collegesToRender.length,
    cache.filters?.typeVal || '',
    cache.filters?.regionVal || '',
    cache.filters?.stateVal || '',
    cache.filters?.searchVal || ''
  );

  if (!options.preserveView) {
    if (cache.bounds && cache.bounds.isValid()) {
      map.fitBounds(cache.bounds.pad(0.15));
    } else if (cache.routeCoords && cache.routeCoords.length) {
      map.fitBounds(L.latLngBounds(cache.routeCoords), { padding: [50, 50] });
    }
  }
  if (elements.loading) elements.loading.classList.remove('active');
  return true;
}

// Re-filter colleges along route without redrawing the route line
function refilterCollegesAlongRoute() {
  if (!route.lastResult || !route.lastResult.routeCoords) {
    // No cached route, need to fetch it
    findCollegesAlongRoute();
    return;
  }
  
  const cache = route.lastResult;
  const routeCoords = cache.routeCoords;
  
  // Skip if this is a fallback route (only 2 points = straight line)
  // We don't want to process fallback routes when toggling saved-only
  if (routeCoords.length <= 2) {
    console.log('Skipping refilter - route is a fallback straight line');
    return;
  }
  const maxDistance = parseFloat(elements.routeMaxDistance?.value || '30') || 30;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  
  // Sample route points for performance
  const sampleRate = routeCoords.length > 100 ? 10 : 1;
  const sampledRoute = [];
  for (let i = 0; i < routeCoords.length; i += sampleRate) {
    sampledRoute.push(routeCoords[i]);
  }
  if (sampledRoute[sampledRoute.length - 1] !== routeCoords[routeCoords.length - 1]) {
    sampledRoute.push(routeCoords[routeCoords.length - 1]);
  }
  
  // Filter colleges by distance to route
  const filtered = colleges.filter(c => {
    let minDistance = Infinity;
    for (let i = 0; i < sampledRoute.length - 1; i++) {
      const segmentStart = sampledRoute[i];
      const segmentEnd = sampledRoute[i + 1];
      const dist = distanceToLineSegment(
        c.lat, c.lon,
        segmentStart[0], segmentStart[1],
        segmentEnd[0], segmentEnd[1],
        units
      );
      minDistance = Math.min(minDistance, dist);
      if (minDistance <= maxDistance) break;
    }
    return minDistance <= maxDistance;
  });
  
  // Apply other filters
  const typeVal = elements.type ? elements.type.value.trim() : '';
  const regionVal = elements.region ? elements.region.value.trim() : '';
  const stateVal = elements.state ? elements.state.value.trim() : '';
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  
  const finalFiltered = filtered.filter(c => {
    if (typeVal && (c.type || c.tier) !== typeVal) return false;
    if (regionVal) {
      const regionStates = REGION_MAP[regionVal] || [];
      if (!regionStates.includes(c.state)) return false;
    }
    if (stateVal && c.state !== stateVal) return false;
    if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
    return true;
  });
  
  const routeEntries = finalFiltered.map(c => {
    let distanceText = '';
    let minRouteDist = Infinity;
    for (let i = 0; i < sampledRoute.length - 1; i++) {
      const dist = distanceToLineSegment(
        c.lat, c.lon,
        sampledRoute[i][0], sampledRoute[i][1],
        sampledRoute[i + 1][0], sampledRoute[i + 1][1],
        units
      );
      minRouteDist = Math.min(minRouteDist, dist);
    }
    if (minRouteDist < Infinity) {
      distanceText = `<br>Distance from route: ${minRouteDist.toFixed(1)} ${units}`;
    }
    return { college: c, distanceText };
  });
  
  const visibleRouteEntries = savedOnlyMode
    ? routeEntries.filter(item => SavedStore.isSaved(item.college.college_id))
    : routeEntries;
  
  if (visibleRouteEntries.length === 0 && savedOnlyMode) {
    const savedCount = SavedStore.getAll().length;
    if (savedCount === 0) {
      console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
    } else {
      console.log("No saved colleges match your current filters or route.");
    }
  }
  
  // Clear and render markers only (don't touch routeLayer)
  markersLayer.clearLayers();
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  
  const routeBounds = L.latLngBounds(routeCoords);
  routeEntries.forEach(item => {
    routeBounds.extend([item.college.lat, item.college.lon]);
  });
  
  visibleRouteEntries.forEach(item => {
    addRouteCollegeMarker(item.college, item.distanceText, units);
  });
  
  if (elements.count) elements.count.textContent = visibleRouteEntries.length;
  updateMapHints(visibleRouteEntries.length, typeVal, regionVal, stateVal, searchVal);
  
  route.lastResult.colleges = routeEntries;
  route.lastResult.filters = { typeVal, regionVal, stateVal, searchVal, maxDistance, units };
  if (routeBounds.isValid()) {
    route.lastResult.bounds = routeBounds;
  }
}

/**
 * Render colleges on the map based on current filters.
 * 
 * Performance: This function is NOT called during map pan/zoom interactions.
 * Markers are only re-rendered when:
 * - User changes filters (Type, Region, State, Search)
 * - User sets/changes address/radius
 * - User switches between Nearby/Route modes
 * - NOT during map dragging/zooming (Leaflet handles marker visibility automatically)
 */
function render(){
  // Only render in nearby mode - route mode uses findCollegesAlongRoute()
  if (activeMode === 'route') {
    // If route search has been performed, re-run it with updated filters
    if (route.lastSearch) {
      findCollegesAlongRoute();
    } else {
      // If in route mode but no route search, show colleges based on filters only
      // Clear route visualization
      routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      
      // Apply filters from dropdowns
      const stateVal = elements.state ? elements.state.value : '';
      const regionVal = elements.region ? elements.region.value : '';
      const typeVal = elements.type ? elements.type.value : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      
      let filtered = colleges.filter(c => {
        // Region filter
        const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
        if (!regionMatch) return false;
        
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        
        // Type filter
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        return true;
      });
      
      // Apply saved-only filter if enabled
      if (savedOnlyMode) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(c => SavedStore.isSaved(c.college_id));
        
        // Edge case: Show message if no saved colleges match filters
        if (filtered.length === 0) {
          const savedCount = SavedStore.getAll().length;
          if (savedCount === 0) {
            // No saved colleges at all
            console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
          } else {
            // Saved colleges exist but don't match current filters
            console.log("No saved colleges match your current filters or route.");
          }
        }
      }
      
      // Render filtered colleges
      filtered.forEach(c => {
        try {
          if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
            return;
          }
          
          const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
          const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
          
          const saveButtonHtml = c.college_id ? `
            <div class="popup-save-row">
              <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
                <span class="popup-save-icon" aria-hidden="true">☆</span>
                <span class="popup-save-label">Save</span>
              </button>
            </div>` : '';

          const popupContent = `
            <div style="font-size:12px;line-height:1.4">
              <b>${c.name}</b><br>
              ${c.state} · ${(c.type||'Unknown')}<br>
              ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
              Enrollment: ${c.enrollment || 'N/A'}<br>
              Tuition: ${tuition}<br>
              ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
              ${saveButtonHtml}
            </div>`;

          const marker = createCollegeMarker(c, popupContent, c.college_id);
          marker.addTo(markersLayer);
        } catch (e) {
          console.error(`Error creating marker for ${c.name}:`, e);
        }
      });
      
      if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
      
      // Update map hints for route mode (no route search yet)
      updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
    }
    return;
  }
  
  // Clear route visualization when in nearby mode
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  
  // Check if colleges data is loaded
  if (!colleges || colleges.length === 0) {
    console.log('No colleges data available yet');
    if (elements.count) elements.count.textContent = '0';
    return;
  }
  
  markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
  radiusLayer.clearLayers();
  
  const stateVal = elements.state ? elements.state.value : '';
  const regionVal = elements.region ? elements.region.value : '';
  const typeVal = elements.type ? elements.type.value : '';
  // Get search value from either desktop or mobile search field (prefer the one with a value, or desktop first)
  const desktopSearch = elements.search;
  const mobileSearch = document.getElementById('search-mobile');
  const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
  const radiusVal = parseFloat(elements.radius?.value || '0') || 0;
  const unitsVal = elements.units ? elements.units.value : 'mi';
  const nearbySignature = {
    typeVal,
    regionVal,
    stateVal,
    searchVal,
    radiusVal,
    unitsVal,
    homeLat: home ? Number(home.lat.toFixed(6)) : null,
    homeLon: home ? Number(home.lon.toFixed(6)) : null
  };
  const shouldAutoFrameNearby = !lastNearbyFilters || !mapViewState.nearby || !areNearbySignaturesEqual(lastNearbyFilters, nearbySignature);
  const isDefaultNearbyState = !home && !regionVal && !stateVal && !typeVal && !searchVal;
  const isSearchOnlyFilter = !!searchVal && !home && !regionVal && !stateVal && !typeVal;

  let filtered = colleges.filter(c => {
    // Region filter
    const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
    if (!regionMatch) return false;
    
    // State filter
    if (stateVal && c.state !== stateVal) return false;
    
    // Type filter
    if (typeVal && (c.type || c.tier) !== typeVal) return false;
    
    // Search filter
    if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
    
    // Radius filter (if home location is set)
    if (home && radiusVal > 0) {
      const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
      if (distance > radiusVal) return false;
    }
    
    return true;
  });
  
  // Apply saved-only filter if enabled
  if (savedOnlyMode) {
    const beforeCount = filtered.length;
    filtered = filtered.filter(c => SavedStore.isSaved(c.college_id));
    
    // Edge case: Show message if no saved colleges match filters
    if (filtered.length === 0) {
      const savedCount = SavedStore.getAll().length;
      if (savedCount === 0) {
        // No saved colleges at all
        console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
      } else {
        // Saved colleges exist but don't match current filters
        console.log("No saved colleges match your current filters or route.");
      }
    }
  }

  // Draw radius circle if home and radius are set
  if (home && radiusVal > 0) {
    const radiusMeters = radiusVal * (unitsVal === 'mi' ? 1609.34 : 1000);
    L.circle([home.lat, home.lon], {
      radius: radiusMeters,
      color: '#2563eb',
      fillColor: '#2563eb',
      fillOpacity: 0.1,
      weight: 2,
      dashArray: '5, 5'
    }).addTo(radiusLayer);
  }

  console.log(`Rendering ${filtered.length} colleges (activeMode: ${activeMode}, home: ${home ? 'set' : 'null'})`);
  
  const nearbyBounds = filtered.length > 1 ? L.latLngBounds([]) : null;
  filtered.forEach(c => {
    try {
      // Validate coordinates
      if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
        console.warn(`Invalid coordinates for ${c.name}:`, c.lat, c.lon);
        return;
      }
      
    const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
    const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
      
      // Calculate distance if home is set
      let distanceText = '';
      if (home) {
        const distance = calculateDistance(home.lat, home.lon, c.lat, c.lon, unitsVal);
        distanceText = `<br>Distance: ${distance.toFixed(1)} ${unitsVal}`;
      }
      
    const saveButtonHtml = c.college_id ? `
      <div class="popup-save-row">
        <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
          <span class="popup-save-icon" aria-hidden="true">☆</span>
          <span class="popup-save-label">Save</span>
        </button>
      </div>` : '';

    const popupContent = `
      <div style="font-size:12px;line-height:1.4">
        <b>${c.name}</b><br>
          ${c.state} · ${(c.type||'Unknown')}${distanceText}<br>
        ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
        Enrollment: ${c.enrollment || 'N/A'}<br>
        Tuition: ${tuition}<br>
        ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
        ${saveButtonHtml}
      </div>`;

    const marker = createCollegeMarker(c, popupContent, c.college_id);
    marker.addTo(markersLayer);
    if (nearbyBounds) {
      nearbyBounds.extend(marker.getLatLng());
    }
    } catch (e) {
      console.error(`Error creating marker for ${c.name}:`, e);
    }
  });

  if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
  console.log(`Added ${filtered.length} markers to map`);
  
  // Update map hints based on filtered results
  updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
  
  if (shouldAutoFrameNearby) {
    if ((isDefaultNearbyState || isSearchOnlyFilter) && mapViewState.nearby) {
      map.setView([mapViewState.nearby.center.lat, mapViewState.nearby.center.lng], mapViewState.nearby.zoom);
      captureMapView('nearby');
    } else if (filtered.length === 0) {
      if (home) {
        map.setView([home.lat, home.lon], 8);
      } else {
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    } else if (filtered.length === 1) {
      map.setView([filtered[0].lat, filtered[0].lon], 8);
    } else if (nearbyBounds && nearbyBounds.isValid()) {
      const paddedBounds = nearbyBounds.pad(0.15);
      const constrainedBounds = clampBoundsToMainland(paddedBounds);
      map.fitBounds(constrainedBounds);
    } else if (home) {
      map.setView([home.lat, home.lon], 8);
    } else {
      map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
    }
  } else {
    if (!applySavedMapView('nearby')) {
      if (home) {
        map.setView([home.lat, home.lon], 8);
      } else {
        map.setView([mapViewState.nearby?.center.lat || 39.5, mapViewState.nearby?.center.lng || -98.35], mapViewState.nearby?.zoom || 4);
      }
    }
  }
  lastNearbyFilters = nearbySignature;
}

function refreshDropdown(id, values, placeholder) {
  const select = document.getElementById(id);
  select.innerHTML = `<option value="">${placeholder}</option>` + values.map(v => `<option>${v}</option>`).join('');
}

/**
 * Update map hint popups based on filtered results and filter state
 * Only shows hints when user has actively used search controls
 * Priority: No Results > Too Many Colleges (never show both)
 */
function updateMapHints(visibleCount, typeVal, regionVal, stateVal, searchVal) {
  const hintTooMany = document.getElementById('hint-too-many-colleges');
  const hintNoResults = document.getElementById('hint-no-colleges');
  
  if (!hintTooMany || !hintNoResults) {
    console.warn('Map hint elements not found');
    return;
  }
  
  // Don't show any hints if user hasn't actively used search controls
  if (!hasUsedSearchControls) {
    hintTooMany.classList.remove('active');
    hintNoResults.classList.remove('active');
    return;
  }
  
  // Only show hints when in nearby or route mode
  if (activeMode !== 'nearby' && activeMode !== 'route') {
    hintTooMany.classList.remove('active');
    hintNoResults.classList.remove('active');
    return;
  }
  
  const tooManyViews = getHintViewCount('tooMany');
  const noResultViews = getHintViewCount('noResults');

  const hasNonDefaultFilter = regionVal || stateVal || searchVal;
  const hasAnyFilter = typeVal || hasNonDefaultFilter;
  
  // Priority 1: No Results hint
  if (visibleCount === 0 && hasAnyFilter && noResultViews < HINT_MAX_VIEWS) {
    if (hintNoResults.dataset.active !== 'true') {
      incrementHintViewCount('noResults');
    }
    hintNoResults.dataset.active = 'true';
    hintNoResults.classList.add('active');
    hintTooMany.classList.remove('active');
    hintTooMany.dataset.active = '';
    startHintAutoHide('noResults');
    return;
  } else {
    hintNoResults.classList.remove('active');
    hintNoResults.dataset.active = '';
    clearHintAutoHide('noResults');
  }
  
  // Priority 2: Too Many Colleges hint (only if No Results is not showing)
  if (visibleCount > 30 && !typeVal && tooManyViews < 1) {
    if (hintTooMany.dataset.active !== 'true') {
      incrementHintViewCount('tooMany');
    }
    hintTooMany.dataset.active = 'true';
    hintTooMany.classList.add('active');
    startHintAutoHide('tooMany');
  } else {
    hintTooMany.classList.remove('active');
    hintTooMany.dataset.active = '';
    clearHintAutoHide('tooMany');
  }
}

/**
 * Dismiss a map hint and store in sessionStorage
 */
function dismissMapHint(type) {
  if (type === 'tooMany') {
    const hint = document.getElementById('hint-too-many-colleges');
    if (hint) {
      hint.classList.remove('active');
      hint.dataset.active = '';
    }
    clearHintAutoHide('tooMany');
  } else if (type === 'noResults') {
    const hint = document.getElementById('hint-no-colleges');
    if (hint) {
      hint.classList.remove('active');
      hint.dataset.active = '';
    }
    clearHintAutoHide('noResults');
  } else if (type === 'noSavedColleges') {
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) hint.classList.remove('active');
    // Automatically turn off Saved Only toggle and restore previous state
    if (savedOnlyMode) {
      savedOnlyMode = false;
      const savedControls = document.getElementById("saved-controls");
      if (savedControls) {
        savedControls.classList.remove("saved-only-active");
      }
      // Re-render map without saved-only filter
      if (activeMode === 'route' && route.lastSearch) {
        refilterCollegesAlongRoute();
      } else {
        render();
      }
    }
  }
}

function getHintStorageKey(type) {
  return type === 'tooMany' ? 'ucm_hintTooManyCount' : 'ucm_hintNoResultsCount';
}

function getHintViewCount(type) {
  const key = getHintStorageKey(type);
  const val = parseInt(sessionStorage.getItem(key) || '0', 10);
  return Number.isNaN(val) ? 0 : val;
}

function incrementHintViewCount(type) {
  const key = getHintStorageKey(type);
  const current = getHintViewCount(type);
  const maxViews = type === 'tooMany' ? 1 : HINT_MAX_VIEWS;
  sessionStorage.setItem(key, String(Math.min(maxViews, current + 1)));
}

function startHintAutoHide(type) {
  clearHintAutoHide(type);
  mapHintTimeouts[type] = setTimeout(() => {
    dismissMapHint(type);
  }, 60000);
}

function clearHintAutoHide(type) {
  if (mapHintTimeouts[type]) {
    clearTimeout(mapHintTimeouts[type]);
    mapHintTimeouts[type] = null;
  }
}


/**
 * Show the map tip bubble if it hasn't been seen this session
 */
function showMapTip() {
  const tipBubble = document.getElementById('map-tip-bubble');
  if (!tipBubble) return;
  
  // Check if already seen this session
  if (sessionStorage.getItem('ucm_seenTapDotHint') === '1') {
    return;
  }
  
  // Show the tip bubble
  tipBubble.classList.add('active');
  
  // Auto-hide after 15 seconds
  setTimeout(() => {
    dismissMapTip();
  }, 15000);
}

/**
 * Dismiss the map tip bubble and store in sessionStorage
 */
function dismissMapTip() {
  sessionStorage.setItem('ucm_seenTapDotHint', '1');
  const tipBubble = document.getElementById('map-tip-bubble');
  if (tipBubble) tipBubble.classList.remove('active');
}

// Saved controls functions
let savedSearchTimeout = null;
let savedSearchResults = [];
const mapHintTimeouts = {
  tooMany: null,
  noResults: null
};
const HINT_MAX_VIEWS = 3;
let routeHintShown = sessionStorage.getItem(ROUTE_HINT_KEY) === '1';
let routeHintUserInteracted = false;
let routeHintDismissTimer = null;

function openSavedListPanel() {
  const overlay = document.getElementById('saved-colleges-overlay');
  if (overlay && !overlay.classList.contains('active')) {
    overlay.classList.add('active');
    freezeMapInteractions();
    updateSavedOverlay();
    // Focus search input
    const searchInput = document.getElementById('saved-search-input');
    if (searchInput) {
      setTimeout(() => searchInput.focus(), 100);
    }
    // Track saved list opened
    if (typeof gtag !== 'undefined') {
      gtag('event', 'feature_saved_list_opened');
    }
  }
}

function closeSavedListPanel() {
  const overlay = document.getElementById('saved-colleges-overlay');
  if (overlay && overlay.classList.contains('active')) {
    overlay.classList.remove('active');
    resumeMapInteractions();
    // Clear search
    const searchInput = document.getElementById('saved-search-input');
    const searchResults = document.getElementById('saved-search-results');
    if (searchInput) searchInput.value = '';
    if (searchResults) {
      searchResults.classList.remove('active');
      searchResults.innerHTML = '';
    }
  }
}

function updateSavedOverlay() {
  const savedIds = SavedStore.getAll();
  const countEl = document.getElementById('saved-overlay-count');
  const listEl = document.getElementById('saved-colleges-list');
  const unsaveAllBtn = document.getElementById('unsave-all-btn');
  
  if (countEl) {
    countEl.textContent = `${savedIds.length} Colleges Saved`;
  }
  
  if (unsaveAllBtn) {
    unsaveAllBtn.style.display = savedIds.length > 0 ? 'block' : 'none';
  }
  
  if (listEl) {
    if (savedIds.length === 0) {
      listEl.innerHTML = `
        <div class="saved-empty-state">
          <div class="saved-empty-state-title">You haven't saved any colleges yet.</div>
          <div class="saved-empty-state-text">Tap a college on the map or use search above to start a saved list.</div>
        </div>
      `;
    } else {
      listEl.innerHTML = savedIds.map(collegeId => {
        const college = collegesById[collegeId];
        if (!college) return '';
        const typeDisplay = college.type || 'Unknown';
        return `
          <div class="saved-college-item" data-college-id="${collegeId}">
            <div class="saved-college-info">
              <div class="saved-college-name">${escapeHtml(college.name)}</div>
              <div class="saved-college-details">${college.state} · ${escapeHtml(typeDisplay)}</div>
            </div>
            <button class="saved-college-unsave-btn" onclick="unsaveCollegeFromOverlay('${collegeId}')">
              <span style="color: #16a34a;">★</span> Saved
            </button>
          </div>
        `;
      }).join('');
    }
  }
}

function setupRouteHint() {
  const routeHint = document.getElementById('route-hint-bubble');
  const startInput = elements.routeStart;
  const endInput = elements.routeEnd;
  if (!routeHint || !startInput || !endInput || routeHintShown) return;

  const handleEvent = (event) => {
    if (routeHintShown) return;
    if (event && (event.type === 'input' || event.type === 'change')) {
      routeHintUserInteracted = true;
    }
    const force = event ? event.type === 'blur' : false;
    maybeShowRouteHint(force);
  };

  ['input', 'change', 'blur'].forEach(evtName => {
    startInput.addEventListener(evtName, handleEvent);
    endInput.addEventListener(evtName, handleEvent);
  });
}

function maybeShowRouteHint(force = false) {
  if (routeHintShown) return;
  const startFilled = !!(elements.routeStart && elements.routeStart.value.trim());
  const endFilled = !!(elements.routeEnd && elements.routeEnd.value.trim());
  if (!startFilled || !endFilled) return;
  if (!routeHintUserInteracted && !force) return;
  showRouteHintBubble();
}

function notifyRouteInputsUpdated(forceUserInteraction = false) {
  if (forceUserInteraction) {
    routeHintUserInteracted = true;
  }
  maybeShowRouteHint(forceUserInteraction);
}

function showRouteHintBubble() {
  const routeHint = document.getElementById('route-hint-bubble');
  const exploreBtn = elements.findRouteBtn;
  if (!routeHint || !exploreBtn || routeHintShown) return;

  routeHint.style.display = 'block';
  routeHint.style.visibility = 'hidden';
  routeHint.classList.remove('visible');
  routeHint.classList.remove('below');

  const buttonRect = exploreBtn.getBoundingClientRect();
  const headerRect = document.querySelector('.app-header')?.getBoundingClientRect();
  const bubbleRect = routeHint.getBoundingClientRect();
  const minTop = headerRect ? headerRect.bottom + 8 : 12;
  let placeBelow = false;
  let top = buttonRect.top - bubbleRect.height - 8;
  if (top < minTop) {
    top = Math.max(buttonRect.bottom + 8, minTop);
    placeBelow = true;
  }
  if (placeBelow) {
    routeHint.classList.add('below');
  }
  let left = buttonRect.left + (buttonRect.width / 2) - (bubbleRect.width / 2);
  const maxLeft = window.innerWidth - bubbleRect.width - 12;
  left = Math.min(Math.max(12, left), maxLeft);

  routeHint.style.top = `${top}px`;
  routeHint.style.left = `${left}px`;
  routeHint.style.visibility = 'visible';

  requestAnimationFrame(() => {
    routeHint.classList.add('visible');
  });

  if (routeHintDismissTimer) {
    clearTimeout(routeHintDismissTimer);
    routeHintDismissTimer = null;
  }
  routeHint.onclick = () => dismissRouteHint();
  routeHintDismissTimer = setTimeout(() => dismissRouteHint(), 5000);
  routeHintShown = true;
  sessionStorage.setItem(ROUTE_HINT_KEY, '1');
}

function dismissRouteHint() {
  const routeHint = document.getElementById('route-hint-bubble');
  if (!routeHint) return;
  routeHint.onclick = null;
  routeHint.classList.remove('visible');
  if (routeHintDismissTimer) {
    clearTimeout(routeHintDismissTimer);
    routeHintDismissTimer = null;
  }
  setTimeout(() => {
    routeHint.style.display = 'none';
    routeHint.style.visibility = '';
  }, 200);
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Search functionality
function initSavedSearch() {
  const searchInput = document.getElementById('saved-search-input');
  if (!searchInput) return;
  
  searchInput.addEventListener('input', (e) => {
    const query = (e.target.value || '').trim().toLowerCase();
    const resultsEl = document.getElementById('saved-search-results');
    
    if (!resultsEl) return;
    
    // Clear previous timeout
    if (savedSearchTimeout) {
      clearTimeout(savedSearchTimeout);
    }
    
    if (query.length < 2) {
      resultsEl.classList.remove('active');
      resultsEl.innerHTML = '';
      return;
    }
    
    // Debounce search
    savedSearchTimeout = setTimeout(() => {
      const queryLower = query.toLowerCase();
      const queryWords = queryLower.split(/\s+/).filter(w => w.length > 0);
      
      // Score and filter colleges
      const scored = colleges.map(college => {
        if (!college.name) return null;
        const nameLower = college.name.toLowerCase();
        
        // Perfect match (exact)
        if (nameLower === queryLower) {
          return { college, score: 1000, matchType: 'exact' };
        }
        
        // Starts with query
        if (nameLower.startsWith(queryLower)) {
          return { college, score: 500, matchType: 'starts' };
        }
        
        // Contains query as substring
        if (nameLower.includes(queryLower)) {
          return { college, score: 300, matchType: 'contains' };
        }
        
        // Word-based matching
        const nameWords = nameLower.split(/\s+/);
        let wordMatches = 0;
        let allWordsMatch = true;
        
        for (const queryWord of queryWords) {
          let wordMatched = false;
          for (const nameWord of nameWords) {
            if (nameWord.startsWith(queryWord)) {
              wordMatches += 2; // Word starts with query word
              wordMatched = true;
              break;
            } else if (nameWord.includes(queryWord)) {
              wordMatches += 1; // Word contains query word
              wordMatched = true;
              break;
            }
          }
          if (!wordMatched) {
            allWordsMatch = false;
          }
        }
        
        if (wordMatches > 0) {
          const score = allWordsMatch ? 200 + wordMatches : 100 + wordMatches;
          return { college, score, matchType: 'words' };
        }
        
        return null;
      }).filter(item => item !== null);
      
      // Sort by score (highest first), then alphabetically
      scored.sort((a, b) => {
        if (b.score !== a.score) {
          return b.score - a.score;
        }
        return a.college.name.localeCompare(b.college.name);
      });
      
      const matches = scored.slice(0, 10).map(item => item.college);
      
      if (matches.length === 0) {
        resultsEl.classList.remove('active');
        resultsEl.innerHTML = '';
        return;
      }
      
      resultsEl.innerHTML = matches.map(college => {
        const isSaved = SavedStore.isSaved(college.college_id);
        const typeDisplay = college.type || 'Unknown';
        const collegeIdEscaped = escapeHtml(college.college_id);
        return `
          <div class="saved-search-result-item" data-college-id="${collegeIdEscaped}">
            <div class="saved-search-result-info">
              <div class="saved-search-result-name">${escapeHtml(college.name)}</div>
              <div class="saved-search-result-details">${college.state} · ${escapeHtml(typeDisplay)}</div>
            </div>
            <button class="saved-search-result-save-btn ${isSaved ? 'saved' : ''}" 
                    data-college-id="${collegeIdEscaped}"
                    onclick="saveCollegeFromSearch('${collegeIdEscaped.replace(/'/g, "\\'")}')">
              <span style="color: ${isSaved ? '#16a34a' : '#64748b'}; display: inline-block; width: 12px; text-align: center; line-height: 1;">${isSaved ? '★' : '☆'}</span>
              ${isSaved ? 'Saved' : 'Save'}
            </button>
          </div>
        `;
      }).join('');
      
      resultsEl.classList.add('active');
      resultsEl.scrollTop = 0; // Reset scroll to top
      savedSearchResults = matches;
    }, 200);
  });
  
  // Close results when clicking outside
  document.addEventListener('click', (e) => {
    const searchInput = document.getElementById('saved-search-input');
    if (!searchInput) return;
    const searchWrapper = searchInput.closest('.saved-search-wrapper');
    if (searchWrapper && !searchWrapper.contains(e.target)) {
      const resultsEl = document.getElementById('saved-search-results');
      if (resultsEl) {
        resultsEl.classList.remove('active');
      }
    }
  });
}

function saveCollegeFromSearch(collegeId) {
  if (!collegeId) return;
  
  SavedStore.toggle(collegeId);
  updateMarkerIcon(collegeId);
  updateSavedOverlay();
  
  // Update search result button using data attribute
  const resultsEl = document.getElementById('saved-search-results');
  if (resultsEl) {
    const btn = resultsEl.querySelector(`button[data-college-id="${collegeId}"]`);
    if (btn) {
      const isSaved = SavedStore.isSaved(collegeId);
      if (isSaved) {
        btn.classList.add('saved');
      } else {
        btn.classList.remove('saved');
      }
      btn.innerHTML = `
        <span style="color: ${isSaved ? '#16a34a' : '#64748b'}; display: inline-block; width: 12px; text-align: center; line-height: 1;">${isSaved ? '★' : '☆'}</span>
        ${isSaved ? 'Saved' : 'Save'}
      `;
    }
  }
  
  // Re-render if saved-only mode is on
  if (savedOnlyMode) {
    if (activeMode === 'route' && route.lastSearch) {
      refilterCollegesAlongRoute();
    } else {
      render();
    }
  }
}

function getSavedOverlayItem(collegeId) {
  if (!collegeId) return null;
  const selector = '.saved-college-item[data-college-id="%s"]';
  if (window.CSS && CSS.escape) {
    return document.querySelector(selector.replace('%s', CSS.escape(collegeId)));
  }
  return document.querySelector(selector.replace('%s', collegeId.replace(/"/g, '\\"')));
}

function unsaveCollegeFromOverlay(collegeId) {
  if (!collegeId) return;
  
  const listItem = getSavedOverlayItem(collegeId);
  if (listItem) {
    listItem.classList.add('removing');
  }
  
  const finalize = () => {
    SavedStore.toggle(collegeId);
    updateMarkerIcon(collegeId);
    updateSavedOverlay();
    
    if (savedOnlyMode) {
      if (activeMode === 'route' && route.lastSearch) {
        refilterCollegesAlongRoute();
      } else {
        render();
      }
    }
  };
  
  if (listItem) {
    setTimeout(finalize, 260);
  } else {
    finalize();
  }
}

function updateMarkerIcon(collegeId) {
  const marker = markersByCollegeId[collegeId];
  if (!marker) return;
  
  const isSaved = SavedStore.isSaved(collegeId);
  const latlng = marker.getLatLng();
  const popup = marker.getPopup();
  const tooltip = marker.getTooltip();
  const popupContent = popup ? popup.getContent() : '';
  const tooltipContent = tooltip ? tooltip.getContent() : '';
  const wasPopupOpen = popup && marker.isPopupOpen();
  
  marker.remove();
  
  let newMarker;
  if (isSaved) {
    // Use green pin icon for saved colleges with dynamic sizing
    const iconSize = getCurrentSavedIconSize();
    newMarker = L.marker(latlng, { icon: createGreenSavedIcon(iconSize) });
  } else {
    // Use dynamic radius for touch devices
    const radius = getCurrentMarkerRadius();
    newMarker = L.circleMarker(latlng, { radius: radius, color: '#2563eb', weight: 2, fillOpacity: 0.7 });
  }
  
  if (popupContent) newMarker.bindPopup(popupContent);
  if (tooltipContent) newMarker.bindTooltip(tooltipContent, {permanent: false, direction: 'top'});
  newMarker.addTo(markersLayer);
  markersByCollegeId[collegeId] = newMarker;
  
  if (wasPopupOpen) {
    newMarker.openPopup();
  }
}

function confirmUnsaveAll() {
  const modal = document.getElementById('unsave-all-modal');
  if (modal) {
    modal.classList.add('active');
  }
}

function closeUnsaveAllModal() {
  const modal = document.getElementById('unsave-all-modal');
  if (modal) {
    modal.classList.remove('active');
  }
}

function unsaveAllColleges() {
  const savedIds = SavedStore.getAll();
  
  savedIds.forEach(collegeId => {
    SavedStore.toggle(collegeId);
    updateMarkerIcon(collegeId);
  });
  
  closeUnsaveAllModal();
  updateSavedOverlay();
  
  // Re-render if saved-only mode is on
  if (savedOnlyMode) {
    if (activeMode === 'route' && route.lastSearch) {
      refilterCollegesAlongRoute();
    } else {
      render();
    }
  }
}

let savedOnlyMode = false;
function toggleSavedOnly() {
  savedOnlyMode = !savedOnlyMode;
  const savedControls = document.getElementById("saved-controls");
  if (savedControls) {
    savedControls.classList.toggle("saved-only-active", savedOnlyMode);
  }
  console.log("Saved Only:", savedOnlyMode);
  // Track saved only toggle
  if (typeof gtag !== 'undefined') {
    gtag('event', 'feature_saved_only_toggled');
  }
  
  // Check if Saved Only is turned ON and there are no saved colleges
  if (savedOnlyMode) {
    const savedIds = SavedStore.getAll();
    if (savedIds.length === 0) {
      // Show notice that there are no saved colleges yet
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) {
        hint.classList.add('active');
        // Auto-dismiss after 8 seconds and turn off toggle
        setTimeout(() => {
          if (hint) {
            hint.classList.remove('active');
            // Automatically turn off Saved Only toggle and restore previous state
            if (savedOnlyMode) {
              savedOnlyMode = false;
              const savedControls = document.getElementById("saved-controls");
              if (savedControls) {
                savedControls.classList.remove("saved-only-active");
              }
              // Re-render map without saved-only filter
              if (activeMode === 'route' && route.lastSearch) {
                refilterCollegesAlongRoute();
              } else {
                render();
              }
            }
          }
        }, 8000);
      }
    } else {
      // Hide the notice if it was showing
      const hint = document.getElementById('hint-no-saved-colleges');
      if (hint) hint.classList.remove('active');
    }
  } else {
    // Hide the notice when Saved Only is turned OFF
    const hint = document.getElementById('hint-no-saved-colleges');
    if (hint) hint.classList.remove('active');
  }
  
  // Re-render map with saved-only filter
  if (activeMode === 'route' && route.lastSearch) {
    // Use cached route data to avoid redrawing the route line
    refilterCollegesAlongRoute();
  } else {
    render();
  }
}

function isLocalStorageAvailable() {
  try {
    const testKey = '__ucm_storage_test__';
    localStorage.setItem(testKey, '1');
    localStorage.removeItem(testKey);
    return true;
  } catch (e) {
    console.warn('localStorage unavailable:', e);
    return false;
  }
}

function parseCollegesCSV(csvText, sourceLabel = 'network') {
  return new Promise((resolve, reject) => {
    Papa.parse(csvText, {
      header: true,
      dynamicTyping: true,
      complete: (results) => {
        if (results.errors && results.errors.length) {
          console.warn(`CSV parsing warnings from ${sourceLabel}:`, results.errors);
        }
        if (!results.data || !results.data.length) {
          reject(new Error('No data rows in CSV'));
          return;
        }
        console.log(`CSV parsing complete from ${sourceLabel}. Rows:`, results.data.length);
        resolve(results.data);
      },
      error: (error) => {
        reject(error);
      }
    });
  });
}

function loadCSV(url){
  if (elements.loading) elements.loading.classList.add('active');
  
  const canUseStorage = isLocalStorageAvailable();
  let cachedCSV = null;
  let cacheLoaded = false;
  
  const handleDataLoad = (data) => {
    processCollegesData(data);
    cacheLoaded = true;
    if (elements.loading) elements.loading.classList.remove('active');
  };
  
  if (canUseStorage) {
    try {
      cachedCSV = localStorage.getItem(COLLEGE_CACHE_KEY);
      if (cachedCSV) {
        parseCollegesCSV(cachedCSV, 'cache')
          .then(handleDataLoad)
          .catch(err => {
            console.warn('Failed to parse cached CSV:', err);
          });
      }
    } catch (e) {
      console.warn('Unable to read cached CSV:', e);
    }
  }
  
  fetch(url, { cache: 'no-cache' })
    .then(response => {
      if (!response.ok) {
        throw new Error(`Network response not ok (${response.status})`);
      }
      return response.text();
    })
    .then(csvText => {
      const cachedMatches = cachedCSV && csvText === cachedCSV;
      const shouldProcess = !cachedMatches || !cacheLoaded;
      const parseLabel = cachedMatches ? 'network-sync' : (cachedCSV ? 'network-refresh' : 'network');
      
      if (canUseStorage) {
        try {
          if (!cachedMatches) {
            localStorage.setItem(COLLEGE_CACHE_KEY, csvText);
          }
        } catch (e) {
          console.warn('Failed to cache CSV text:', e);
        }
      }
      
      if (shouldProcess) {
        return parseCollegesCSV(csvText, parseLabel)
          .then(handleDataLoad);
      }
    })
    .catch(error => {
      console.error('CSV fetch error:', error);
      if (!cacheLoaded) {
        if (elements.loading) elements.loading.classList.remove('active');
        showError('Error loading colleges data: ' + (error.message || 'Unknown error'));
      } else {
        console.warn('Using cached CSV due to fetch error.');
      }
    });
}

/**
 * Generate a stable fallback college_id for rows missing one.
 */
function buildFallbackCollegeId(row) {
  const safeName = (row.name || 'college')
    .toString()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '') || 'college';
  const state = (row.state || 'XX').toString().toUpperCase();
  const lat = Number(row.lat);
  const lon = Number(row.lon);
  const latStr = Number.isFinite(lat) ? lat.toFixed(3) : '0.000';
  const lonStr = Number.isFinite(lon) ? lon.toFixed(3) : '0.000';
  return `${safeName}_${state}_${latStr}_${lonStr}`;
}

/**
 * Process CSV data and map to internal college objects.
 * 
 * REQUIRED CSV COLUMNS (for creating a "slim" CSV):
 * - name: College name (used in search, popups, tooltips)
 * - lat: Latitude (required for map markers, radius/route filtering)
 * - lon: Longitude (required for map markers, radius/route filtering)
 * - state: State code (used in state filter, region filter, popups)
 * - type: College type (used in type filter dropdown, popups, TYPE_ORDER ranking)
 * - tier: Alternative type field (used as fallback in type filter: c.type || c.tier)
 * - control: Control type (used in popups: "Public | Private")
 * - acceptance: Acceptance rate (used in popups)
 * - enrollment: Enrollment number (used in popups)
 * - tuition: Tuition cost (used in popups)
 * - url: College website URL (used in popups as clickable link)
 * 
 * All other CSV columns can be removed to reduce payload size.
 */
// Lookup object: college_id -> college object
let collegesById = {};

function processCollegesData(data) {
  colleges = data.filter(r => r.name && r.lat && r.lon).map(r => {
    const rawId = (r.college_id || '').toString().trim();
    const collegeId = rawId || buildFallbackCollegeId(r);
    return {
      college_id: collegeId,
      name: r.name,
      lat: +r.lat,
      lon: +r.lon,
      state: (r.state || '').toUpperCase(),
      type: r.type || 'Unknown',
      tier: r.tier || '', // Used as fallback in type filter: (c.type || c.tier)
      control: r.control || '',
      acceptance: r.acceptance || '',
      enrollment: r.enrollment || '',
      tuition: r.tuition || '',
      url: r.url || ''
    };
  });
  
  // Build collegesById lookup
  collegesById = {};
  colleges.forEach(c => {
    if (c.college_id) {
      collegesById[c.college_id] = c;
    }
  });
  
  console.log(`Loaded ${colleges.length} colleges`);
  
  if (colleges.length === 0) {
    showError('No college data found. Please check the CSV file.');
    return;
  }
  
  const states = [...new Set(colleges.map(c => c.state))].sort();
  const types = [...new Set(colleges.map(c => c.type))].filter(Boolean);
  const ranked = [...TYPE_ORDER.filter(t => types.includes(t))];
  const leftovers = types.filter(t => !TYPE_ORDER.includes(t)).sort();
  const orderedTypes = ranked.concat(leftovers);
  
  refreshDropdown('state', states, 'All states');
  refreshDropdown('type', orderedTypes, 'All college types');
  refreshDropdown('region', ['Northeast', 'Midwest', 'South', 'West', 'Territories'], 'All regions');
  
  // Ensure we're in nearby mode on initial load (default section is open)
  activeMode = 'nearby';
  
  // Render colleges on initial load
    render();
  
  // Show the tip bubble after map is ready (only once per session)
  setTimeout(() => {
    showMapTip();
  }, 500);
}

function geocodeAddress(address, mode = 'nearby'){
  if(!address) {
    if (mode === 'nearby') {
      showError('Please enter an address');
    }
    return Promise.resolve(null);
  }
  
  // Only update map if in the correct active mode
  const shouldUpdateMap = (mode === 'nearby' && activeMode === 'nearby') || (mode === 'route' && activeMode === 'route');
  
  if (mode === 'nearby') {
    closeAutocomplete();
  }
  if (shouldUpdateMap && elements.loading) {
    elements.loading.classList.add('active');
  }
  
  // Note: Address geocoding is independent of state filter - it does not modify state/region/type filters
  // Rate limiting: Nominatim requires a User-Agent and has strict rate limits
  return fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`, {
    headers: {
      'User-Agent': 'USCollegeMap/1.0'
    }
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (shouldUpdateMap && elements.loading) {
        elements.loading.classList.remove('active');
      }
      
      if (data && data[0]) {
        const lat = +data[0].lat;
        const lon = +data[0].lon;
        
        if (mode === 'nearby') {
          // Store in nearby state
          home = { lat, lon };
          nearbyState.home = { lat, lon };
          nearbyState.address = address;
          nearbyState.radius = elements.radius ? elements.radius.value : '30';
          nearbyState.units = elements.units ? elements.units.value : 'mi';
          
          // Only update map if nearby mode is active
          if (activeMode === 'nearby') {
        homeLayer.clearLayers();
            radiusLayer.clearLayers();
            
            // Add "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([lat, lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
            
            map.setView([lat, lon], 8);
            render(); // Re-render to apply radius filter
            // Track nearby search completion
            if (typeof gtag !== 'undefined') {
              gtag('event', 'feature_nearby_used');
            }
          }
          saveSharedLocation(address, lat, lon);
          saveRecent(RECENT_STORAGE_KEYS.nearby, address);
          return { lat, lon };
        } else if (mode === 'route') {
          // Return for route mode (caller will store it)
          saveSharedLocation(address, lat, lon);
          return { lat, lon, description: address };
        }
      } else {
        if (shouldUpdateMap) {
          showError('Address not found. Please try a different address.');
        }
        return null;
      }
    })
    .catch(error => {
      if (shouldUpdateMap && elements.loading) {
        elements.loading.classList.remove('active');
        showError('Error geocoding address: ' + (error.message || 'Please try again later'));
        console.error('Geocoding error:', error);
      }
      return null;
    });
}

// Address autocomplete functions
function searchAddresses(query) {
  if (!query || query.length < 3) {
    if (!showAddressRecentsIfEligible()) {
      closeAutocomplete();
    }
    return;
  }
  clearRecentState(elements.addressSuggestions);
  
  // Cancel previous request if any
  if (addressAutocomplete.abortController) {
    addressAutocomplete.abortController.abort();
  }
  
  // Show loading state
  addressAutocomplete.suggestions = [];
  addressAutocomplete.selectedIndex = -1;
  elements.addressSuggestions.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
  elements.addressSuggestions.classList.add('active');
  addressAutocomplete.isOpen = true;
  
  // Create new abort controller
  addressAutocomplete.abortController = new AbortController();
  
  // URL encoding prevents XSS and handles special characters
  const sanitizedQuery = query.trim().substring(0, 200); // Limit query length
  
  // Use Cloudflare proxy for Google Places Autocomplete API
  fetch(`https://cold-bread-f865.cannahere2007.workers.dev/?input=${encodeURIComponent(sanitizedQuery)}`, {
    signal: addressAutocomplete.abortController.signal
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      // Handle empty array or invalid response
      if (!Array.isArray(data) || data.length === 0) {
        addressAutocomplete.suggestions = [];
        renderSuggestions();
        return;
      }
      
      // Google Places API already returns well-ranked results
      // Map the response to our format, keeping up to 5 results
      const results = data.slice(0, 5).map(item => ({
        description: item.description || '',
        place_id: item.place_id || '',
        matchedQuery: query
      }));
      
      addressAutocomplete.suggestions = results;
      renderSuggestions();
    })
    .catch(error => {
      if (error.name === 'AbortError') {
        return; // Request was cancelled, ignore
      }
      console.error('Autocomplete error:', error);
      elements.addressSuggestions.innerHTML = '<div class="autocomplete-empty" style="color:#d93025;">Unable to load suggestions. Please try again.</div>';
    });
}

function formatAddressName(displayName, query = '') {
  // Clean up the display name - remove awkward commas after street numbers
  let cleanedName = displayName.replace(/(\d+),\s+/g, '$1 '); // "25, " becomes "25 "
  
  const parts = cleanedName.split(',').map(p => p.trim()).filter(p => p);
  let primary, secondary;
  
  // Format like Google Maps: primary address on first line, location details on second
  if (parts.length >= 3) {
    // Full address: "Street Address, City, State, Country"
    // Primary: Street Address (first part)
    // Secondary: City, State, Country (remaining parts)
    primary = parts[0];
    secondary = parts.slice(1).join(', ');
  } else if (parts.length === 2) {
    // Two parts: check if first is just a number
    if (/^\d+$/.test(parts[0])) {
      // If "25, Location" -> combine to "25 Location"
      primary = parts.join(' ');
      secondary = '';
    } else {
      // "Street, City" -> Primary: Street, Secondary: City
      primary = parts[0];
      secondary = parts[1];
    }
  } else {
    // Single part
    primary = cleanedName;
    secondary = '';
  }
  
  // Escape HTML first, then apply highlighting
  // This is simpler and safer - we'll find matches in escaped text
  const escapeHtml = (text) => text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  
  // Escape the text first
  let escapedPrimary = escapeHtml(primary);
  secondary = escapeHtml(secondary);
  
  // Now apply highlighting on the escaped text
  if (query && query.length >= 2) {
    const queryLower = query.toLowerCase().trim();
    const escapedQueryLower = escapeHtml(query).toLowerCase();
    const escapedPrimaryLower = escapedPrimary.toLowerCase();
    const matchIndex = escapedPrimaryLower.indexOf(escapedQueryLower);
    
    if (matchIndex !== -1) {
      const before = escapedPrimary.substring(0, matchIndex);
      const match = escapedPrimary.substring(matchIndex, matchIndex + escapeHtml(query).length);
      const after = escapedPrimary.substring(matchIndex + escapeHtml(query).length);
      escapedPrimary = `${before}<strong>${match}</strong>${after}`;
    }
  }
  
  primary = escapedPrimary;
  
  return { primary, secondary };
}

function getAddressTypeIcon(type) {
  // Determine icon based on address type
  const icons = {
    'place': '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>',
    'house': '<path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>',
    'default': '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>'
  };
  
  const addressType = (type || '').toLowerCase();
  if (addressType.includes('house') || addressType.includes('building') || addressType.includes('residential')) {
    return icons.house;
  }
  if (addressType.includes('place') || addressType.includes('point')) {
    return icons.place;
  }
  return icons.default;
}

function renderSuggestions() {
  clearRecentState(elements.addressSuggestions);
  const queryValue = (elements.address?.value || '').trim();
  const unifiedSection = buildUnifiedRecentSection(getFallbackRecentsForField('address'), {
    query: queryValue,
    filterShared: true,
    filterFallback: true
  });
  if (addressAutocomplete.suggestions.length === 0) {
    const emptyHtml = '<div class="autocomplete-empty" role="option">No suggestions found</div>';
    elements.addressSuggestions.innerHTML = unifiedSection ? unifiedSection + emptyHtml : emptyHtml;
    return;
  }
  
  const html = addressAutocomplete.suggestions.map((item, index) => {
    const isSelected = index === addressAutocomplete.selectedIndex;
    const query = item.matchedQuery || '';
    const formatted = formatAddressName(item.description, query);
    
    // formatAddressName already escapes HTML and handles <strong> tags
    const safePrimary = formatted.primary;
    const safeSecondary = formatted.secondary;
    const safeFullName = item.description.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;');
    
    // Get icon - Google Places API doesn't provide type in autocomplete, use default
    const iconPath = getAddressTypeIcon('place');
    
    return `
      <div class="autocomplete-item ${isSelected ? 'highlighted' : ''}" 
           role="option"
           id="suggestion-${index}"
           aria-selected="${isSelected}"
           tabindex="${isSelected ? '0' : '-1'}"
           data-index="${index}">
        <div class="autocomplete-item-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            ${iconPath}
          </svg>
        </div>
        <div class="autocomplete-item-content">
          <div class="address-name">${safePrimary}</div>
          ${safeSecondary ? `<div class="address-details">${safeSecondary}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  elements.addressSuggestions.innerHTML = unifiedSection + html;
  elements.address.setAttribute('aria-expanded', 'true');
  
  // Add mouseenter handlers for highlighting
  elements.addressSuggestions.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    // Ensure item is properly clickable
    item.style.pointerEvents = 'auto';
    item.style.cursor = 'pointer';
    
    // Add direct click handler - this is the primary method
    const handleClick = (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      e.stopPropagation();
      selectSuggestion(index);
      return false;
    };
    
    item.addEventListener('click', handleClick, true);
    item.addEventListener('mousedown', (e) => {
      e.preventDefault(); // Prevent input blur
    });
    
    // Update highlight without re-rendering - just update classes
    item.addEventListener('mouseenter', () => {
      addressAutocomplete.selectedIndex = index;
      updateHighlight();
    });
    
    // Also handle touch events for mobile
    item.addEventListener('touchend', handleClick, { passive: false, capture: true });
  });
}

function selectSuggestion(index) {
  if (!addressAutocomplete.suggestions || !addressAutocomplete.suggestions[index]) {
    console.warn('No suggestion at index:', index, 'Available:', addressAutocomplete.suggestions.length);
    return;
  }
  
  const suggestion = addressAutocomplete.suggestions[index];
  const description = suggestion.description || '';
  
  if (!description) {
    console.warn('No description found for suggestion at index:', index);
    return;
  }
  
  // Mark that we're programmatically setting the value (prevents triggering new search)
  addressAutocomplete.isSelecting = true;
  
  // Close dropdown FIRST - instant visual feedback
  closeAutocomplete();
  
  // Set the input value immediately - user sees it instantly
  elements.address.value = description;
  saveRecent(RECENT_STORAGE_KEYS.nearby, description);
  
  // Clear the flag after a brief delay to allow the value to be set
  setTimeout(() => {
    addressAutocomplete.isSelecting = false;
  }, 100);
  
  // Geocode the address to update the map (this happens asynchronously)
  // Always geocode and show pin if we're in nearby mode
  // Also check if the nearby section is open (even if activeMode hasn't been set yet)
  const nearbySection = document.querySelector('details.filter-section[open] summary');
  const isNearbySectionOpen = nearbySection && nearbySection.textContent.trim().includes('Find Colleges Nearby');
  
  if (activeMode === 'nearby' || isNearbySectionOpen) {
    // Ensure activeMode is set to nearby if section is open
    if (isNearbySectionOpen && activeMode !== 'nearby') {
      activeMode = 'nearby';
    }
    geocodeAddress(description, 'nearby');
  } else {
    // Store the address value but don't update map if in route mode
    nearbyState.address = description;
  }
}

function closeAutocomplete() {
  clearRecentState(elements.addressSuggestions);
  elements.addressSuggestions.classList.remove('active');
  elements.address.setAttribute('aria-expanded', 'false');
  addressAutocomplete.isOpen = false;
  addressAutocomplete.selectedIndex = -1;
}

function updateHighlight() {
  // Update highlight without re-rendering - just update classes
  elements.addressSuggestions.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    if (index === addressAutocomplete.selectedIndex) {
      item.classList.add('highlighted');
      item.setAttribute('aria-selected', 'true');
      item.setAttribute('tabindex', '0');
    } else {
      item.classList.remove('highlighted');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('tabindex', '-1');
    }
  });
}

function handleAutocompleteKeydown(e) {
  if (!addressAutocomplete.isOpen || addressAutocomplete.suggestions.length === 0) {
    if (e.key === 'Enter') {
      e.preventDefault();
      geocodeAddress(elements.address.value);
    }
    return;
  }
  
  switch(e.key) {
    case 'ArrowDown':
      e.preventDefault();
      addressAutocomplete.selectedIndex = Math.min(
        addressAutocomplete.selectedIndex + 1,
        addressAutocomplete.suggestions.length - 1
      );
      updateHighlight();
      scrollToSelected();
      break;
      
    case 'ArrowUp':
      e.preventDefault();
      addressAutocomplete.selectedIndex = Math.max(addressAutocomplete.selectedIndex - 1, -1);
      updateHighlight();
      scrollToSelected();
      break;
      
    case 'Enter':
      e.preventDefault();
      if (addressAutocomplete.selectedIndex >= 0) {
        selectSuggestion(addressAutocomplete.selectedIndex);
      } else {
        geocodeAddress(elements.address.value);
      }
      break;
      
    case 'Escape':
      e.preventDefault();
      closeAutocomplete();
      break;
  }
}

function scrollToSelected() {
  const selected = elements.addressSuggestions.querySelector('.autocomplete-item.highlighted');
  if (selected) {
    selected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

// Route autocomplete functions (similar to address autocomplete but for route fields)
function searchRouteAddresses(query, autocompleteObj, inputElement, suggestionsContainer) {
  const storageKey = inputElement && inputElement.id === 'routeStart' ? RECENT_STORAGE_KEYS.routeStart : RECENT_STORAGE_KEYS.routeEnd;
  const context = inputElement && inputElement.id === 'routeStart' ? 'routeStart' : 'routeEnd';
  if (!query || query.length < 3) {
    if (!showRouteRecentsIfEligible(inputElement, suggestionsContainer, autocompleteObj, storageKey, context)) {
      closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement);
    }
    return;
  }
  clearRecentState(suggestionsContainer);
  
  if (autocompleteObj.abortController) {
    autocompleteObj.abortController.abort();
  }
  
  autocompleteObj.suggestions = [];
  autocompleteObj.selectedIndex = -1;
  suggestionsContainer.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
  suggestionsContainer.classList.add('active');
  autocompleteObj.isOpen = true;
  
  autocompleteObj.abortController = new AbortController();
  const sanitizedQuery = query.trim().substring(0, 200);
  
  fetch(`https://cold-bread-f865.cannahere2007.workers.dev/?input=${encodeURIComponent(sanitizedQuery)}`, {
    signal: autocompleteObj.abortController.signal
  })
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (!data || !Array.isArray(data) || data.length === 0) {
        autocompleteObj.suggestions = [];
        renderRouteSuggestions(autocompleteObj, suggestionsContainer);
        return;
      }
      
      const results = data.slice(0, 5).map(item => ({
        description: item.description || '',
        place_id: item.place_id || ''
      }));
      
      autocompleteObj.suggestions = results;
      renderRouteSuggestions(autocompleteObj, suggestionsContainer, inputElement);
    })
    .catch(error => {
      if (error.name !== 'AbortError') {
        console.error('Route autocomplete error:', error);
        autocompleteObj.suggestions = [];
        if (suggestionsContainer) {
          suggestionsContainer.innerHTML = '<div class="autocomplete-empty" style="color:#d93025;">Unable to load suggestions. Please try again.</div>';
        }
      }
    });
}

function renderRouteSuggestions(autocompleteObj, suggestionsContainer, inputElement) {
  clearRecentState(suggestionsContainer);
  const fieldId = (inputElement && inputElement.id === 'routeEnd') ? 'routeEnd' :
                  (inputElement && inputElement.id === 'routeStart') ? 'routeStart' :
                  (suggestionsContainer && suggestionsContainer.dataset.field) || '';
  const queryValue = (inputElement?.value || '').trim();
  const unifiedSection = buildUnifiedRecentSection(getFallbackRecentsForField(fieldId), {
    query: queryValue,
    filterShared: true,
    filterFallback: true
  });
  if (autocompleteObj.suggestions.length === 0) {
    const emptyHtml = '<div class="autocomplete-empty" role="option">No suggestions found</div>';
    suggestionsContainer.innerHTML = unifiedSection ? unifiedSection + emptyHtml : emptyHtml;
    return;
  }
  
  // Get icon function (same as nearby autocomplete)
  const getAddressTypeIcon = (type) => {
    const icons = {
      place: '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>',
      default: '<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>'
    };
    return icons[type] || icons.default;
  };
  
  const html = autocompleteObj.suggestions.map((item, index) => {
    const isSelected = index === autocompleteObj.selectedIndex;
    const formatted = formatAddressName(item.description, '');
    const iconPath = getAddressTypeIcon('place');
    
    return `
      <div class="autocomplete-item ${isSelected ? 'highlighted' : ''}" 
           role="option" 
           aria-selected="${isSelected}" 
           tabindex="${isSelected ? '0' : '-1'}"
           data-index="${index}">
        <div class="autocomplete-item-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            ${iconPath}
          </svg>
        </div>
        <div class="autocomplete-item-content">
          <div class="address-name">${formatted.primary}</div>
          ${formatted.secondary ? `<div class="address-details">${formatted.secondary}</div>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  suggestionsContainer.innerHTML = unifiedSection + html;
  inputElement.setAttribute('aria-expanded', 'true');
  
  suggestionsContainer.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    item.style.pointerEvents = 'auto';
    item.style.cursor = 'pointer';
    
    const handleClick = (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      e.stopPropagation();
      selectRouteSuggestion(index, autocompleteObj, inputElement, suggestionsContainer);
      return false;
    };
    
    item.addEventListener('click', handleClick, true);
    item.addEventListener('mousedown', (e) => {
      e.preventDefault();
    });
    
    item.addEventListener('mouseenter', () => {
      autocompleteObj.selectedIndex = index;
      updateRouteHighlight(autocompleteObj, suggestionsContainer);
    });
    
    item.addEventListener('touchend', handleClick, { passive: false, capture: true });
  });
}

function selectRouteSuggestion(index, autocompleteObj, inputElement, suggestionsContainer) {
  if (!autocompleteObj.suggestions || !autocompleteObj.suggestions[index]) {
    return;
  }
  
  const suggestion = autocompleteObj.suggestions[index];
  const description = suggestion.description || '';
  
  if (!description) {
    return;
  }
  
  autocompleteObj.isSelecting = true;
  closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement);
  inputElement.value = description;
  notifyRouteInputsUpdated(true);
  if (inputElement.id === 'routeStart') {
    saveRecent(RECENT_STORAGE_KEYS.routeStart, description);
  } else if (inputElement.id === 'routeEnd') {
    saveRecent(RECENT_STORAGE_KEYS.routeEnd, description);
  }
  
  setTimeout(() => {
    autocompleteObj.isSelecting = false;
  }, 100);
  
  // Geocode and store in route state (but don't update map yet)
  geocodeAddress(description, 'route').then(result => {
    if (result) {
      if (inputElement.id === 'routeStart') {
        route.start = { description, lat: result.lat, lon: result.lon };
        console.log('Route start set:', route.start);
      } else if (inputElement.id === 'routeEnd') {
        route.end = { description, lat: result.lat, lon: result.lon };
        console.log('Route end set:', route.end);
      }
    } else {
      console.warn('Geocoding failed for route address:', description);
    }
  }).catch(error => {
    console.error('Error geocoding route address:', error);
  });
}

function closeRouteAutocomplete(autocompleteObj, suggestionsContainer, inputElement) {
  clearRecentState(suggestionsContainer);
  suggestionsContainer.classList.remove('active');
  inputElement.setAttribute('aria-expanded', 'false');
  autocompleteObj.isOpen = false;
  autocompleteObj.selectedIndex = -1;
}

function updateRouteHighlight(autocompleteObj, suggestionsContainer) {
  suggestionsContainer.querySelectorAll('.autocomplete-item').forEach((item, index) => {
    if (index === autocompleteObj.selectedIndex) {
      item.classList.add('highlighted');
      item.setAttribute('aria-selected', 'true');
      item.setAttribute('tabindex', '0');
    } else {
      item.classList.remove('highlighted');
      item.setAttribute('aria-selected', 'false');
      item.setAttribute('tabindex', '-1');
    }
  });
}

/**
 * LAZY LOADED: Route calculation function - only executed when route mode is first used
 * Calculate perpendicular distance from a point to a line segment (using Haversine formula)
 * Returns the shortest distance from point P to line segment AB
 * 
 * Performance: This heavy computation is only executed when user interacts with route mode
 */
function distanceToLineSegment(pointLat, pointLon, lineStartLat, lineStartLon, lineEndLat, lineEndLon, units = 'mi') {
  // Calculate distances to endpoints
  const dAP = calculateDistance(lineStartLat, lineStartLon, pointLat, pointLon, units);
  const dBP = calculateDistance(lineEndLat, lineEndLon, pointLat, pointLon, units);
  const dAB = calculateDistance(lineStartLat, lineStartLon, lineEndLat, lineEndLon, units);
  
  // If the line segment is very short, return distance to nearest endpoint
  if (dAB < 0.01) {
    return Math.min(dAP, dBP);
  }
  
  // Use the law of cosines to find the angle at point A
  // cos(angle) = (a² + c² - b²) / (2ac)
  // where a = dAP, b = dBP, c = dAB
  const cosAngle = (dAP * dAP + dAB * dAB - dBP * dBP) / (2 * dAP * dAB);
  
  // Clamp cosAngle to [-1, 1] to avoid NaN from acos
  const clampedCos = Math.max(-1, Math.min(1, cosAngle));
  const angle = Math.acos(clampedCos);
  
  // Calculate perpendicular distance using sine
  // distance = dAP * sin(angle)
  const perpendicularDist = dAP * Math.sin(angle);
  
  // Check if the perpendicular point is within the segment
  // If angle > 90 degrees, the perpendicular is beyond point A
  // If the distance along AB from A is > dAB, it's beyond point B
  const distAlongAB = dAP * Math.cos(angle);
  
  if (distAlongAB < 0 || distAlongAB > dAB) {
    // Perpendicular point is outside the segment, return distance to nearest endpoint
    return Math.min(dAP, dBP);
  }
  
  return Math.abs(perpendicularDist);
}

/**
 * LAZY LOADED: Route search function - only executed when user clicks "Find" in route mode
 * Prevents infinite loops by checking if already processing
 * 
 * Performance: Heavy OSRM API calls and distance calculations only run when:
 * - User enters start/end addresses AND clicks "Find" button
 * - NOT on initial page load
 * - NOT when just switching to route mode
 */
let isProcessingRoute = false;

function findCollegesAlongRoute() {
  // Guard against infinite loops
  if (isProcessingRoute) {
    console.log('Route already processing, skipping...');
    return;
  }
  
  if (activeMode !== 'route') {
    console.log('Not in route mode, current mode:', activeMode);
    return;
  }
  
  if (!route.start || !route.end) {
    showError('Please enter both starting and destination addresses.');
    console.log('Route start or end missing:', { start: route.start, end: route.end });
    return;
  }
  
  console.log('Starting route search...', { start: route.start, end: route.end });
  isProcessingRoute = true;
  
  const maxDistance = parseFloat(elements.routeMaxDistance?.value || '30') || 30;
  const units = elements.routeUnits ? elements.routeUnits.value : 'mi';
  
  // Store route search state
  route.lastSearch = {
    start: route.start,
    end: route.end,
    maxDistance,
    units
  };
  
  if (elements.loading) elements.loading.classList.add('active');
  
  // Clear previous route visualization
  routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
  homeLayer.clearLayers();
  radiusLayer.clearLayers();
  
  // Get actual driving route using OSRM (Open Source Routing Machine)
  // Format: lon,lat (OSRM uses lon,lat order)
  const startCoords = `${route.start.lon},${route.start.lat}`;
  const endCoords = `${route.end.lon},${route.end.lat}`;
  const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${startCoords};${endCoords}?overview=full&geometries=geojson`;
  
  fetch(osrmUrl)
    .then(r => {
      if (!r.ok) throw new Error(`Routing failed: ${r.status}`);
      return r.json();
    })
    .then(data => {
      if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
        throw new Error('No route found');
      }
      
      const routeGeometry = data.routes[0].geometry.coordinates;
      // Convert from [lon, lat] to [lat, lon] for Leaflet
      const routeCoords = routeGeometry.map(coord => [coord[1], coord[0]]);
      
      // Draw the actual driving route with ribbon effect
      const zoom = map ? map.getZoom() : 5;
      const routeWeights = calculateRouteLineWeights(zoom);
      
      // First draw the deep navy outline (thin line for ribbon effect)
      routeOutlinePolyline = L.polyline(routeCoords, {
        color: '#0A2CA5',
        weight: routeWeights.outlineWeight,
        opacity: routeWeights.outlineOpacity
      }).addTo(routeLayer);
      // Then draw the vivid royal blue main route line on top
      routeMainPolyline = L.polyline(routeCoords, {
        color: '#1A4CFF',
        weight: routeWeights.mainWeight,
        opacity: routeWeights.mainOpacity
      }).addTo(routeLayer);
      
      // Track route search completion
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_route_used');
      }
      
      // Draw start and destination markers (map pins - smaller size)
      // Start pin (white circle with black border)
      L.marker([route.start.lat, route.start.lon], {
        icon: L.icon({
          iconUrl: ROUTE_START_PIN_ICON,
          iconSize: [18, 18],
          iconAnchor: [9, 9],
          popupAnchor: [0, -9]
        })
      }).addTo(routeLayer).bindPopup('From');
      
      // Destination pin (red teardrop)
      L.marker([route.end.lat, route.end.lon], {
        icon: L.icon({
          iconUrl: ROUTE_END_PIN_ICON,
          iconSize: [24, 30],
          iconAnchor: [12, 30],
          popupAnchor: [0, -30]
        })
      }).addTo(routeLayer).bindPopup('To');
      
      // Calculate route bounds and fit map
      const polylineBounds = L.latLngBounds(routeCoords);
      let routeBounds = L.latLngBounds(routeCoords);
      
      // Filter colleges along the route using perpendicular distance
      // Sample route points to improve performance (check every 10th point for long routes)
      const sampleRate = routeCoords.length > 100 ? 10 : 1;
      const sampledRoute = [];
      for (let i = 0; i < routeCoords.length; i += sampleRate) {
        sampledRoute.push(routeCoords[i]);
      }
      // Always include the last point
      if (sampledRoute[sampledRoute.length - 1] !== routeCoords[routeCoords.length - 1]) {
        sampledRoute.push(routeCoords[routeCoords.length - 1]);
      }
      
      const filtered = colleges.filter(c => {
        // Check distance to each segment of the sampled route
        let minDistance = Infinity;
        
        for (let i = 0; i < sampledRoute.length - 1; i++) {
          const segmentStart = sampledRoute[i];
          const segmentEnd = sampledRoute[i + 1];
          
          const dist = distanceToLineSegment(
            c.lat, c.lon,
            segmentStart[0], segmentStart[1],
            segmentEnd[0], segmentEnd[1],
            units
          );
          
          minDistance = Math.min(minDistance, dist);
          
          // Early exit if we're already within range
          if (minDistance <= maxDistance) {
            break;
          }
        }
        
        return minDistance <= maxDistance;
      });
      
      // Apply other filters (type, region, state, search)
      const typeVal = elements.type ? elements.type.value.trim() : '';
      const regionVal = elements.region ? elements.region.value.trim() : '';
      const stateVal = elements.state ? elements.state.value.trim() : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      const filtersSnapshot = { typeVal, regionVal, stateVal, searchVal, maxDistance, units };
      const finalFiltered = filtered.filter(c => {
        // Type filter - check both type and tier fields
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        // Region filter - use REGION_MAP to check if state is in region
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        return true;
      });
      
      const allRouteColleges = finalFiltered.map(c => {
        let distanceText = '';
        let minRouteDist = Infinity;
        for (let i = 0; i < sampledRoute.length - 1; i++) {
          const dist = distanceToLineSegment(
            c.lat, c.lon,
            sampledRoute[i][0], sampledRoute[i][1],
            sampledRoute[i + 1][0], sampledRoute[i + 1][1],
            units
          );
          minRouteDist = Math.min(minRouteDist, dist);
        }
        if (minRouteDist < Infinity) {
          distanceText = `<br>Distance from route: ${minRouteDist.toFixed(1)} ${units}`;
        }
        return { college: c, distanceText };
      });
      allRouteColleges.forEach(item => {
        routeBounds.extend([item.college.lat, item.college.lon]);
      });
      
      const visibleRouteColleges = savedOnlyMode
        ? allRouteColleges.filter(item => SavedStore.isSaved(item.college.college_id))
        : allRouteColleges;
      
      if (visibleRouteColleges.length === 0 && savedOnlyMode) {
        const savedCount = SavedStore.getAll().length;
        if (savedCount === 0) {
          console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
        } else {
          console.log("No saved colleges match your current filters or route.");
        }
      }
      
      // Clear and render markers (using same style as nearby mode - blue circle dots)
      markersLayer.clearLayers();
      // Clear marker registry
      Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      visibleRouteColleges.forEach(item => {
        addRouteCollegeMarker(item.college, item.distanceText, units);
      });
      
      if (elements.count) elements.count.textContent = visibleRouteColleges.length;
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Update map hints for route mode
      updateMapHints(visibleRouteColleges.length, typeVal, regionVal, stateVal, searchVal);
      
      // Store route visualization for restoration
      if (routeBounds.isValid()) {
        if (visibleRouteColleges.length > 0) {
          map.fitBounds(routeBounds.pad(0.15));
        } else {
          map.fitBounds(polylineBounds.pad(0.15));
        }
      }

      route.lastResult = {
        bounds: routeBounds.isValid() ? routeBounds : polylineBounds,
        routeCoords,
        colleges: allRouteColleges,
        filters: filtersSnapshot,
        start: route.start ? { ...route.start } : null,
        end: route.end ? { ...route.end } : null
      };
      
      isProcessingRoute = false;
    })
    .catch(error => {
      console.error('Route calculation error:', error);
      // Fallback to straight line if routing fails
      const fallbackRouteCoords = [
        [route.start.lat, route.start.lon],
        [route.end.lat, route.end.lon]
      ];
      // Draw fallback route with ribbon effect
      const zoom = map ? map.getZoom() : 5;
      const routeWeights = calculateRouteLineWeights(zoom);
      
      // First draw the deep navy outline (thin line for ribbon effect)
      routeOutlinePolyline = L.polyline(
        fallbackRouteCoords,
        { 
          color: '#0A2CA5', 
          weight: routeWeights.outlineWeight, 
          opacity: routeWeights.outlineOpacity 
        }
      ).addTo(routeLayer);
      // Then draw the vivid royal blue main route line on top
      routeMainPolyline = L.polyline(
        fallbackRouteCoords,
        { 
          color: '#1A4CFF', 
          weight: routeWeights.mainWeight, 
          opacity: routeWeights.mainOpacity 
        }
      ).addTo(routeLayer);
      
      // Track route search completion (fallback route)
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_route_used');
      }
      
      const fallbackBounds = L.latLngBounds(fallbackRouteCoords);
      
      // Use simple distance calculation as fallback
      const filtered = colleges.filter(c => {
        const distToStart = calculateDistance(route.start.lat, route.start.lon, c.lat, c.lon, units);
        const distToEnd = calculateDistance(route.end.lat, route.end.lon, c.lat, c.lon, units);
        const routeLength = calculateDistance(route.start.lat, route.start.lon, route.end.lat, route.end.lon, units);
        
        // Simple approximation: if within maxDistance of the straight line
        const minDist = Math.min(distToStart, distToEnd);
        if (minDist <= maxDistance) return true;
        
        // Check if point is within corridor (rough approximation)
        const midLat = (route.start.lat + route.end.lat) / 2;
        const midLon = (route.start.lon + route.end.lon) / 2;
        const distToMid = calculateDistance(midLat, midLon, c.lat, c.lon, units);
        return distToMid <= maxDistance * 1.5; // Slightly more lenient for fallback
      });
      
      // Apply other filters
      const typeVal = elements.type ? elements.type.value.trim() : '';
      const regionVal = elements.region ? elements.region.value.trim() : '';
      const stateVal = elements.state ? elements.state.value.trim() : '';
      const searchVal = (elements.search ? elements.search.value.trim().toLowerCase() : '') || 
                        (document.getElementById('search-mobile') ? document.getElementById('search-mobile').value.trim().toLowerCase() : '');
      
      const filtersSnapshot = { typeVal, regionVal, stateVal, searchVal, maxDistance, units };
      const finalFiltered = filtered.filter(c => {
        // Type filter - check both type and tier fields
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        // Region filter - use REGION_MAP to check if state is in region
        if (regionVal) {
          const regionStates = REGION_MAP[regionVal] || [];
          if (!regionStates.includes(c.state)) return false;
        }
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        return true;
      });
      
      const fallbackRouteEntries = finalFiltered.map(c => {
        const distToStart = calculateDistance(route.start.lat, route.start.lon, c.lat, c.lon, units);
        const distToEnd = calculateDistance(route.end.lat, route.end.lon, c.lat, c.lon, units);
        const minDist = Math.min(distToStart, distToEnd);
        const distanceText = `<br>Approx. distance from route: ${minDist.toFixed(1)} ${units}`;
        return { college: c, distanceText };
      });
      const fallbackCollegeBounds = L.latLngBounds(fallbackRouteCoords);
      fallbackRouteEntries.forEach(entry => {
        fallbackCollegeBounds.extend([entry.college.lat, entry.college.lon]);
      });
      
      const visibleFallbackEntries = savedOnlyMode
        ? fallbackRouteEntries.filter(item => SavedStore.isSaved(item.college.college_id))
        : fallbackRouteEntries;
      
      if (visibleFallbackEntries.length === 0 && savedOnlyMode) {
        const savedCount = SavedStore.getAll().length;
        if (savedCount === 0) {
          console.log("You haven't saved any colleges yet. Tap a college and hit 'Save' to see it here.");
        } else {
          console.log("No saved colleges match your current filters or route.");
        }
      }
      
      // Clear and render markers (using same style as nearby mode)
      markersLayer.clearLayers();
      // Clear marker registry
      Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      visibleFallbackEntries.forEach(item => {
        addRouteCollegeMarker(item.college, item.distanceText, units);
      });
      
      if (elements.count) elements.count.textContent = visibleFallbackEntries.length;
      if (elements.loading) elements.loading.classList.remove('active');
      
      // Update map hints for route mode (fallback)
      updateMapHints(visibleFallbackEntries.length, typeVal, regionVal, stateVal, searchVal);
      if (fallbackCollegeBounds.isValid()) {
        map.fitBounds(fallbackCollegeBounds.pad(0.15));
      } else if (fallbackBounds.isValid()) {
        map.fitBounds(fallbackBounds.pad(0.15));
      }

      route.lastResult = {
        bounds: fallbackCollegeBounds.isValid() ? fallbackCollegeBounds : fallbackBounds,
        routeCoords: fallbackRouteCoords,
        colleges: fallbackRouteEntries,
        filters: filtersSnapshot,
        start: route.start ? { ...route.start } : null,
        end: route.end ? { ...route.end } : null
      };
      
      showError('Could not calculate driving route. Showing approximate results.');
      
      isProcessingRoute = false;
    });
}

// Initialize dropdowns immediately
// Region dropdown (doesn't depend on CSV)
refreshDropdown('region', ['Northeast', 'Midwest', 'South', 'West', 'Territories'], 'All regions');

// Type dropdown (initialize with common types, will be updated when CSV loads)
try {
  refreshDropdown('type', TYPE_ORDER.filter(Boolean), 'Any college type');
} catch (e) {
  console.error('Error initializing type dropdown:', e);
  // Fallback: ensure dropdown at least exists
  const typeSelect = document.getElementById('type');
  if (typeSelect) {
    typeSelect.innerHTML = '<option value="">All college types</option>';
  }
}

// Event listeners
if (elements.geocodeBtn) {
  elements.geocodeBtn.onclick = () => {
    if (activeMode === 'nearby' && elements.address) {
      hasUsedSearchControls = true; // User actively clicked Locate button
      geocodeAddress(elements.address.value, 'nearby');
    }
  };
}

// Address autocomplete
if (elements.address) {
  elements.address.addEventListener('input', debounce((e) => {
    // Don't trigger search if we're programmatically setting the value
    if (addressAutocomplete.isSelecting) {
      return;
    }
    searchAddresses(e.target.value);
  }, 400));

  elements.address.addEventListener('keydown', handleAutocompleteKeydown);
  elements.address.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.address, true);
    showAddressRecentsIfEligible();
  });
  elements.address.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.address, false);
      closeAutocomplete();
    }, 120);
  });
}

// Event delegation as backup (items have direct handlers, but this catches edge cases)
if (elements.addressSuggestions) {
  elements.addressSuggestions.addEventListener('click', (e) => {
    const item = e.target.closest('.autocomplete-item');
    if (item) {
      if (item.dataset.recent === 'true') {
        e.preventDefault();
        e.stopPropagation();
        const decodedValue = item.dataset.value ? decodeURIComponent(item.dataset.value) : '';
        handleRecentAddressSelection(decodedValue);
        return;
      }
      if (item.classList.contains('shared-location')) {
        e.preventDefault();
        e.stopPropagation();
        const field = elements.addressSuggestions?.dataset.field || 'address';
        const description = item.dataset.description ? decodeURIComponent(item.dataset.description) : '';
        handleSharedLocationSelection(field, description);
        return;
      }
      const index = parseInt(item.dataset.index, 10);
      if (!isNaN(index) && index >= 0) {
        e.preventDefault();
        e.stopPropagation();
        selectSuggestion(index);
      }
    }
  }, true);
  elements.addressSuggestions.addEventListener('mousedown', (e) => {
    if (e.target.closest('.recent-suggestion') || e.target.closest('.shared-location')) {
      e.preventDefault();
    }
  }, true);
}

// Handle route recents in suggestion containers
[elements.routeStartSuggestions, elements.routeEndSuggestions].forEach(container => {
  if (!container) return;
  container.addEventListener('click', (e) => {
    const recentItem = e.target.closest('.recent-suggestion');
    if (recentItem) {
      e.preventDefault();
      e.stopPropagation();
      const decodedValue = recentItem.dataset.value ? decodeURIComponent(recentItem.dataset.value) : '';
      handleRecentRouteSelection(decodedValue, container.dataset.recentContext || '');
      return;
    }
    const sharedItem = e.target.closest('.shared-location');
    if (sharedItem) {
      e.preventDefault();
      e.stopPropagation();
      const description = sharedItem.dataset.description ? decodeURIComponent(sharedItem.dataset.description) : '';
      const field = container.dataset.field || '';
      handleSharedLocationSelection(field, description);
    }
  }, true);
  container.addEventListener('mousedown', (e) => {
    if (e.target.closest('.recent-suggestion') || e.target.closest('.shared-location')) {
      e.preventDefault();
    }
  }, true);
});

// Close autocomplete when clicking outside
document.addEventListener('click', (e) => {
  // Only close if click is truly outside
  if (elements.address && elements.addressSuggestions && 
      !elements.address.contains(e.target) && 
      !elements.addressSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeAutocomplete();
  }
  // Close route autocompletes
  if (elements.routeStart && elements.routeStartSuggestions && 
      !elements.routeStart.contains(e.target) && 
      !elements.routeStartSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
  }
  if (elements.routeEnd && elements.routeEndSuggestions && 
      !elements.routeEnd.contains(e.target) && 
      !elements.routeEndSuggestions.contains(e.target) &&
      !e.target.closest('.autocomplete-item')) {
    closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
  }
}, true);

// Route autocomplete event listeners
if (elements.routeStart) {
  elements.routeStart.addEventListener('input', debounce((e) => {
    if (routeStartAutocomplete.isSelecting) {
      return;
    }
    searchRouteAddresses(e.target.value, routeStartAutocomplete, elements.routeStart, elements.routeStartSuggestions);
  }, 400));
  elements.routeStart.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.routeStart, true);
    showRouteRecentsIfEligible(elements.routeStart, elements.routeStartSuggestions, routeStartAutocomplete, RECENT_STORAGE_KEYS.routeStart, 'routeStart');
  });
  elements.routeStart.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.routeStart, false);
      if (elements.routeStartSuggestions) {
        closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
      }
    }, 120);
  });
}

if (elements.routeEnd) {
  elements.routeEnd.addEventListener('input', debounce((e) => {
    if (routeEndAutocomplete.isSelecting) {
      return;
    }
    searchRouteAddresses(e.target.value, routeEndAutocomplete, elements.routeEnd, elements.routeEndSuggestions);
  }, 400));
  elements.routeEnd.addEventListener('focus', () => {
    toggleAutocompleteLayer(elements.routeEnd, true);
    showRouteRecentsIfEligible(elements.routeEnd, elements.routeEndSuggestions, routeEndAutocomplete, RECENT_STORAGE_KEYS.routeEnd, 'routeEnd');
  });
  elements.routeEnd.addEventListener('blur', () => {
    setTimeout(() => {
      toggleAutocompleteLayer(elements.routeEnd, false);
      if (elements.routeEndSuggestions) {
        closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
      }
    }, 120);
  });
}

// Route search button
if (elements.findRouteBtn) {
  elements.findRouteBtn.onclick = async () => {
    // If addresses are entered but not geocoded yet, geocode them first
    if (elements.routeStart && elements.routeStart.value && !route.start) {
      const startAddress = elements.routeStart.value;
      const startResult = await geocodeAddress(startAddress, 'route');
      if (startResult) {
        route.start = { description: startAddress, lat: startResult.lat, lon: startResult.lon };
        saveRecent(RECENT_STORAGE_KEYS.routeStart, startAddress);
      }
    }
    
    if (elements.routeEnd && elements.routeEnd.value && !route.end) {
      const endAddress = elements.routeEnd.value;
      const endResult = await geocodeAddress(endAddress, 'route');
      if (endResult) {
        route.end = { description: endAddress, lat: endResult.lat, lon: endResult.lon };
        saveRecent(RECENT_STORAGE_KEYS.routeEnd, endAddress);
      }
    }
    
    hasUsedSearchControls = true; // User actively clicked Find Route button
    // Now call the route search function
    findCollegesAlongRoute();
  };
}

// Route clear button
if (elements.clearRoute) {
  elements.clearRoute.onclick = () => {
    if (elements.routeStart) elements.routeStart.value = '';
    if (elements.routeEnd) elements.routeEnd.value = '';
    if (elements.routeMaxDistance) elements.routeMaxDistance.value = '30';
    if (elements.routeUnits) elements.routeUnits.value = 'mi';
    route.start = null;
    route.end = null;
    route.lastSearch = null;
     route.lastResult = null;
    routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
    if (elements.routeStartSuggestions && elements.routeStart) {
      closeRouteAutocomplete(routeStartAutocomplete, elements.routeStartSuggestions, elements.routeStart);
    }
    if (elements.routeEndSuggestions && elements.routeEnd) {
      closeRouteAutocomplete(routeEndAutocomplete, elements.routeEndSuggestions, elements.routeEnd);
    }
    // When clearing route, show colleges based on current filter settings
    if (activeMode === 'route') {
      // Clear route visualization
      routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
      // Show all colleges filtered by type, region, state, and search
      markersLayer.clearLayers();
  // Clear marker registry
  Object.keys(markersByCollegeId).forEach(key => delete markersByCollegeId[key]);
      
      // Apply filters from dropdowns
      const stateVal = elements.state ? elements.state.value : '';
      const regionVal = elements.region ? elements.region.value : '';
      const typeVal = elements.type ? elements.type.value : '';
      const desktopSearch = elements.search;
      const mobileSearch = document.getElementById('search-mobile');
      const searchVal = (desktopSearch?.value || mobileSearch?.value || '').toLowerCase().trim();
      
      let filtered = colleges.filter(c => {
        // Region filter
        const regionMatch = !regionVal || (REGION_MAP[regionVal] || []).includes(c.state);
        if (!regionMatch) return false;
        
        // State filter
        if (stateVal && c.state !== stateVal) return false;
        
        // Type filter
        if (typeVal && (c.type || c.tier) !== typeVal) return false;
        
        // Search filter
        if (searchVal && !c.name.toLowerCase().includes(searchVal)) return false;
        
        return true;
      });
      
      // Render filtered colleges
      filtered.forEach(c => {
        try {
          if (isNaN(c.lat) || isNaN(c.lon) || c.lat === 0 || c.lon === 0) {
            return;
          }
          
          const tuition = c.tuition ? (c.tuition.toString().includes('$') ? c.tuition : `$${Number(c.tuition).toLocaleString()}`) : 'N/A';
          const acceptance = c.acceptance ? (c.acceptance.toString().includes('%') ? c.acceptance : `${parseFloat(c.acceptance).toFixed(1)}%`) : 'N/A';
          
          const saveButtonHtml = c.college_id ? `
            <div class="popup-save-row">
              <button type="button" class="popup-save-btn" data-college-id="${c.college_id}">
                <span class="popup-save-icon" aria-hidden="true">☆</span>
                <span class="popup-save-label">Save</span>
              </button>
            </div>` : '';

          const popupContent = `
            <div style="font-size:12px;line-height:1.4">
              <b>${c.name}</b><br>
              ${c.state} · ${(c.type||'Unknown')}<br>
              ${c.control ? c.control + ' | ' : ''}Acceptance Rate: ${acceptance}<br>
              Enrollment: ${c.enrollment || 'N/A'}<br>
              Tuition: ${tuition}<br>
              ${c.url ? `<a href="https://${c.url.replace(/^https?:\/\//,'')}" target="_blank">${c.url}</a>` : ''}
              ${saveButtonHtml}
            </div>`;
          
          const marker = createCollegeMarker(c, popupContent, c.college_id);
          marker.addTo(markersLayer);
        } catch (e) {
          console.error(`Error creating marker for ${c.name}:`, e);
        }
      });
      
      if (elements.count) elements.count.textContent = filtered.length.toLocaleString();
      
      // Update map hints after clearing route
      updateMapHints(filtered.length, typeVal, regionVal, stateVal, searchVal);
      
      map.setView([39.5, -98.35], 4);
    }
  };
}

if (elements.clearRadius) {
  elements.clearRadius.onclick = () => {
    if (elements.radius) elements.radius.value = '30';
    if (elements.address) elements.address.value = '';
    // Clear both desktop and mobile search fields
    if (elements.search) elements.search.value = '';
    const mobileSearch = document.getElementById('search-mobile');
    if (mobileSearch) mobileSearch.value = '';
    home = null;
    homeLayer.clearLayers();
    radiusLayer.clearLayers();
    closeAutocomplete();
    map.setView([39.5, -98.35], 4);
    render();
  };
}

// Accordion behavior for filter sections - when one opens, close the other
const filterSections = document.querySelectorAll('.filter-section');
if (filterSections.length) {
  const isMobileViewport = window.innerWidth <= 700;
  if (!isMobileViewport) {
    filterSections[0].setAttribute('open', '');
  } else {
    filterSections[0].removeAttribute('open');
  }
}
filterSections.forEach(section => {
  section.addEventListener('toggle', (e) => {
    // Remove active class from all sections first
    filterSections.forEach(s => s.classList.remove('active'));
    
    // Find the currently open section and mark it as active
    const openSection = Array.from(filterSections).find(s => s.open);
    if (openSection) {
      openSection.classList.add('active');
    }
    
    // Only act if this section is now open (was just opened)
    if (section.open) {
      // Determine which section opened
      const summary = section.querySelector('summary');
      const isNearby = summary && summary.textContent.trim().includes('Find Colleges Nearby');
      const isRoute = summary && summary.textContent.trim().includes('Find Colleges Along a Route');
      
      // Set active mode
      if (isNearby) {
        activeMode = 'nearby';
        // Clear route visualization when switching to nearby mode
        routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
        // Restore nearby state if available
        if (nearbyState.home) {
          home = nearbyState.home;
          if (elements.address && nearbyState.address) {
            elements.address.value = nearbyState.address;
          }
          if (elements.radius && nearbyState.radius) {
            elements.radius.value = nearbyState.radius;
          }
          if (elements.units && nearbyState.units) {
            elements.units.value = nearbyState.units;
          }
          // Re-apply the search and recreate the pin marker
          if (home) {
            // Clear and recreate the pin marker
            homeLayer.clearLayers();
            radiusLayer.clearLayers();
            
            // Recreate "Your Location" pin marker (red)
            const locationPinSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="30" viewBox="0 0 32 40"><path d="M16 0C7.163 0 0 7.163 0 16c0 11.045 16 24 16 24s16-12.955 16-24C32 7.163 24.837 0 16 0z" fill="#ef4444" stroke="#fff" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="#fff"/></svg>';
            L.marker([home.lat, home.lon], {
              icon: L.icon({
                iconUrl: 'data:image/svg+xml;base64,' + btoa(locationPinSvg),
                iconSize: [24, 30],
                iconAnchor: [12, 30],
                popupAnchor: [0, -30]
              })
            }).addTo(homeLayer).bindPopup('Your Location');
            
            render();
          }
        } else {
          // If no nearby state, rely on render to determine framing
          render();
        }
      } else if (isRoute) {
        activeMode = 'route';
        // Clear nearby visualization when switching to route mode
        homeLayer.clearLayers();
        radiusLayer.clearLayers();
        // Restore route state if available
        if (route.lastSearch && route.start && route.end) {
          // Restore input values
          if (elements.routeStart && route.start.description) {
            elements.routeStart.value = route.start.description;
          }
          if (elements.routeEnd && route.end.description) {
            elements.routeEnd.value = route.end.description;
          }
          if (elements.routeMaxDistance && route.lastSearch.maxDistance) {
            elements.routeMaxDistance.value = route.lastSearch.maxDistance;
          }
          if (elements.routeUnits && route.lastSearch.units) {
            elements.routeUnits.value = route.lastSearch.units;
          }
          const currentFilters = getRouteFilterSignature();
          if (route.lastResult && isRouteCacheValid(route.lastResult, currentFilters, route.start, route.end)) {
            restoreRouteFromCache(route.lastResult, { preserveView: true });
            if (!applySavedMapView('route')) {
              if (route.lastResult.bounds && route.lastResult.bounds.isValid()) {
                map.fitBounds(route.lastResult.bounds.pad(0.15));
              } else if (route.lastResult.routeCoords && route.lastResult.routeCoords.length) {
                map.fitBounds(L.latLngBounds(route.lastResult.routeCoords), { padding: [50, 50] });
              }
            }
          } else {
            // Redraw the route
            findCollegesAlongRoute();
          }
        } else {
          // If no route state, show colleges based on current filters (type, region, state, search)
          // Clear only route visualization layers, keep markers showing filtered colleges
          routeLayer.clearLayers();
  // Clear route polyline references when route is cleared
  routeOutlinePolyline = null;
  routeMainPolyline = null;
          render();
        }
      }
      
      // This section just opened, close all other sections
      filterSections.forEach(otherSection => {
        if (otherSection !== section && otherSection.open) {
          otherSection.open = false;
        }
      });
    }
  });
});

// Set initial active state for the default open section
const openSection = document.querySelector('.filter-section[open]');
if (openSection) {
  openSection.classList.add('active');
}

// Store the last user-selected state value to prevent autofill from changing it
let lastUserSelectedState = '';
let isUserChangingState = false;
let autofillWatchInterval = null;
let stateProtectionActive = true; // Always active by default

// Strong protection function to restore state value
function protectStateValue() {
  if (!elements.state || isUserChangingState) {
    return;
  }
  if (elements.state.value !== lastUserSelectedState) {
    // Autofill tried to change it - restore immediately
    elements.state.value = lastUserSelectedState;
    // Force a reflow to ensure the change is applied
    void elements.state.offsetHeight;
  }
}

// Prevent autofill from changing the state dropdown
if (elements.state) {
  // Store initial value
  lastUserSelectedState = elements.state.value;
  
  // Track when any address field is being filled (autofill detection)
  const addressFields = [elements.address, elements.routeStart, elements.routeEnd].filter(Boolean);
  
  addressFields.forEach(addressField => {
    // Store state value before address field changes
    addressField.addEventListener('focus', () => {
      lastUserSelectedState = elements.state.value;
      stateProtectionActive = true;
      // Start watching for autofill changes to state dropdown - more frequent checks
      if (autofillWatchInterval) {
        clearInterval(autofillWatchInterval);
      }
      autofillWatchInterval = setInterval(() => {
        protectStateValue();
      }, 25); // Check every 25ms during autofill window (more frequent)
    });
    
    // Handle browser autofill event (some browsers fire this)
    addressField.addEventListener('change', () => {
      protectStateValue();
    });
    
    // Handle input event (autofill can trigger this)
    addressField.addEventListener('input', () => {
      protectStateValue();
    });
    
    // Stop watching when address field loses focus, but keep protection active longer
    addressField.addEventListener('blur', () => {
      // Keep protection active for a bit longer in case autofill happens after blur
      setTimeout(() => {
        if (autofillWatchInterval) {
          clearInterval(autofillWatchInterval);
          autofillWatchInterval = null;
        }
        // Final check and restore if needed
        protectStateValue();
        // Keep protection active for 3 more seconds after blur
        setTimeout(() => {
          // Protection stays active, just stop the interval
        }, 3000);
      }, 200);
    });
  });
  
  // Continuous protection - always watch for unauthorized changes
  setInterval(() => {
    if (stateProtectionActive && !isUserChangingState) {
      protectStateValue();
    }
  }, 100); // Check every 100ms continuously
  
  // Listen for user-initiated changes to state dropdown
  elements.state.addEventListener('mousedown', () => {
    isUserChangingState = true;
    lastUserSelectedState = elements.state.value;
  });
  
  elements.state.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter' || e.key === ' ') {
      isUserChangingState = true;
      lastUserSelectedState = elements.state.value;
    }
  });
  
  elements.state.addEventListener('change', function(e) {
    const currentValue = e.target.value;
    
    // If this change was initiated by user, update stored value
    if (isUserChangingState) {
      lastUserSelectedState = currentValue;
      isUserChangingState = false;
      
      // Track state filter usage
      if (typeof gtag !== 'undefined') {
        gtag('event', 'feature_filter_state_used');
      }
      
      // Continue with normal change handling
      if (activeMode === 'route' && route.lastSearch) {
        // Re-run route search with updated filters
        findCollegesAlongRoute();
      } else {
        render();
      }
    } else {
      // This change was NOT from user - likely autofill - restore previous value
      elements.state.value = lastUserSelectedState;
      // Don't trigger render since this wasn't a real change
      return; // Prevent further processing of this change
    }
  });
  
  // Reset flag after a short delay (only if change event didn't fire)
  elements.state.addEventListener('blur', () => {
    setTimeout(() => {
      // Only reset if change event hasn't already processed it
      // Check if value changed - if it did, change event should have handled it
      if (elements.state.value === lastUserSelectedState) {
        // Value didn't change, so user didn't select anything - safe to reset
        isUserChangingState = false;
      }
    }, 200);
  });
}

['region', 'type', 'radius', 'units'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    // Track filter usage
    if (typeof gtag !== 'undefined') {
      if (id === 'type') {
        gtag('event', 'feature_filter_type_used');
      } else if (id === 'region') {
        gtag('event', 'feature_filter_region_used');
      }
    }
    
    if (activeMode === 'route' && route.lastSearch) {
      // Re-run route search with updated filters
      findCollegesAlongRoute();
    } else {
      render();
    }
  });
});

// Debounced search input - use event delegation to handle both desktop and mobile search fields
// Performance: Debounced to 300ms to avoid heavy re-renders on every keystroke
// Dropdown changes (Type, Region, State) are NOT debounced - they update immediately for better UX
document.querySelector('.controls').addEventListener('input', debounce((e) => {
  if (e.target.id === 'search' || e.target.id === 'search-mobile') {
    // Sync values between both search fields if they exist
    // Respect activeMode - only render in nearby mode, or re-run route search in route mode
    if (activeMode === 'route' && route.lastSearch) {
      findCollegesAlongRoute();
      return;
    }
    const desktopSearch = document.getElementById('search');
    const mobileSearch = document.getElementById('search-mobile');
    if (e.target.id === 'search' && mobileSearch) {
      mobileSearch.value = e.target.value;
    } else if (e.target.id === 'search-mobile' && desktopSearch) {
      desktopSearch.value = e.target.value;
    }
    render();
  }
}, 300));

// Check if running from file:// protocol (won't work due to CORS)
if (window.location.protocol === 'file:') {
  showError('Please use a web server to test this page. CSV files cannot load from file:// protocol. Use: python3 -m http.server 8000');
  console.error('Cannot load CSV from file:// protocol due to CORS restrictions');
} else {
loadCSV(DATA_URL);
}
</script>

<!-- Feedback Widget -->
<div class="feedback-button" id="feedbackButton">Feedback</div>
<div class="feedback-popup" id="feedbackPopup">
  <div class="feedback-popup-header">
    <div></div>
    <button class="feedback-popup-close" id="feedbackClose" aria-label="Close">×</button>
  </div>
  <div class="feedback-popup-message">We're improving U.S. College Map. Got 30 seconds to tell us what to fix next?</div>
  <div class="feedback-popup-button-wrapper">
    <a href="https://forms.gle/tGNzJr9THUYKfUPZ8" target="_blank" rel="noopener noreferrer" class="feedback-popup-button" style="text-decoration:none">Open feedback form</a>
  </div>
  <a href="#" class="feedback-popup-dismiss" id="feedbackDismiss">Don't show again</a>
</div>

<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E2KP0JHTMC"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-E2KP0JHTMC');
</script>

<script>
// Feedback Widget
(function() {
  'use strict';
  
  const feedbackButton = document.getElementById('feedbackButton');
  const feedbackPopup = document.getElementById('feedbackPopup');
  
  // Check if user has dismissed the feedback widget
  if (localStorage.getItem('uscm_feedback_dismissed') === 'true') {
    if (feedbackButton) feedbackButton.style.display = 'none';
    if (feedbackPopup) feedbackPopup.style.display = 'none';
    return; // Don't set up event listeners
  }
  
  const feedbackClose = document.getElementById('feedbackClose');
  const feedbackDismiss = document.getElementById('feedbackDismiss');
  
  // Open popup
  feedbackButton.addEventListener('click', function(e) {
    e.stopPropagation();
    feedbackPopup.classList.add('active');
  });
  
  // Close popup
  feedbackClose.addEventListener('click', function() {
    feedbackPopup.classList.remove('active');
  });
  
  // Dismiss permanently
  feedbackDismiss.addEventListener('click', function(e) {
    e.preventDefault();
    localStorage.setItem('uscm_feedback_dismissed', 'true');
    feedbackButton.classList.add('hidden');
    feedbackPopup.classList.remove('active');
  });
  
  // Close popup when clicking outside
  document.addEventListener('click', function(e) {
    if (feedbackPopup.classList.contains('active') && 
        !feedbackPopup.contains(e.target) && 
        !feedbackButton.contains(e.target)) {
      feedbackPopup.classList.remove('active');
    }
  });
})();
</script>

</body>
</html>
